<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>杰哥的{运维,编程,调板子}小笔记</title><description>杰哥的{运维,编程,调板子}小笔记</description><link>https://jia.je/</link><atom:link href="https://jia.je/feed_rss_created.xml" rel="self" type="application/rss+xml" /><language>en-None</language> <pubDate>Sun, 06 Aug 2023 05:44:09 -0000</pubDate> <lastBuildDate>Sun, 06 Aug 2023 05:44:09 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.8.0</generator> <item> <title>普通高校招生录取流程</title> <category>admission</category> <category>gaokao</category> <category>others</category> <description>&lt;h1&gt;普通高校招生录取流程&lt;/h1&gt;&lt;p&gt;本文是本人对普通高校招生录取流程的整理，可能有误，欢迎指出。文中不涉及一些省份的特殊情况。&lt;/p&gt;&lt;h2&gt;计划&lt;/h2&gt;&lt;p&gt;计划指的是普通高校每年要录取的新生人数，每年提前制定好，计划的组成包括：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;普通招生，预先给每个省分配一部分计划&lt;/li&gt;&lt;li&gt;预留计划，比例会在招生章程中公开，例如不超过 1%&lt;/li&gt;&lt;li&gt;非普通招生，例如特殊类型招生，各种专项&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;计划数是公开的，每年可以在各省印发的大厚本中，查看本年某高校在本省各专业组计划招收的计划数。&lt;/p&gt;&lt;p&gt;计划数通常情况下只增不减，如果需要减少，涉及到教育公平，需要有合理要求，并经过教育部审批。当然了，如果招不满，也就是满足合理要求的考生数量不足计划数，是可以把计划挪到其他地方的。&lt;/p&gt;&lt;p&gt;因此高校会预留保留计划，从预留计划调整到各省招生计划是比较容易的。但保留计划的数量有限，例如清华招生章程中，写道：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;将招生计划总数的 1% 作为预留计划，用于调节各地统考上线生源不平衡。预留计划使用时，坚持规范有序、质量优先的原则。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，上述计划针对的是高校，而不是专业。这意味着，计划只限制了每年每个高校通过每个途径或者每个省份招收多少新生。但是并不限制专业，高校在每个专业录取多少新生的方面具有较大的自主权。&lt;/p&gt;&lt;p&gt;因此在大厚本里，各专业组的计划总数是可靠的，各专业的计划数是不可靠的：实际录取的每个专业的计划数和大厚本上写的很可能不一致，但总数应当是差不多的。&lt;/p&gt;&lt;h2&gt;平行志愿&lt;/h2&gt;&lt;p&gt;考生在高考出分后，需要填报志愿，每个志愿对应一个投档单位，也就是高校的某个专业组。例如物理组要求考生选择物理，物化组要求考生选择了物理和化学。专业组的制定取决于高校，高校会根据招生章程，制定各专业组。在大厚本上，也可以看到每个专业组内有哪些专业。&lt;/p&gt;&lt;p&gt;填报志愿时，每个志愿内包含该专业组内的多个专业，考生对专业进行排序，并可以选择是否服从调剂。&lt;/p&gt;&lt;p&gt;平行志愿的意思是，投档的时候，按照分数从高到低遍历考生，按照考生的志愿查看是否满足投档条件，如果满足，则投档到对应投档单位，结束投档过程；如果不满足，则检查下一个志愿。需要注意的是，投档的时候只看志愿，也就是专业组，而不看专业。伪代码如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;pythonfor student in all_students.sort_by(score): for choice in student.all_choices: if meet(student, choice): assign(student, choice.group) break&lt;/code&gt;&lt;/p&gt;&lt;p&gt;投档条件首先是分数，要求考生的分数超过该投档单位的投档线；其次，部分投档单位有额外的限制，例如上面提到的物理化学等等。&lt;/p&gt;&lt;p&gt;再次强调，投档的时候不会看填了专业组里的哪些专业，也不会看是否选择不服从分配。&lt;/p&gt;&lt;p&gt;在平行志愿模式下，有一个很重要的现象，就是退档的时候，考生会很难再进入好的学校。观察上面的投档流程，每个学生只会投档一次，如果投档了又退档了，是不会立即投档的。而是要等到所有学生都投档和录取完成以后，部分高校没有完成招生计划，还有空余，那么在征集志愿的阶段，这些退档的学生才有机会重新填志愿，重新投档，重新录取。&lt;/p&gt;&lt;h2&gt;模拟投档&lt;/h2&gt;&lt;p&gt;上面的投档过程中，涉及到一个参数，那就是投档线。这里涉及到一个概念，投档比例（也叫调档比例）：投档的人数，相比计划数的比例。例如 100% 就是计划收 100 个学生，那就投档 100 个学生；105% 就是计划收 100 个学生，投档 105 个学生。&lt;/p&gt;&lt;p&gt;那么投档线是怎么定的呢？答案是模拟投档。在正式投档前，需要进行多轮的模拟投档，模拟投档的结果会通知各高校，各高校可以调整自己的计划和投档线，调整完以后再次模拟投档。这样多轮以后，模拟投档就会收敛到一个稳定的状态，此时各个高校都会知道自己的投档线是多少，可以投档多少个学生，也不打算修改参数了，只不过不是正式结果。&lt;/p&gt;&lt;p&gt;所以投档线并不等于录取的最后一名学生的分数线，虽然很多时候恰好相等。前文也提到，退档在平行志愿的模式下，是一个对于学生来说很吃亏的事情，因此实际上投档比例大部分时候就是 100%。具体操作是，在模拟投档的时候进行检查，如果投档比例大于 100%，而多出来的部分又不会录取进来，那就提高投档线，尽量保证投档的学生都可以录取。但如果遇到分数在中游，不服从专业调剂，同时无法满足专业，此时可能也不得不先调档再退档，同时扩大投档比例，保证有足够计划数的考生可以录取。&lt;/p&gt;&lt;p&gt;高校的招生章程会规定调档比例的上限，常见的是 105%，但这只是上限，实际大部分都是 100% 的比例，这样可以尽量减少退档的情况发生。&lt;/p&gt;&lt;p&gt;以目前的计算机性能，投档是一个很快的事情，几分钟就可以完成，所以模拟投档主要花的时间还是在高校一侧。&lt;/p&gt;&lt;h2&gt;正式投档&lt;/h2&gt;&lt;p&gt;正式投档时，会按照前述平行志愿的方式进行投档，每个考试投档到至多一个投档单位，也就是某高校的某专业组。高校进行阅档，然后对该考试进行专业的分配，选择录取到某个专业，或者选择退档。这个结果会反馈到省考试院，考试院按照教育公平的标准进行录取检查，例如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;高分考生专业优先&lt;/li&gt;&lt;li&gt;退档需给出必要理由&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中第一点保证了，如果 A 比 B 分高，且都填报了同一个专业，那么 B 能够进入这个专业的前提是 A 也能够进入这个专业。并且考生的专业录取也要按照考试填报的专业顺序进行匹配。高校招生办必须按照这个规则进行，因此其实所谓的专业分配，也就是在计算机上跑一段类似平行志愿的程序，只不过这次分配的是专业。&lt;/p&gt;&lt;p&gt;考试院可以选择审核通过，那么录取的考生就完成了整个录取流程，录取到该高校的该专业。审核不通过时，需要高校招生办重新录取。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;普通高校招生录取流程是一个十分严谨的过程，在一定程度上兼顾了公平和效率：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;公平：投档和录取都按照既定的规则执行，由计算机程序自动计算结果，结果由多位老师进行审核&lt;/li&gt;&lt;li&gt;效率：不同分数段的考生可以同时进行，不同高校之间也可以同时并行，代价是退档的风险较大&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;整个流程中大部分决策都是计算机程序自动进行计算，有限的自由在教育公平的前提下实现。&lt;/p&gt;</description><link>https://jia.je/others/2023/08/06/college-admission/</link> <pubDate>Sun, 06 Aug 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/others/2023/08/06/college-admission/</guid> </item> <item> <title>SPEC CPU 2006 性能测试</title> <category>benchmark</category> <category>software</category> <category>spec</category> <description>&lt;h1&gt;SPEC CPU 2006 性能测试&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近在网上看到龙芯 3A6000 的 SPEC CPU 2006 性能评测数据，想着自己也可以在手上的一些平台上测一测，把测试的过程记录在本文。&lt;/p&gt;</description><link>https://jia.je/software/2023/08/02/spec-cpu-2006/</link> <pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/08/02/spec-cpu-2006/</guid> </item> <item> <title>LK-99 相关链接</title> <category>lk99</category> <category>others</category> <description>&lt;h1&gt;LK-99 相关链接&lt;/h1&gt;&lt;p&gt;收录自己找到的一些和 LK-99 相关的信息，非专业人士，看个热闹。&lt;/p&gt;</description><link>https://jia.je/others/2023/08/01/lk99/</link> <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/others/2023/08/01/lk99/</guid> </item> <item> <title>记录一次 CentOS AArch64 7 到 8 的升级</title> <category>aarch64</category> <category>centos</category> <category>devops</category> <description>&lt;h1&gt;记录一次 CentOS AArch64 7 到 8 的升级&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;有一台 AArch64 机器安装了 CentOS 7，想要升级到 CentOS 8，这篇博客主要讲讲折腾的整个过程，而不是教程：如果真要说，就是不要升级 CentOS 大版本，直接重装吧。如果真的想折腾，可以看看下面的内容。&lt;/p&gt;</description><link>https://jia.je/devops/2023/07/31/upgrade-centos-aarch64-7-to-8/</link> <pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/devops/2023/07/31/upgrade-centos-aarch64-7-to-8/</guid> </item> <item> <title>VFIO - Virtual Function I/O</title> <category>driver</category> <category>linux</category> <category>pcie</category> <category>software</category> <category>vfio</category> <description>&lt;h1&gt;VFIO - Virtual Function I/O&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;VFIO 是 Linux 内核中的一个功能，目的是把 PCIe 设备暴露给用户态的程序，进而可以暴露给虚拟机内的系统，也就是常说的虚拟机 PCIe 直通。为了保证安全性，VFIO 还会配置好 IOMMU，保证用户态程序无法利用设备的 DMA 访问到其他地址空间的数据。&lt;/p&gt;&lt;p&gt;本文探讨 VFIO 暴露的用户态 API 以及如何在用户态中使用 VFIO 直接控制 PCIe 设备。&lt;/p&gt;</description><link>https://jia.je/software/2023/07/24/vfio/</link> <pubDate>Mon, 24 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/07/24/vfio/</guid> </item> <item> <title>Montgomery 模乘</title> <category>crypto</category> <category>crypto</category> <category>montgomery</category> <category>mulmod</category> <description>&lt;h1&gt;Montgomery 模乘&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;在密码学中，经常会涉及到模乘操作：$a * b \bmod N$。朴素的实现方法是，先求出 $a * b$，再对 N 进行除法，那么余数就是模乘的结果。&lt;/p&gt;&lt;p&gt;但由于此时的 $a$ $b$ $N$ 三个数都很大，在计算机上需要用大整数来表示，而大整数的乘法和除法都是需要耗比较多的时间的。如果用 Schönhage–Strassen 算法，计算两个 $n$ 位大整数的乘法需要的时间是 $O(n \log(n) \log(\log(n)))$。&lt;/p&gt;&lt;h2&gt;定义&lt;/h2&gt;&lt;p&gt;Montgomery 模乘是一种提高模乘的性能的方法。具体地，Montgomery 模乘需要一个参数 $R$ 满足 $R$ 和 $N$ 互质，且 $R &amp;gt; N$，那么 Montgomery 模乘实现的是如下计算：&lt;/p&gt;&lt;p&gt;$$M(a, b) = a * b * R^{-1} \bmod N$$&lt;/p&gt;</description><link>https://jia.je/crypto/2023/07/23/montgomery-mul-mod/</link> <pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/crypto/2023/07/23/montgomery-mul-mod/</guid> </item> <item> <title>libc++ 的 uniform_int_distribution 性能问题</title> <category>cpp</category> <category>programming</category> <category>random</category> <category>sampling</category> <category>stl</category> <description>&lt;h1&gt;libc++ 的 uniform_int_distribution 性能问题&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;前段时间，@lwpie 发现一段 C++ 代码在 macOS 下，分别用自带的 Clang 编译和用 Homebrew 的 GCC 编译，性能差距接近一个数量级，下面是运行时间：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;GCC-13 Homebrew: 300&lt;/li&gt;&lt;li&gt;Apple Clang: 2170&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/programming/2023/07/22/uniform-int-distribution-performance/</link> <pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/programming/2023/07/22/uniform-int-distribution-performance/</guid> </item> <item> <title>写一个 bash zsh 和 fish 都能跑的脚本</title> <category>bash</category> <category>fish</category> <category>programming</category> <category>shell</category> <category>zsh</category> <description>&lt;h1&gt;写一个 bash zsh 和 fish 都能跑的脚本&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;bash 和 zsh 都实现了 POSIX shell 标准，因此写脚本的时候，比较容易兼容这两种常见的 shell。但现在 fish 也很流行，而 fish 不符合 POSIX shell 标准，很多地方语法多不兼容，能否写一个脚本，可以用 bash，zsh 和 fish 跑？&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;The following commands should work&lt;/h1&gt;&lt;p&gt;bash test.shzsh test.shfish test.sh```&lt;/p&gt;</description><link>https://jia.je/programming/2023/07/18/portable-script-across-bash-zsh-fish/</link> <pubDate>Tue, 18 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/programming/2023/07/18/portable-script-across-bash-zsh-fish/</guid> </item> <item> <title>把博客生成器从 Hugo 迁移到 Mkdocs</title> <category>meta</category> <category>site</category> <description>&lt;h1&gt;把博客生成器从 Hugo 迁移到 Mkdocs&lt;/h1&gt;&lt;p&gt;距离上一次 &lt;a href=&#34;migrate-from-jekyll-to-hugo.md&#34;&gt;Jekyll 迁移到 Hugo&lt;/a&gt; 已经过去了四年，这次正好 mkdocs-material 发了新的 beta 版本，加入了对博客的支持，所以就当小白鼠，把博客迁移到了 Mkdocs + Mkdocs-Material。&lt;/p&gt;&lt;p&gt;这次迁移比较顺利，除了 tag 和 category 少了一些页面以外，原来的文章的链接都是正常的。为什么要迁移呢，主要是最近写各种文档，Mkdocs 用的比较多，但是 Mkdocs 的 Markdown 很多地方和 Hugo 不太一样，下面列一些最难以忍受的 Hugo 的问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数学公式：Hugo 的 &lt;code&gt;\&lt;/code&gt; 需要转义，导致很多地方写数学公式都很麻烦，然后因为我经常要在 Hugo 和 Mkdocs 之间复制 Markdown，此时就需要很多手动工作。&lt;/li&gt;&lt;li&gt;资源路径：Hugo 的资源路径默认都是绝对路径，要引用其他文章的话，要么用啰嗦的 relref，要么就写绝对路径，比较头疼。Mkdocs 就很好，自动检测，帮我计算出实际的地址。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;迁移的时候有很多细节上的不同，不过基本靠 VSCode 的正则表达式替换解决了。&lt;/p&gt;&lt;p&gt;不过，Mkdocs 又出现了 Jekyll 的老问题，就是性能比较差。当然了，不一定是 Mkdocs 本身的问题，也可能是 Mkdocs-Material 加各种插件的问题，目前还有待观察。无论如何，Python 调起来总归是比 Ruby 要容易。希望不要在未来的某一天，由从 Mkdocs 迁移回 Hugo。&lt;/p&gt;</description><link>https://jia.je/meta/2023/07/15/migrate-from-hugo-to-mkdocs/</link> <pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/meta/2023/07/15/migrate-from-hugo-to-mkdocs/</guid> </item> <item> <title>ECDSA</title> <category>crypto</category> <category>crypto</category> <category>ecc</category> <category>ecdsa</category> <description>&lt;h1&gt;ECDSA&lt;/h1&gt;&lt;p&gt;ECDSA 是一个基于椭圆曲线的签名算法，使用时需要确定一个椭圆曲线，以及它的 base point $G$，且 $G$ 的阶是素数 $n$。ECDSA 支持如下的操作：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;生成签名&lt;/li&gt;&lt;li&gt;验证签名&lt;/li&gt;&lt;li&gt;从签名和明文推导出公钥&lt;/li&gt;&lt;/ol&gt;</description><link>https://jia.je/crypto/2023/07/14/ecdsa/</link> <pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/crypto/2023/07/14/ecdsa/</guid> </item> <item> <title>在 Apple M1 上试用 Gentoo/Prefix</title> <category>devops</category> <category>gentoo</category> <category>gentoo-prefix</category> <category>m1</category> <category>macos</category> <description>&lt;h1&gt;在 Apple M1 上试用 Gentoo/Prefix&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;上一次折腾 Gentoo/Prefix 是&lt;a href=&#34;try-gentoo-prefix-on-macOS.md&#34;&gt;五年多以前&lt;/a&gt;，当时还是用的 Intel Mac，最近需要探索一下在现在的 macOS 系统上用 Gentoo/Prefix 会遇到哪些问题，因此今天在 Apple M1 上重新尝试一次。&lt;/p&gt;</description><link>https://jia.je/devops/2023/07/08/gentoo-prefix-m1/</link> <pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/devops/2023/07/08/gentoo-prefix-m1/</guid> </item> <item> <title>生成树协议</title> <category>mstp</category> <category>networking</category> <category>pvst</category> <category>rstp</category> <category>stp</category> <category>vbst</category> <description>&lt;h1&gt;生成树协议&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/networking/spanning_tree_protocol.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;Spanning Tree Protocol&lt;/h2&gt;&lt;p&gt;STP（Spanning Tree Protocol）可以在 &lt;a href=&#34;https://ieeexplore.ieee.org/document/1389253&#34;&gt;802.1D-1998&lt;/a&gt; 第 8 章中找到。STP 协议工作在交换机上，需要根据交换机连接的拓扑，自动计算出一个生成树，并且把不在生成树上的边禁用，这样即使连接的拓扑有环路，禁用以后就没有环了。有了 STP 以后，连接交换机的时候就可以刻意连成环，从而提供冗余。&lt;/p&gt;</description><link>https://jia.je/networking/2023/06/20/spanning-tree-protocol/</link> <pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/networking/2023/06/20/spanning-tree-protocol/</guid> </item> <item> <title>从 libvirtd 迁移到 Proxmox VE</title> <category>libvirtd</category> <category>proxmoxve</category> <category>pve</category> <category>qemu</category> <category>software</category> <description>&lt;h1&gt;从 libvirtd 迁移到 Proxmox VE&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;之前用 libvirtd + virt-manager 做 Linux 上的虚拟化，好处是比较轻量级，但是远程控制起来比较麻烦，要么通过 RDP 访问 virt-manager 的 UI，要么就用 cockpit 在网页里去配置虚拟机。此时就会比较怀念 VMware ESXi 的网页，但是 ESXi 装完以后，宿主机就很不自由了，很多东西没法自定义。最后就想到在 Debian 上装一个 Proxmox VE，希望得到一个比较好的中间态。&lt;/p&gt;</description><link>https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</link> <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</guid> </item> <item> <title>LoongArch 初尝试</title> <category>hardware</category> <category>la32</category> <category>la32r</category> <category>la64</category> <category>loongarch</category> <category>qemu</category> <description>&lt;h1&gt;LoongArch 初尝试&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近应龙芯要求把监控程序移植到了 LoongArch 32 Reduced 架构上，趁此机会体验了一下 LoongArch 相关的软件和系统。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/06/12/try-loongarch/</link> <pubDate>Mon, 12 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/06/12/try-loongarch/</guid> </item> <item> <title>Tar 文件格式</title> <category>software</category> <category>tar</category> <description>&lt;h1&gt;Tar 文件格式&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/software/tar.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近在解压 tar.gz 文件的时候，发现如果用 unar 解压，就会出现文件名截断到 100 个字节的问题，而如果用 gnu tar 解压，文件名就是正常的，因此深入研究了一下 Tar 的文件格式。实际上，这是因为早期 tar 格式设计的时候，就设定了路径最长 100 字节的限制，后来的扩展解决了这个问题，但是 unar 没能正确地识别扩展，导致解压路径出错。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/23/tar-format/</link> <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/23/tar-format/</guid> </item> <item> <title>使用 Docker 部署 OpenLDAP</title> <category>docker</category> <category>ldap</category> <category>openldap</category> <category>software</category> <description>&lt;h1&gt;使用 Docker 部署 OpenLDAP&lt;/h1&gt;&lt;p&gt;OpenLDAP 是一个开源的用户系统实现，主要支持 LDAP 协议，可以给其他系统提供用户认证。下面讨论了如何在 Docker 中部署 OpenLDAP。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/13/openldap-in-docker/</link> <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/13/openldap-in-docker/</guid> </item> <item> <title>使用 JLink 操作 SPI NOR Flash</title> <category>flash</category> <category>hardware</category> <category>jflash</category> <category>jlink</category> <category>nor</category> <category>spi</category> <description>&lt;h1&gt;使用 JLink 操作 SPI NOR Flash&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近设计了一款 &lt;a href=&#34;https://github.com/jiegec/PMOD-SPI-NOR-FLASH&#34;&gt;PMOD SPI NOR Flash&lt;/a&gt; 扩展板，搭载了 W25Q128 SPI NOR Flash 芯片。在 jlc 生产回来以后，通过 JLink 连接到电脑上进行测试，看看是否可以用 JLink 操作 SPI NOR Flash。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/05/08/jlink-spi-nor-flash/</link> <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/05/08/jlink-spi-nor-flash/</guid> </item> <item> <title>链接器的工作原理</title> <category>ld</category> <category>linker</category> <category>software</category> <description>&lt;h1&gt;链接器的工作原理&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近和同学讨论一些比较复杂的链接问题，遇到一些比较复杂的情况，因此复习一遍链接器的工作原理，在这里总结工作原理和常见的问题。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linker/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linker/</guid> </item> <item> <title>How a Linux 6.2.13 BUG stops Vivado from recognizing FPGA</title> <category>linux</category> <category>software</category> <category>vivado</category> <description>&lt;h1&gt;How a Linux 6.2.13 BUG stops Vivado from recognizing FPGA&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;linux-regression-vivado.md&#34;&gt;中文版本&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TLDR&lt;/h2&gt;&lt;p&gt;In short, the commit introduced by Linux 6.2.13:&lt;/p&gt;&lt;p&gt;```commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;While fixing a BUG, a new BUG is introduced, causing MAP_32BIT to fail to work sometimes, and Xilinx&#39;s Digilent driver uses this parameter, causing mmap to fail and unable to recognize the FPGA.&lt;/p&gt;&lt;p&gt;The new BUG has been fixed in &lt;a href=&#34;https://lore.kernel.org/linux-mm/20230505145829.74574-1-zhangpeng.00@bytedance.com/&#34;&gt;[PATCH v2] maple_tree: Make maple state reusable after mas_empty_area()&lt;/a&gt;.&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linux-regression-vivado-en/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linux-regression-vivado-en/</guid> </item> <item> <title>Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA</title> <category>linux</category> <category>software</category> <category>vivado</category> <description>&lt;h1&gt;Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;linux-regression-vivado-en.md&#34;&gt;English version&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TLDR&lt;/h2&gt;&lt;p&gt;简单来说，Linux 6.2.13 引入的 commit：&lt;/p&gt;&lt;p&gt;```commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;修复了 BUG 的同时，引入了新的 BUG，导致 MAP_32BIT 有时无法工作，而 Xilinx 的 Digilent 下载器代码使用了这个参数，导致 mmap 失败，无法识别 FPGA。&lt;/p&gt;&lt;p&gt;新 BUG 在 &lt;a href=&#34;https://lore.kernel.org/linux-mm/20230505145829.74574-1-zhangpeng.00@bytedance.com/&#34;&gt;[PATCH v2] maple_tree: Make maple state reusable after mas_empty_area()&lt;/a&gt; 中被修复。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linux-regression-vivado/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_created.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linux-regression-vivado/</guid> </item> </channel></rss>