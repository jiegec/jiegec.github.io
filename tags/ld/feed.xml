<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ld on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/ld/</link>
    <description>Recent content in ld on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Feb 2021 19:02:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/ld/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>COMMON 符号</title>
      <link>https://jia.je/software/2021/02/09/common-symbols-linking/</link>
      <pubDate>Tue, 09 Feb 2021 19:02:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2021/02/09/common-symbols-linking/</guid>
      <description>背景 在编译一个程序的时候，遇到了 undefined symbol 的问题。具体情况是这样的：
 一开始的时候，直接把所有的源代码编译成 .o，再一次性链接，这样不会报错 后来，把一些代码编译成静态库，即把其中一部分源代码编译成 .o 后，用 ar 合并到一个 .a 中，再和其余的 .o 链接在一起，这时候就报错了：  Undefined symbols for architecture arm64: &amp;#34;_abcd&amp;#34;, referenced from: ... 如果换台机器，编译（使用的是 gcc 10.2.0）就没有问题。
而如果去找这个符号存在的 .o 里，是可以找到的：
$ objdump -t /path/to/abcd.o 0000000000000028 *COM* 00000008 _abcd 在合成的静态库 .a 里，也是存在的（一个定义+若干个引用）：
$ objdump -t /path/to/libabc.a | grep abcd 0000000000000028 *COM* 00000008 _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 于是觉得很奇怪，就上网搜了一下，找到了一篇 StackOverflow 讲了这个问题。解决方案很简单，就是：</description>
    </item>
    
    <item>
      <title>Rust 获取 Linker Script 中的地址</title>
      <link>https://jia.je/programming/2019/01/07/rust-access-linker-script-address/</link>
      <pubDate>Mon, 07 Jan 2019 11:57:00 +0800</pubDate>
      
      <guid>https://jia.je/programming/2019/01/07/rust-access-linker-script-address/</guid>
      <description>在 Linker Script 中可以记录下一个地址到一个变量中，大概这样：
.text: { PROVIDE(__text_start = .); *(.text .text.* .gnu.linkonce.t*) PROVIDE(__text_end = .); } 这里的 PROVIDE() 是可选的。这样，代码里就可以获取到 .text 段的地址了。在 C 中，直接 extern 一个同名的变量就可以了，但在 Rust 中，需要这样获取：
extern &amp;#34;C&amp;#34; { fn __text_start(); fn __text_end(); } // __text_start as usize // __text_end as usize 这样就可以拿到地址了。</description>
    </item>
    
  </channel>
</rss>
