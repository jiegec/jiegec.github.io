<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>debug on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/debug/</link>
    <description>Recent content in debug on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 May 2022 08:35:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/debug/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>向 Rocket Chip 添加自定义调试信号</title>
      <link>https://jia.je/hardware/2022/05/13/rocket-chip-custom-debug/</link>
      <pubDate>Fri, 13 May 2022 08:35:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/05/13/rocket-chip-custom-debug/</guid>
      <description>背景 最近在尝试把核心作为一个 Tile 加到 Rocket System 中，所以想要把核心之前自定义的调试信号接到顶层上去。Rocket System 自带的支持是 trace，也就是输出每个周期 retire 的指令信息，但和自定义的不大一样，所以研究了一下怎么添加自定义的调试信号，并且连接到顶层。
分析 Trace 信号连接方式 首先，观察 Rocket Chip 自己使用的 Trace 信号是如何连接到顶层的。在顶层上，可以找到使用的是 testchipip.CanHaveTraceIO:
trait CanHaveTraceIO { this: HasTiles =&amp;gt;  val module: CanHaveTraceIOModuleImp   // Bind all the trace nodes to a BB; we&amp;#39;ll use this to generate the IO in the imp  val traceNexus = BundleBridgeNexusNode[Vec[TracedInstruction]]()  val tileTraceNodes = tiles.flatMap {  case ext_tile: WithExtendedTraceport =&amp;gt; None  case tile =&amp;gt; Some(tile)  }.</description>
    </item>
    
    <item>
      <title>「教学」RISC-V Debug 协议</title>
      <link>https://jia.je/hardware/2021/12/12/riscv-debug/</link>
      <pubDate>Sun, 12 Dec 2021 14:01:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/12/riscv-debug/</guid>
      <description>背景 之前用过一些 RISC-V 核心，但是遇到调试相关的内容的时候就两眼一抹黑，不知道原理，出了问题也不知道如何排查，趁此机会研究一下工作原理。
架构 为了调试 RISC-V 核心，需要很多部件一起工作。按 RISC-V Debug Spec 所述，有这么几部分：
 Debugger: GDB，连接到 OpenOCD 启动的 GDB Server Debug Translator: OpenOCD，向 GDB 提供 Server 实现，同时会通过 FTDI 等芯片控制 JTAG Debug Transport Hardware: 比如 FTDI 的芯片，可以提供 USB 接口，让 OpenOCD 控制 JTAG 信号 TMS/TDI/TCK 的变化，并读取 TDO Debug Transport Module: 在芯片内部的 JTAG 控制器（TAP），符合 JTAG 标准 Debug Module Interface：RISC-V 自定义的一系列寄存器，通过这些寄存器来控制 Debug Module 的行为 Debug Module：调试器，控制 RISC-V 核心，同时也支持直接访问总线，也有内部的 Program Buffer  可以看到，DMI 是实际的调试接口，而 JTAG 可以认为是一个传输协议。</description>
    </item>
    
  </channel>
</rss>
