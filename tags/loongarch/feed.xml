<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>loongarch on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/loongarch/</link>
    <description>Recent content in loongarch on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Jun 2023 22:51:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/loongarch/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LoongArch 初尝试</title>
      <link>https://jia.je/hardware/2023/06/12/try-loongarch/</link>
      <pubDate>Mon, 12 Jun 2023 22:51:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/06/12/try-loongarch/</guid>
      <description>背景 最近应龙芯要求把监控程序移植到了 LoongArch 32 Reduced 架构上，趁此机会体验了一下 LoongArch 相关的软件和系统。
在 QEMU 中运行 LoongArch Arch Linux 主页：https://github.com/loongarchlinux
环境：Debian Bookworm
QEMU 启动流程，参考官方文档：
wget https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/archlinux-xfce4-2023.05.10-loong64.qcow2.zst zstd -d archlinux-xfce4-2023.05.10-loong64.qcow2.zst wget https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/QEMU_EFI_7.2.fd 然后就可以启动 QEMU 7.2.2 了：
qemu-system-loongarch64 \ -m 4G \ -cpu la464-loongarch-cpu \ -machine virt \ -smp 4 \ -bios ./QEMU_EFI_7.2.fd \ -serial stdio \ -device virtio-gpu-pci \ -net nic -net user \ -device nec-usb-xhci,id=xhci,addr=0x1b \ -device usb-tablet,id=tablet,bus=xhci.0,port=1 \ -device usb-kbd,id=keyboard,bus=xhci.0,port=2 \ -hda archlinux-xfce4-2023.05.10-loong64.qcow2 启动后，可以正常看到 Xfce4 的界面，用 loongarch:loongarch 登录：</description>
    </item>
    
    <item>
      <title>LoongArch64 工具链构建</title>
      <link>https://jia.je/software/2022/05/02/loongarch64-toolchain/</link>
      <pubDate>Mon, 02 May 2022 20:35:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2022/05/02/loongarch64-toolchain/</guid>
      <description>最近因为龙芯杯的原因，想自己搞个 LoongArch64 的交叉编译工具链试试，结果遇到了很多坑，最后终于算是搞出来了。
一开始是想搞一个 newlib 的工具链，比较简单，而且之前做过一个仓库：jiegec/riscv-toolchain，就是构建的 riscv64-unknown-elf 工具链，照着 riscv-gnu-toolchain 就可以了。不过研究发现，newlib 还不支持 loongarch，目前只有 glibc 支持，只好硬着头皮上了。
于是我就在 riscv-toolchain 的基础上搞 loongarch64-unknown-linux-gnu，也就是带 glibc 的工具链，结果发现遇到很多坑。首先编译 libgcc 的时候就找不到头文件，于是先要从 glibc 和 linux 安装头文件到 sysroot 里面，对于 sysroot 里面的头文件路径到底是 include 还是 usr/include 也折腾了半天。然后编译 libgcc 又各种出问题，最后折腾了半天，结果是 gcc stage1 和 glibc 都没问题，gcc stage2 会报链接错误，但是不管它也能用，可以编译出正常的程序，毕竟 libc 是好的。
于是转念一想，要不要试试 crosstool-ng。克隆了一份上游的版本，照着 riscv 的部分抄了一份变成了 loongarch，然后把 config 里面的 linux/glibc/gcc/binutils-gdb 都替换为 custom location，这样我就可以用上游的最新版本了。中途还遇到了 crosstool-ng 对 gcc 12/13 不兼容的 bug，还好下面有人提出了解决方法。这些都搞定以后，终于构建出了一个完整的 loongarch64-unknown-linux-gnu 工具链。仓库地址是 jiegec/ct-ng-loongarch64，需要配合添加了 LoongArch 的 jiegec/crosstool-ng loongarch 分支 使用。</description>
    </item>
    
  </channel>
</rss>
