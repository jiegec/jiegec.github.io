<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>qemu on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/qemu/</link>
    <description>Recent content in qemu on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Jun 2023 16:03:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/qemu/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>从 libvirtd 迁移到 Proxmox VE</title>
      <link>https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</link>
      <pubDate>Thu, 15 Jun 2023 16:03:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</guid>
      <description>背景 之前用 libvirtd + virt-manager 做 Linux 上的虚拟化，好处是比较轻量级，但是远程控制起来比较麻烦，要么通过 RDP 访问 virt-manager 的 UI，要么就用 cockpit 在网页里去配置虚拟机。此时就会比较怀念 VMware ESXi 的网页，但是 ESXi 装完以后，宿主机就很不自由了，很多东西没法自定义。最后就想到在 Debian 上装一个 Proxmox VE，希望得到一个比较好的中间态。
Proxmox VE 安装 按照官方的 Install Proxmox VE on Debian 11 Bullseye 去安装即可。我的环境是 Debian Bookworm，把路径改成 Bookworm 的 pvetest 即可。安装的时候可能会遇到一些小问题，例如用 ifupdown2 替换 ifupdown 的时候会检查 config 是否正确等等。安装完以后重启，就可以用 root 用户访问 Proxmox VE 了。
迁移 libvirtd 虚拟机 下一步是迁移 libvirtd 虚拟机。在网上搜索，会看到提供的方法是，在 Proxmox VE 里创建一个同样大小的镜像，然后把原来的 qcow2 的数据复制一份，但是这样复制的时候得存两份数据，而且对稀疏 qcow2 的支持也不太好。
最后实际的解决办法是：在 Proxmox VE 里创建一个和 qcow2 大小一样的镜像，设置为 qcow2 格式，然后去 /var/lib/vz/images 路径下找到新建的 qcow2，直接用原来 libvirtd 创建的 qcow2 覆盖过去。目前来看，还没有遇到问题，毕竟 ProxmoxVE 用的也是 QEMU，和 libvirtd 一样。</description>
    </item>
    
    <item>
      <title>LoongArch 初尝试</title>
      <link>https://jia.je/hardware/2023/06/12/try-loongarch/</link>
      <pubDate>Mon, 12 Jun 2023 22:51:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/06/12/try-loongarch/</guid>
      <description>背景 最近应龙芯要求把监控程序移植到了 LoongArch 32 Reduced 架构上，趁此机会体验了一下 LoongArch 相关的软件和系统。
在 QEMU 中运行 LoongArch Arch Linux 主页：https://github.com/loongarchlinux
环境：Debian Bookworm
QEMU 启动流程，参考官方文档：
wget https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/archlinux-xfce4-2023.05.10-loong64.qcow2.zst zstd -d archlinux-xfce4-2023.05.10-loong64.qcow2.zst wget https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/QEMU_EFI_7.2.fd 然后就可以启动 QEMU 7.2.2 了：
qemu-system-loongarch64 \ -m 4G \ -cpu la464-loongarch-cpu \ -machine virt \ -smp 4 \ -bios ./QEMU_EFI_7.2.fd \ -serial stdio \ -device virtio-gpu-pci \ -net nic -net user \ -device nec-usb-xhci,id=xhci,addr=0x1b \ -device usb-tablet,id=tablet,bus=xhci.0,port=1 \ -device usb-kbd,id=keyboard,bus=xhci.0,port=2 \ -hda archlinux-xfce4-2023.05.10-loong64.qcow2 启动后，可以正常看到 Xfce4 的界面，用 loongarch:loongarch 登录：</description>
    </item>
    
    <item>
      <title>在 libvirt 中运行 RISC-V 虚拟机</title>
      <link>https://jia.je/software/2022/05/31/qemu-rv64-in-libvirt/</link>
      <pubDate>Tue, 31 May 2022 09:22:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2022/05/31/qemu-rv64-in-libvirt/</guid>
      <description>背景 我在 libvirt 中跑了几个 KVM 加速的虚拟机，然后突发奇想，既然 libvirt 背后是 qemu，然后 qemu 是支持跨指令集的，那是否可以让 libvirt 来运行 RISC-V 架构的虚拟机？经过一番搜索，发现可以跑 ARM：How To: Running Fedora-ARM under QEMU，既然如此，我们也可以试试用 libvirt 来运行 RV64 虚拟机。
准备 rootfs 第一步是根据 Debian 的文档 Creating a riscv64 chroot 来创建 rootfs，然后再用 virt-make-fs 来打包。
首先是用 mmdebstrap 来生成一个 chroot：
$ sudo mkdir -p /tmp/riscv64-chroot $ sudo apt install mmdebstrap qemu-user-static binfmt-support debian-ports-archive-keyring $ sudo mmdebstrap --architectures=riscv64 --include=&amp;#34;debian-ports-archive-keyring&amp;#34; sid /tmp/riscv64-chroot &amp;#34;deb http://deb.debian.org/debian-ports sid main&amp;#34; &amp;#34;deb http://deb.debian.org/debian-ports unreleased main&amp;#34; 进入 chroot 以后，进行一些配置：</description>
    </item>
    
    <item>
      <title>在 M1 上用 QEMU 运行 Debian 虚拟机</title>
      <link>https://jia.je/software/2021/01/02/aarch64-debian-in-qemu-m1/</link>
      <pubDate>Sat, 02 Jan 2021 13:05:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2021/01/02/aarch64-debian-in-qemu-m1/</guid>
      <description>背景 看到 @jsteward 在 M1 的 QEMU 中运行了 Windows on ARM，所以我先来试试 Debian on AArch64，这样会简单一些。
参考：https://gist.github.com/niw/e4313b9c14e968764a52375da41b4278#file-readme-md
大约需要 3G 的硬盘空间。
安装 QEMU w/ M1 patches 目前上游的 QEMU 还不支持 M1 的 Hypervisor framework，需要打 patch：
git clone https://mirrors.tuna.tsinghua.edu.cn/git/qemu.git cd qemu git checkout master -b wip/hvf curl &amp;#39;https://patchwork.kernel.org/series/400619/mbox/&amp;#39;|git am --3way mkdir build cd build ../configure --target-list=aarch64-softmmu --enable-cocoa --disable-gnutls make -j4 编译后，得到 qemu-system-aarch64 的二进制
准备好文件系统 需要下载 EFI 固件 和 Debian 安装镜像，解压前者以后把文件放同一个目录中，并且创建需要的文件：
$ ls *.fd QEMU_EFI.fd QEMU_VARS.fd $ dd if=/dev/zero of=pflash0.</description>
    </item>
    
    <item>
      <title>体验 Fedora on RISCV</title>
      <link>https://jia.je/os/2018/05/24/trying-fedora-on-riscv/</link>
      <pubDate>Thu, 24 May 2018 23:40:00 +0800</pubDate>
      
      <guid>https://jia.je/os/2018/05/24/trying-fedora-on-riscv/</guid>
      <description>看到 RISCV 很久了，但一直没能体验。最近工具链不断更新，QEMU 在 2.12.0 也正式加入了 riscv 的模拟。但是自己编译一个内核又太麻烦，就找到了 Fedora 做的 RISCV port，下载下来试用了一下。之前试过一次，但是遇到了一些问题，刚才总算是成功地搞出来了。
官方文档地址：https://fedorapeople.org/groups/risc-v/disk-images/readme.txt 首先下载 https://fedorapeople.org/groups/risc-v/disk-images/ 下的 bbl vmlinux 和 stage4-disk.img.xz 三个文件，然后解压 stage4-disk.img.xz，大约有 5G 的样子。之前作者在脚本里作死开得特别大，导致我以前光是解压这一步就成功不了。现在终于解决了。
然后启动 qemu 命令打开虚拟机：
qemu-system-riscv64 \ -nographic \ -machine virt \ -m 2G \ -kernel bbl \ -object rng-random,filename=/dev/urandom,id=rng0 \ -device virtio-rng-device,rng=rng0 \ -append &amp;#34;console=ttyS0 ro root=/dev/vda&amp;#34; \ -device virtio-blk-device,drive=hd0 \ -drive file=stage4-disk.img,format=raw,id=hd0 \ -device virtio-net-device,netdev=usernet \ -netdev user,id=usernet,hostfwd=tcp::10000-:22 这段命令摘自 readme.txt，区别只在于把 -smp 4 去掉了。不知道为什么不能正常工作，可能和作者提到的 FPU patch 有关。然后系统就可以正常起来了（firewalld 和 systemd-logind 不止为啥起不来，但是不用管）。</description>
    </item>
    
  </channel>
</rss>
