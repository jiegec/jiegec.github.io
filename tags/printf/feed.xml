<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>printf on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/printf/</link>
    <description>Recent content in printf on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Apr 2023 09:24:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/printf/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C/C&#43;&#43; 数参数个数的特别方法</title>
      <link>https://jia.je/programming/2023/04/14/counting-arguments/</link>
      <pubDate>Fri, 14 Apr 2023 09:24:00 +0800</pubDate>
      
      <guid>https://jia.je/programming/2023/04/14/counting-arguments/</guid>
      <description>背景 群友上个月提了一个未知来源问题：
实现一个你自己的 printf(int, ...) 函数，该函数包含可变参数。为简便期间，假设所有参数均为 int 类型。
第一个参数是一个普通参数，不表示后续可变参数的数目 在 printf 中逐个输出所有传入的整数值（可使用系统自带的 kprintf 实现输出） 思考如何判定参数结束，是否有副作用 va_args 我们知道，传统的处理可变参数的方法是 va_args，但是它无法知道传入了多少参数，而要像 POSIX printf 那样，解析 format 参数，然后一个一个去取。
所以问题的关键是，如何获取参数的个数？一个思路是宏，尝试用宏的魔法来计算出参数个数，这个方法可能是可以的，但是没有深究。另一个思路是利用 ABI 的特点，例如 i386 上参数是通过栈传递的，那或许可以在栈上找到所有的 int，但是问题是无法确认参数在哪里结束。
__builtin_va_arg_pack_len 今天，另一位群友发了一个链接：https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls，讲述了 GCC 中一些特别的 builtin 函数，用于函数调用相关的魔法，其中一段描述吸引了我的眼球：
Built-in Function: int __builtin_va_arg_pack_len () This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using __attribute__ ((__always_inline__)) or __attribute__ ((__gnu_inline__)) extern inline functions.</description>
    </item>
    
  </channel>
</rss>
