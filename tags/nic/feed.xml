<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nic on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/nic/</link>
    <description>Recent content in nic on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Mar 2023 22:30:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/nic/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软硬件队列接口</title>
      <link>https://jia.je/networking/2023/03/22/hardware-queue-interface/</link>
      <pubDate>Wed, 22 Mar 2023 22:30:00 +0800</pubDate>
      
      <guid>https://jia.je/networking/2023/03/22/hardware-queue-interface/</guid>
      <description>背景 在网卡等场景下，经常会需要在软硬件之间传输大量的数据，通常的方法是建立循环队列，例如 H2C（Host to Chip）方向，是 Host 作为 Producer 增加数据到队尾，Chip 作为 Consumer 从队头读取数据。由于每次传输的数据不定长，为了方便，队列的项是一个定长的 Descriptor，Descriptor 指向了数据的地址。但具体的细节，不同的实现还不太一样。下面逐个案例进行分析。
AXI DMA 文档：https://docs.xilinx.com/r/en-US/pg021_axi_dma
如果在 Xilinx FPGA 上使用过以太网，那大概率会接触到 AXI DMA 这个 IP，它负责把以太网 MAC 的 AXI Stream 数据用 DMA 的形式通过内存来与操作系统交互。
发送队列 它的收和发各是一个队列，首先来看发送队列：
发送队列由一个头指针（MM2S_CURDESC）和一个尾指针定义（MM2S_TAILDESC），指针指向的是一个 Scatter Gather Descriptor，Descriptor 的内容包括：
NXTDESC：队列下一项的地址 BUFFER_ADDRESS：要传输的数据的地址 CONTROL：控制信息 STATUS：状态信息 APP0 to APP4：附带的信息 可见这个发送队列实际上是一个链表：
struct axi_dma_desc { struct axi_dma_desc *nxtdesc; void *buffer_address; // omitted }; 当 MM2S_TAILDESC 被更新的时候，硬件会从 CURDESC 开始逐个 Descriptor 处理，直到遇到 TAILDESC 为止：
// when taildesc is changed void taildesc_changed() { do { dma_send(curdesc); if (curdesc !</description>
    </item>
    
  </channel>
</rss>
