<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>chisel on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/chisel/</link>
    <description>Recent content in chisel on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Apr 2023 20:33:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/chisel/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>firtool 尝试</title>
      <link>https://jia.je/hardware/2023/04/04/firtool/</link>
      <pubDate>Tue, 04 Apr 2023 20:33:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/04/04/firtool/</guid>
      <description>背景 Chisel 3.6 很快就要发布了（目前最新版本是 3.6.0-RC2），这个大版本的主要更新内容就是引入了 CIRCT 的 firtool 作为 FIRRTL 到 Verilog 的转换流程：
The primary change in Chisel v3.6.0 is the transition from the Scala FIRRTL Compiler to the new MLIR FIRRTL Compiler. This will have a minimal impact on typical Chisel user APIs but a large impact on custom compiler flows. For more information, please see the ROADMAP. 因此提前测试一下 firtool，看看其和 Scala FIRRTL Compiler 有哪些区别，是否有更好的输出。
使用 firtool 使用 firtool 有两种方法：</description>
    </item>
    
    <item>
      <title>分析 Rocket Chip 中 Diplomacy 系统</title>
      <link>https://jia.je/hardware/2022/01/05/diplomacy/</link>
      <pubDate>Wed, 05 Jan 2022 00:29:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/01/05/diplomacy/</guid>
      <description>概念 Diplomacy 主要实现了两个功能：
把整个总线结构在代码中表现出来 自动配置总线中各个端口的参数 具体来说，第一点实现了类似 Vivado Board Design 中连线的功能，第二点则是保证总线两端的参数一致，可以连接起来。
Diplomacy 为了表示总线的结构，每个模块可以对应一个 Node，Node 和 Node 之间连接形成一个图。Node 的类型主要有以下几个：
Client：对应 AXI 里面的 Master，发起请求 Manager：对应 AXI 里面的 Slave，处理请求 Adapter：对应 AXI Width Converter/Clock Converter/AXI4 to AXI3/AXI4 to AHB bridge 等，会修改 AXI 的参数，然后每个输入对应一个输出 Nexus：对应 AXI Crossbar，多个输入和多个输出 每个 Node 可能作为 Manager 连接上游的 Client，这个叫做入边（Inward Edge）；同样地，也可以作为 Client 连接下游的 Manager，这个是出边（Outward Edge）。想象成一个 DAG，从若干个 Client 流向 Manager。
连接方式采用的是 := :=* :*= :*=* 操作符，左侧是 Client，右侧是 Manager。
Rocket Chip 总线结构 Rocket Chip 主要有以下几个总线：</description>
    </item>
    
    <item>
      <title>Chisel3 Cookbook</title>
      <link>https://jia.je/hardware/2022/01/03/chisel3-cookbook/</link>
      <pubDate>Mon, 03 Jan 2022 22:19:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/01/03/chisel3-cookbook/</guid>
      <description>Chisel 版本选择 尽量选择较新版本的 Chisel。Chisel v3.5 完善了编译器插件，使得生成的代码中会包括更多变量名信息。
去掉输出 Verilog 文件中的寄存器随机初始化 版本：FIRRTL &amp;gt;= 1.5.0-RC2
代码：
new ChiselStage().execute( Array(&amp;#34;-X&amp;#34;, &amp;#34;verilog&amp;#34;, &amp;#34;-o&amp;#34;, s&amp;#34;${name}.v&amp;#34;), Seq( ChiselGeneratorAnnotation(genModule), CustomDefaultRegisterEmission( useInitAsPreset = false, disableRandomization = true ) ) ) 设置 disableRandomization=true 即可。useInitAsPreset 不建议开启。
关闭 FIRRTL 优化，输出尽可能与源代码一致的 Verilog 设置 Chisel 生成 MinimumVerilog：
new ChiselStage().execute( Array(&amp;#34;-X&amp;#34;, &amp;#34;mverilog&amp;#34;, &amp;#34;-o&amp;#34;, s&amp;#34;${name}.v&amp;#34;), Seq( ChiselGeneratorAnnotation(genModule) ) ) 此时代码中会保留更多原始 Chisel 代码的元素。
重命名 AXI4 为标准命名 Rocket Chip 中 AXI4Bundle 直接生成的名字和标准写法不同，可以利用 Chisel3 3.5.0 的 DataView 功能进行重命名：
// https://www.</description>
    </item>
    
    <item>
      <title>在 Rocket Chip 上挂接 TLRAM</title>
      <link>https://jia.je/hardware/2020/03/17/rocket-chip-tlram-load/</link>
      <pubDate>Tue, 17 Mar 2020 23:20:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2020/03/17/rocket-chip-tlram-load/</guid>
      <description>最近遇到一个需求，需要在 Rocket Chip 里面开辟一块空间，通过 verilog 的 $readmemh 来进行初始化而不是用 BootROM，这样每次修改内容不需要重新跑一次 Chisel -&amp;gt; Verilog 的流程。然后到处研究了一下，找到了解决的方案：
首先是新建一个 TLRAM 然后挂接到 cbus 上：
import freechips.rocketchip.tilelink.TLRAM import freechips.rocketchip.tilelink.TLFragmenter import freechips.rocketchip.diplomacy.LazyModule import freechips.rocketchip.diplomacy.AddressSet trait HasTestRAM { this: BaseSubsystem =&amp;gt; val testRAM = LazyModule( new TLRAM(AddressSet(0x40000000, 0x1FFF), beatBytes = cbus.beatBytes) ) testRAM.node := cbus.coupleTo(&amp;#34;bootrom&amp;#34;) { TLFragmenter(cbus) := _ } } 这里的地址和大小都可以自由定义。然后添加到自己的 Top Module 中：
class TestTop(implicit p:Parameters) extends RocketSystem // ... with HasTestRAM //... { override lazy ... } 实际上这时候 TLRAM 就已经加入到了 TileLink 总线中。接着，为了让 firrtl 生成 $readmemh 的代码，需要两个步骤：</description>
    </item>
    
    <item>
      <title>在 Vivado 中对 chisel3 产生的 verilog 代码仿真</title>
      <link>https://jia.je/hardware/2020/02/10/simulate-chisel3-on-vivado/</link>
      <pubDate>Mon, 10 Feb 2020 23:09:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2020/02/10/simulate-chisel3-on-vivado/</guid>
      <description>默认情况下，chisel3 生成的 verilog 代码在 Vivado 中仿真会出现很多信号大面积变成 X。解决方法在一个不起眼的 Wiki 页面：Randomization flags：
`define RANDOMIZE_REG_INIT `define RANDOMIZE_MEM_INIT `define RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE_INVALID_ASSIGN 在生成的 verilog 前面加上这四句，就可以正常仿真了。</description>
    </item>
    
  </channel>
</rss>
