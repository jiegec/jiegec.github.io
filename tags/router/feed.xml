<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>router on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jiege.ch/tags/router/</link>
    <description>Recent content in router on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Apr 2019 19:41:00 +0800</lastBuildDate>
    
	<atom:link href="https://jiege.ch/tags/router/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>在 FPGA 上实现路由器</title>
      <link>https://jiege.ch/hardware/router-on-fpga/</link>
      <pubDate>Wed, 24 Apr 2019 19:41:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/router-on-fpga/</guid>
      <description>最近在做 FPGA 上硬件的路由器，感觉接近一个基本可用的阶段了吧，大概谈一谈做这个的思路、过程和踩过的坑。
首先，做实验用的板子是 Alinx AX7021 ，FPGA 是 Xilinx xc7z020clg484-2 ，扩展板上有 4PL+1PS 个网口和千兆 KSZ9031RNX PHY ，采用的接口是 RGMII 。一开始做的自然是做 RGMII ，但是遇到了困难，RGMII在千兆模式下传输的是 DDR 信号，而时序和延迟就是个比较麻烦的事情。一开始先直接拿 Xilinx 的 AXI Ethernet IP 来用，然后上 ILA 看到了 IDDR 后的信号，第一次看到了完整的以太网帧，从 Preamble 和 SFD 到最后的 FCS 。于是就特别振奋，想着手写 RGMII ，先做收，再做发。确实，收很容易，很快就做出来了，但是写总是出问题，当时也不懂跨时钟域的一些问题，总之各种没调出来。于是就退而求其次，选择了 Xilinx 的 Tri Mode Ethernet IP 了。
Tri Mode Ethernet IP 有很多选项，为了简单，直接采用了 AXI-Stream 的接口，不要 AXI4-Lite 什么的，都不要，因为我需要直接写剩余的逻辑。其他东西能省也都省掉了。这个 IP 确实很给力，很快就可以完成收和发的操作了，这次终于知道了怎么处理跨时钟域的问题 — XPM FIFO ASYNC ，一下推进了很大的进度。
既然可以收，也可以发了，就扩展到多个网口。这个 IP 中可以选择 Shared Logic 在内部，也可以在外部，研究了一下发现，应该是一个放内部，其余选外部，然后接起来就可以了。不过目前为了简单，还是只用了俩端口。在这个基础上，就开始解析收进来的以太网帧了。
第一步自然是填 ARP 表，自然问题来了，如果多个网口同时进来数据，怎么保证 ARP 表读写的正确性？自然就想到总线上需要做仲裁，于是写了一个简单的总线仲裁，顺带学习到了 unique case(z) 和 priority case(z) 的语法。然后 ARP 表怎么实现呢，大概就是一个哈希表，然后表里维护了（IP，MAC，PORT）三元组，然后实现了一些冲突和覆盖的处理逻辑，做这些的同时也对各个模块编写相应的测试。有了 ARP 表，就可以在解析以太网帧的时候，拆解出里面的信息，然后请求 ARP 表总线，然后写入。</description>
    </item>
    
    <item>
      <title>rCore 软路由实现</title>
      <link>https://jiege.ch/software/rcore-soft-router/</link>
      <pubDate>Sun, 07 Apr 2019 12:13:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/rcore-soft-router/</guid>
      <description>最近在研究软路由在 rCore 上的实现，但限于硬件限制，目前先在虚拟机里测试。软路由大概要做这些东西：
1. 抓包，解析包里的内容 2. 查路由表，找到下一跳在哪 3. 查ARP，知道下一跳的 MAC 地址 4. 减少TTL，更新 IP Checksum 5. 把包发出去  第一步直接拿 smoltcp 的 Raw Socket 即可，但是目前只能抓指定 IP Protocol 的包，我用的是 ICMP ，但其他的就还抓不了，需要继续改 Smoltcp 源代码。
第二步用的是之前刚修好的 treebitmap 库，它提供了路由表的查询功能，目前路由表还是写死的，之后会用已经部分实现好的 Netlink 接口读取出来。
第三步则是 ioctl 发请求，然后从 smoltcp 内部的 ARP cache 里读取。
第四步很简单，不用多说。
第五步则需要指定出端口，用了一个 index ，放在一个特定的 sockaddr 中。
最后的效果就是，能双向转发 ping 通。
网络拓扑：
可以，这很玄学。
后续在想在真机上实验，但是还缺一个网卡驱动，不然就可以用神奇的办法来做这个实验了。</description>
    </item>
    
  </channel>
</rss>