<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hdl on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/hdl/</link>
    <description>Recent content in hdl on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 04 Apr 2023 20:33:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/hdl/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>firtool 尝试</title>
      <link>https://jia.je/hardware/2023/04/04/firtool/</link>
      <pubDate>Tue, 04 Apr 2023 20:33:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/04/04/firtool/</guid>
      <description>背景 Chisel 3.6 很快就要发布了（目前最新版本是 3.6.0-RC2），这个大版本的主要更新内容就是引入了 CIRCT 的 firtool 作为 FIRRTL 到 Verilog 的转换流程：
The primary change in Chisel v3.6.0 is the transition from the Scala FIRRTL Compiler to the new MLIR FIRRTL Compiler. This will have a minimal impact on typical Chisel user APIs but a large impact on custom compiler flows. For more information, please see the ROADMAP. 因此提前测试一下 firtool，看看其和 Scala FIRRTL Compiler 有哪些区别，是否有更好的输出。
使用 firtool 使用 firtool 有两种方法：</description>
    </item>
    
    <item>
      <title>用 sv2v&#43;yosys 把 fpnew 转为 verilog 网表</title>
      <link>https://jia.je/hardware/2022/03/30/sv2v-fpnew/</link>
      <pubDate>Wed, 30 Mar 2022 00:33:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/03/30/sv2v-fpnew/</guid>
      <description>背景 FPnew 是一个比较好用的浮点计算单元，但它是 SystemVerilog 编写的，并且用了很多高级特性，虽然闭源软件是支持的，但是开源拖拉机经常会遇到这样那样的问题。所以一直想用 sv2v 把它翻译成 Verilog，但此时的 Verilog 还有很多复杂的结构，再用 yosys 转换为一个通用可综合的网表。
步骤 经过一系列踩坑，一个很重要的点是要用最新的 sv2v(v0.0.9-24-gf868f06) 和 yosys(0.15+70)。Debian 打包的 yosys 版本比较老，不能满足需求。
首先，用 verilator 进行预处理，把一堆 sv 文件合成一个：
$ cat a.sv b.sv c.sv &amp;gt; test.sv $ verilator -E test.sv &amp;gt; merged.sv $ sed -i &amp;#39;/^`line/d&amp;#39; merged.sv 注意这里用 sed 去掉了无用的行号信息。然后，用 sv2v 进行转换：
$ sv2v merged.sv &amp;gt; merge.v $ sed -i &amp;#39;/\$$fatal/d&amp;#39; merge.v 这里又用 sed 把不支持的 $fatal 去掉。最后，用 yosys 进行处理：
$ yosys -p &amp;#39;read_verilog -defer merge.</description>
    </item>
    
    <item>
      <title>Chisel3 Cookbook</title>
      <link>https://jia.je/hardware/2022/01/03/chisel3-cookbook/</link>
      <pubDate>Mon, 03 Jan 2022 22:19:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/01/03/chisel3-cookbook/</guid>
      <description>Chisel 版本选择 尽量选择较新版本的 Chisel。Chisel v3.5 完善了编译器插件，使得生成的代码中会包括更多变量名信息。
去掉输出 Verilog 文件中的寄存器随机初始化 版本：FIRRTL &amp;gt;= 1.5.0-RC2
代码：
new ChiselStage().execute( Array(&amp;#34;-X&amp;#34;, &amp;#34;verilog&amp;#34;, &amp;#34;-o&amp;#34;, s&amp;#34;${name}.v&amp;#34;), Seq( ChiselGeneratorAnnotation(genModule), CustomDefaultRegisterEmission( useInitAsPreset = false, disableRandomization = true ) ) ) 设置 disableRandomization=true 即可。useInitAsPreset 不建议开启。
关闭 FIRRTL 优化，输出尽可能与源代码一致的 Verilog 设置 Chisel 生成 MinimumVerilog：
new ChiselStage().execute( Array(&amp;#34;-X&amp;#34;, &amp;#34;mverilog&amp;#34;, &amp;#34;-o&amp;#34;, s&amp;#34;${name}.v&amp;#34;), Seq( ChiselGeneratorAnnotation(genModule) ) ) 此时代码中会保留更多原始 Chisel 代码的元素。
重命名 AXI4 为标准命名 Rocket Chip 中 AXI4Bundle 直接生成的名字和标准写法不同，可以利用 Chisel3 3.5.0 的 DataView 功能进行重命名：
// https://www.</description>
    </item>
    
    <item>
      <title>Skid Buffer</title>
      <link>https://jia.je/hardware/2021/01/26/skid-buffer/</link>
      <pubDate>Tue, 26 Jan 2021 20:34:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/01/26/skid-buffer/</guid>
      <description>Skid buffer Skid buffer 指的就是，对于 valid + ready 的握手信号，用空间（更多的逻辑）来换取时间（更好的时序）的一个硬件模块。
简单来说，背景就是，为了解决 valid 和 ready 信号在数据流水线上一路经过组合逻辑导致的时序问题，在中途加上一些寄存器来阻隔。当然了，代价就是延迟和面积，不过吞吐量还是需要保持的。
由于需求的不同，Skid buffer 也有不同的实现。目前，找到了四个实现，实现上有所不同，特性也不大一样。
统一约定 由于我在 SpinalHDL 语言中重新实现了下面的这些 Skid buffer，所以按照 SpinalHDL 的 Stream 定义接口：
class SkidBufferCommon[T &amp;lt;: Data]( gen: =&amp;gt; T ) extends Component { val io = new Bundle { val s = slave(Stream(gen)) val m = master(Stream(gen)) } } 在这里，io.s 表示从上游取的数据，io.m 表示传递给下游的数据。
输出信号共有：io.s.ready、io.m.valid 和 io.m.payload。
ZipCPU 版本 第一个版本来自 ZipCPU：
博客地址：Building a Skid Buffer for AXI processing 代码地址：skidbuffer.</description>
    </item>
    
  </channel>
</rss>
