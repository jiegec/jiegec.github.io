<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>notes on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/notes/</link>
    <description>Recent content in notes on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Dec 2022 20:44:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/notes/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ACPI 学习笔记</title>
      <link>https://jia.je/hardware/2022/12/10/acpi-notes/</link>
      <pubDate>Sat, 10 Dec 2022 20:44:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/12/10/acpi-notes/</guid>
      <description>标准 ACPI 标准可以从官网下载。
ACPI 的表现形式为一颗树，结点可能是属性，或者是一些函数。操作系统可以操作上面的属性，调用 ACPI 中的函数，来进行一些硬件相关的操作。ACPI 一般与主板密切相关，主板厂家配置好 ACPI 后，操作系统就不需要给每个主板都写一遍代码了。
ASL 为了开发 ACPI，需要使用 ACPI Source Language(ASL) 来进行编程，使用 iasl 编译成 ACPI 表以后，由操作系统进行解释执行。推荐阅读一个比较好的 ASL 教程：ACPI Source Language (ASL) Tutorial。
简单来说，ASL 中的变量类型：
Integer: int32_t/int64_t String: char * Buffer: uint8_t [] Package: object [] Object Reference: object &amp;amp; Method ACPI 需要访问硬件，一般是通过 MMIO 或者 IO Port 来进行访问。在内核开发的时候，MMIO 一般是用一系列 volatile 指针来对应硬件的寄存器定义。ASL 中也可以做类似的事情，分为两步：OperationRegion 和 Field。
OperationRegion 就是声明了一片地址空间，以及对应的类型，常见的类型有 SystemMemory、SystemIO、PCI_Config、SMBus 等等。当 ACPI 中的代码要访问 OperationRegion 中的数据的时候，内核按照类型去进行实际的访问。
有了地址空间以后，还需要根据寄存器的定义，给各个字段起个名字，这就是 Field。Field 给 OperationRegion 中的字段起名，与硬件的定义想对应，这就像在内核中定义一个结构体，保证结构体的成员的偏移和硬件是一致的。这样就可以通过成员来访问，而不是每次都去计算一次偏移。</description>
    </item>
    
    <item>
      <title>InfiniBand 学习笔记</title>
      <link>https://jia.je/hardware/2022/12/06/infiniband-notes/</link>
      <pubDate>Tue, 06 Dec 2022 18:47:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/12/06/infiniband-notes/</guid>
      <description>参考文献 Infiniband Architecture Overview InfiniBand Architecture Specification Volume 1 Release 1.2.1 InfiniBand Architecture Specification Volume 2 Release 1.4 An Introduction to the InfiniBand Architecture InfiniBand Network Architecture - MindShare ArchWiki - InfiniBand 概览 InfiniBand 的网络分为两层，第一层是由 End Node 和 Switch 组成的 Subnet，第二层是由 Router 连接起来的若干个 Subnet。有点类似以太网以及 IP 的关系，同一个二层内通过 MAC 地址转发，三层间通过 IP 地址转发。
在 IB 网络中，End Node 一般是插在结点上的 IB 卡（Host Channel Adapter，HCA）或者是存储结点上的 Target Channel Adapter。End Node 之间通过 Switch 连接成一个 Subnet，由 Subnet Manager 给每个 Node 和 Switch 分配 Local ID，同一个 Subnet 中通过 LID（Local ID）来路由。但是 LID 位数有限，为了进一步扩展，可以用 Router 连接多个 Subnet，此时要通过 GID（Global ID）来路由。</description>
    </item>
    
    <item>
      <title>CXL 学习笔记</title>
      <link>https://jia.je/hardware/2022/11/20/cxl-notes/</link>
      <pubDate>Sun, 20 Nov 2022 23:05:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/11/20/cxl-notes/</guid>
      <description>背景 前段时间学习了 PCIe，趁此机会，进一步学习一下密切相关的 CXL。
CXL 的标准是公开下载的：https://www.computeexpresslink.org/download-the-specification，我目前参考的是 2022 年 8 月 1 日的 CXL 3.0 版本。
CXL 设备类型 CXL 对 PCIe 的重要的扩展，一是在于让设备可以和 CPU 实现缓存一致性（CXL.cache），二是可以做远程的内存（CXL.mem）。
具体下来，CXL 标准主要定义了三类设备：
CXL Type 1: 设备带有与 CPU 一致的缓存，实现 CXL.io 和 CXL.cache CXL Type 2: 设备带有自己的内存和与 CPU 一致的缓存，实现 CXL.io，CXL.cache 和 CXL.mem CXL Type 3: 设备带有自己的内存，实现 CXL.io 和 CXL.mem CXL 传输层 CXL.io CXL.io 基本上就是 PCIe 协议：
CXL.io provides a non-coherent load/store interface for I/O devices. Figure 3-1 shows where the CXL.</description>
    </item>
    
    <item>
      <title>PCIe 学习笔记</title>
      <link>https://jia.je/hardware/2022/11/12/pcie-notes/</link>
      <pubDate>Sat, 12 Nov 2022 14:56:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/11/12/pcie-notes/</guid>
      <description>背景 最近在知乎上看到 LogicJitterGibbs 的 资料整理：可以学习 1W 小时的 PCIe，我跟着资料学习了一下，然后在这里记录一些我学习 PCIe 的笔记。
下面的图片主要来自 PCIe 3.0 标准以及 MindShare 的 PCIe 3.0 书本。
分层 PCIe 定义了三个层：Transaction Layer，Data Link Layer，Physical Layer，和 TCP/IP 四层模型很像。PCIe 也是基于 Packet 传输的。
Transaction Layer Transaction Layer 的核心是 Transaction Layer Packet(TLP)。TLP 格式：
即可选的若干个 Prefix，一个 Header，可选的 Data Payload，可选的 Digest。
Prefix 和 Header 开头的一个字节是 Fmt[2:0] 和 Type[4:0] 字段。Fmt 决定了 header 的长度，有无数据，或者这是一个 Prefix。
它支持几类 Packet：
Memory: MMIO Read Request(MRd)/Completion(CplD) Write Request(MWr): 注意只有 Request，没有 Completion AtomicOp Request(FetchAdd/Swap/CAS)/Completion(CplD) Locked Memory Read(MRdLk)/Completion(CplDLk): Legacy IO: Legacy Read Request(IORd)/Completion(CplD) Write Request(IOWr)/Completion(Cpl) Configuration: 访问配置空间 Read Request(CfgRd0/CfgRd1)/Completion(CplD) Write Request(CfgWr0/CfgWr1)/Completion(Cpl) Message: 传输 event Request(Msg/MsgD) 括号里的是 TLP Type，对应了它 Fmt 和 Type 字段的取值。如果 Completion 失败了，原来应该是 CplD/CplDLk 的 Completion 会变成不带数据的 Cpl/CplLk。</description>
    </item>
    
  </channel>
</rss>
