<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>chi on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/chi/</link>
    <description>Recent content in chi on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Jan 2023 00:10:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/chi/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CHI 学习笔记</title>
      <link>https://jia.je/hardware/2023/01/12/chi-notes/</link>
      <pubDate>Thu, 12 Jan 2023 00:10:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/01/12/chi-notes/</guid>
      <description>本文的内容已经整合到知识库中。
CHI 介绍 CHI 协议是 AMBA 5 标准中的缓存一致性协议，前身是 ACE 协议。最新的 CHI 标准可以从 AMBA 5 CHI Architecture Specification 处下载。
相比 AXI，CHI 更加复杂，进行了分层：协议层，物理层和链路层。因此，CHI 适用于片上网络，支持根据 Node ID 进行路由，而不像 AXI 那样只按照物理地址进行路由。CHI 的地位就相当于 Intel 的环形总线。CHI 也可以桥接到 CCIX 上，用 CCIX 连接 SMP 的的多个 Socket，或者连接支持 CCIX 的显卡等等。
缓存行状态 首先回顾 ACE 的缓存行状态，共有五种，与 MOESI 相对应：
UniqueDirty: Modified SharedDirty: Owned UniqueClean: Exclusive SharedClean: Shared Invalid: Invalid 在此基础上，CHI 考虑缓存行只有部分字节有效的情况，即 Full，Partial 或者 Empty。因此 CHI 的缓存行状态共有七种：
UniqueDirty: Modified UniqueDirtyPartial: 新增，可能有部分字节合法，在写回的时候，需要和下一级缓存或者内存中的合法缓存行内容进行合并 SharedDirty: Owned UniqueClean: Exclusive UniqueCleanEmpty: 新增，所有字节都不合法，但是本缓存占有该缓存行，如果要修改的话，不需要通知其他缓存 SharedClean: Shared Invalid: Invalid 可以看到，比较特别的就是 UniqueDirtyPartial 和 UniqueCleanEmpty。CHI 标准在 4.</description>
    </item>
    
  </channel>
</rss>
