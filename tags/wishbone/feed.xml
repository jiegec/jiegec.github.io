<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>wishbone on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/wishbone/</link>
    <description>Recent content in wishbone on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 19 Jun 2022 17:05:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/wishbone/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「教学」Wishbone 总线协议</title>
      <link>https://jia.je/hardware/2022/06/19/wishbone/</link>
      <pubDate>Sun, 19 Jun 2022 17:05:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/06/19/wishbone/</guid>
      <description>背景 最近在研究如何把 Wishbone 总线协议引入计算机组成原理课程，因此趁此机会学习了一下 Wishbone 的协议。
总线 总线是什么？总线通常用于连接 CPU 和外设，为了更好的兼容性和可复用性，会想到能否设计一个统一的协议，其中 CPU 实现的是发起请求的一方（又称为 master），外设实现的是接收请求的一方（又称为 slave），那么如果要添加外设、或者替换 CPU 实现，都会变得比较简单，减少了许多适配的工作量。
那么，我们来思考一下，一个总线协议需要包括哪些内容？对于 CPU 来说，程序会读写内存，读写内存就需要以下几个信号传输到内存：
 地址（addr）：例如 32 位处理器就是 32 位地址，或者按照内存的大小计算地址线的宽度 数据（w_data 和 r_data）：分别是写数据和读数据，宽度通常为 32 位 或 64 位，也就是一个时钟周期可以传输的数据量 读还是写（we）：高表示写，低表示读 字节有效（be）：例如为了实现单字节写，虽然 w_data 可能是 32 位宽，但是实际写入的是其中的一个字节  除了请求的内容以外，为了表示 CPU 想要发送请求，还需要添加 valid 信号：高表示发送请求，低表示不发送请求。很多时候，外设的速度比较慢，可能无法保证每个周期都可以处理请求，因此外设可以提供一个 ready 信号：当 valid=1 &amp;amp;&amp;amp; ready=1 的时候，发送并处理请求；当 valid=1 &amp;amp;&amp;amp; ready=0 的时候，表示外设还没有准备好，此时 CPU 需要一直保持 valid=1 不变，等到外设准备好后，valid=1 &amp;amp;&amp;amp; ready=1 请求生效。
简单总结一下上面的需求，可以得到 master 和 slave 端分别的信号列表。这次，我们在命名的时候用 _o 表示输出、_i 表示输入，可以得到 master 端（CPU 端）的信号：</description>
    </item>
    
  </channel>
</rss>
