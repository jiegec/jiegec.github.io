<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coherence on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/coherence/</link>
    <description>Recent content in coherence on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Jan 2023 00:10:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/coherence/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CHI 学习笔记</title>
      <link>https://jia.je/hardware/2023/01/12/chi-notes/</link>
      <pubDate>Thu, 12 Jan 2023 00:10:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/01/12/chi-notes/</guid>
      <description>本文的内容已经整合到知识库中。
CHI 介绍 CHI 协议是 AMBA 5 标准中的缓存一致性协议，前身是 ACE 协议。最新的 CHI 标准可以从 AMBA 5 CHI Architecture Specification 处下载。
相比 AXI，CHI 更加复杂，进行了分层：协议层，物理层和链路层。因此，CHI 适用于片上网络，支持根据 Node ID 进行路由，而不像 AXI 那样只按照物理地址进行路由。CHI 的地位就相当于 Intel 的环形总线。CHI 也可以桥接到 CCIX 上，用 CCIX 连接 SMP 的的多个 Socket，或者连接支持 CCIX 的显卡等等。
缓存行状态 首先回顾 ACE 的缓存行状态，共有五种，与 MOESI 相对应：
UniqueDirty: Modified SharedDirty: Owned UniqueClean: Exclusive SharedClean: Shared Invalid: Invalid 在此基础上，CHI 考虑缓存行只有部分字节有效的情况，即 Full，Partial 或者 Empty。因此 CHI 的缓存行状态共有七种：
UniqueDirty: Modified UniqueDirtyPartial: 新增，可能有部分字节合法，在写回的时候，需要和下一级缓存或者内存中的合法缓存行内容进行合并 SharedDirty: Owned UniqueClean: Exclusive UniqueCleanEmpty: 新增，所有字节都不合法，但是本缓存占有该缓存行，如果要修改的话，不需要通知其他缓存 SharedClean: Shared Invalid: Invalid 可以看到，比较特别的就是 UniqueDirtyPartial 和 UniqueCleanEmpty。CHI 标准在 4.</description>
    </item>
    
    <item>
      <title>CXL 学习笔记</title>
      <link>https://jia.je/hardware/2022/11/20/cxl-notes/</link>
      <pubDate>Sun, 20 Nov 2022 23:05:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/11/20/cxl-notes/</guid>
      <description>本文的内容已经整合到知识库中。
背景 前段时间学习了 PCIe，趁此机会，进一步学习一下密切相关的 CXL。
CXL 的标准是公开下载的：https://www.computeexpresslink.org/download-the-specification，我目前参考的是 2022 年 8 月 1 日的 CXL 3.0 版本。
CXL 设备类型 CXL 对 PCIe 的重要的扩展，一是在于让设备可以和 CPU 实现缓存一致性（CXL.cache），二是可以做远程的内存（CXL.mem）。
具体下来，CXL 标准主要定义了三类设备：
CXL Type 1: 设备带有与 CPU 一致的缓存，实现 CXL.io 和 CXL.cache CXL Type 2: 设备带有自己的内存和与 CPU 一致的缓存，实现 CXL.io，CXL.cache 和 CXL.mem CXL Type 3: 设备带有自己的内存，实现 CXL.io 和 CXL.mem CXL 传输层 CXL.io CXL.io 基本上就是 PCIe 协议：
CXL.io provides a non-coherent load/store interface for I/O devices. Figure 3-1 shows where the CXL.</description>
    </item>
    
    <item>
      <title>「教学」ACE 缓存一致性协议</title>
      <link>https://jia.je/hardware/2022/05/16/ace/</link>
      <pubDate>Mon, 16 May 2022 00:34:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/05/16/ace/</guid>
      <description>本文的内容已经整合到知识库中。
背景 最近几天分析了 TileLink 的缓存一致性协议部分内容，见TileLink 总线协议分析，趁此机会研究一下之前尝试过研究，但是因为缺少一些基础知识而弃坑的 ACE 协议分析。
下面主要参考了 IHI0022E 的版本，也就是 AXI4 对应的 ACE 版本。
回顾 首先回顾一下一个缓存一致性协议需要支持哪些操作。对于较上一级 Cache 来说，它需要这么几件事情：
读或写 miss 的时候，需要请求这个缓存行的数据，并且更新自己的状态，比如读取到 Shared，写入到 Modified 等。 写入一个 valid &amp;amp;&amp;amp; !dirty 的缓存行的时候，需要升级自己的状态，比如从 Shared 到 Modified。 需要 evict 一个 valid &amp;amp;&amp;amp; dirty 的缓存行的时候，需要把 dirty 数据写回，并且降级自己的状态，比如 Modified -&amp;gt; Shared/Invalid。如果需要 evict 一个 valid &amp;amp;&amp;amp; !dirty 的缓存行，可以选择通知，也可以选择不通知下一级。 收到 snoop 请求的时候，需要返回当前的缓存数据，并且更新状态。 需要一个方法来通知下一级 Cache/Interconnect，告诉它第一和第二步完成了。 如果之前看过我的 TileLink 分析，那么上面的这些操作对应到 TileLink 就是：
读或写 miss 的时候，需要请求这个缓存行的数据（发送 AcquireBlock，等待 GrantData），并且更新自己的状态，比如读取到 Shared，写入到 Modified 等。 写入一个 valid &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>TileLink 总线协议分析</title>
      <link>https://jia.je/hardware/2022/05/09/tilelink/</link>
      <pubDate>Mon, 09 May 2022 16:15:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/05/09/tilelink/</guid>
      <description>本文的内容已经整合到知识库中。
背景 最近在研究一些支持缓存一致性的缓存的实现，比如 rocket-chip 的实现和 sifive 的实现，因此需要研究一些 TileLink 协议。本文讨论的时候默认读者具有一定的 AXI 知识，因此很多内容会直接参考 AXI。
信号 根据 TileLink Spec 1.8.0，TileLink 分为以下三种：
TL-UL: 只支持读写，不支持 burst，类比 AXI-Lite TL-UH：支持读写，原子指令，预取，支持 burst，类比 AXI+ATOP（AXI5 引入的原子操作） TL-C：在 TL-UH 基础上支持缓存一致性协议，类比 AXI+ACE/CHI TileLink Uncached TileLink Uncached(TL-UL 和 TL-UH) 包括了两个 channel：
A channel: M-&amp;gt;S 发送请求，类比 AXI 的 AR/AW/W D channel: S-&amp;gt;M 发送响应，类比 AXI 的 R/W 因此 TileLink 每个周期只能发送读或者写的请求，而 AXI 可以同时在 AR 和 AW channel 上发送请求。
一些请求的例子：
读：M-&amp;gt;S 在 A channel 上发送 Get，S-&amp;gt;M 在 D channel 上发送 AccessAckData 写：M-&amp;gt;S 在 A channel 上发送 PutFullData/PutPartialData，S-&amp;gt;M 在 D channel 是发送 AccessAck 原子操作：M-&amp;gt;S 在 A channel 上发送 ArithmeticData/LogicalData，S-&amp;gt;M 在 D channel 上发送 AccessAckData 预取操作：M-&amp;gt;S 在 A channel 上发送 Intent，S-&amp;gt;M 在 D channel 上发送 AccessAck AXI4ToTL 针对 AXI4ToTL 模块的例子，来分析一下如何把一个 AXI4 Master 转换为 TileLink。</description>
    </item>
    
    <item>
      <title>「教学」缓存一致性协议分析</title>
      <link>https://jia.je/hardware/2021/12/17/cache-coherency-protocol/</link>
      <pubDate>Fri, 17 Dec 2021 07:39:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/17/cache-coherency-protocol/</guid>
      <description>本文的内容已经整合到知识库中。
背景 最近在《高等计算机系统结构》课程中学习缓存一致性协议算法，这里用自己的语言来组织一下相关知识的讲解。
Write-invalidate 和 Write-update 最基础的缓存一致性思想有两种：
Write-invalidate：写入数据的时候，将其他 Cache 中这条 Cache Line 设为 Invalid Write-update：写入数据的时候，把新的结果写入到有这条 Cache Line 的其他 Cache Write-once 协议 Write-once 协议定义了四个状态：
Invalid：表示这个块不合法 Valid：表示这个块合法，并可能是共享的，同时数据没有修改 Reserved：表示这个块合法，不是共享的，同时数据没有更改 Dirty：表示这个块合法，不是共享的，数据做了修改，和内存不同。 可见，当一个缓存状态在 R 或者 D，其他缓存只能是 I；而缓存状态是 V 的时候，可以有多个缓存在 V 状态。
Write-once 协议的特点是，第一次写的时候，会写入到内存（类似 Write-through），连续写入则只写到缓存中，类似 Write-back。
当 Read hit 的时候，状态不变。
Read hit: The information is supplied by the current cache. No state change. 当 Read miss 的时候，会查看所有缓存，如果有其他缓存处于 Valid/Reserved/Dirty 状态，就从其他缓存处读取数据，然后设为 Valid，其他缓存也设为 Valid。如果其他缓存处于 Dirty 状态，还要把数据写入内存。
Read miss: The data is read from main memory.</description>
    </item>
    
  </channel>
</rss>
