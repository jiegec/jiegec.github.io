<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpu on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/cpu/</link>
    <description>Recent content in cpu on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 17 Dec 2021 07:39:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/cpu/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>缓存一致性协议分析</title>
      <link>https://jia.je/hardware/2021/12/17/cache-coherency-protocol/</link>
      <pubDate>Fri, 17 Dec 2021 07:39:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/17/cache-coherency-protocol/</guid>
      <description>参考文档  Cache coherence MSI protocol Write-once (cache coherence) MESI protocol MOESI protocol Dragon protocol A Strategy to Verify an AXI/ACE Compliant Interconnect (2 of 4) Directory-based cache coherence  Write-invalidate 和 Write-update 最基础的缓存一致性思想有两种：
 Write-invalidate：写入数据的时候，将其他 Cache 中这条 Cache Line 设为 Invalid Write-update：写入数据的时候，把新的结果写入到有这条 Cache Line 的其他 Cache  Write-once 协议 Write-once 协议定义了四个状态：
 Invalid：表示这个块不合法 Valid：表示这个块合法，并可能是共享的，同时数据没有修改 Reserved：表示这个块合法，不是共享的，同时数据没有更改 Dirty：表示这个块合法，不是共享的，数据做了修改，和内存不同。  可见，当一个缓存状态在 R 或者 D，其他缓存只能是 I；而缓存状态是 V 的时候，可以有多个缓存在 V 状态。
Write-once 协议的特点是，第一次写的时候，会写入到内存（类似 Write-through），连续写入则只写到缓存中，类似 Write-back。</description>
    </item>
    
    <item>
      <title>RISC-V Debug 分析</title>
      <link>https://jia.je/hardware/2021/12/12/riscv-debug/</link>
      <pubDate>Sun, 12 Dec 2021 14:01:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/12/riscv-debug/</guid>
      <description>参考文档  RISC-V Debug Spec 0.13 IEEE Standard for JTAG 1149.1-2013 OpenOCD 相关代码  背景 之前用过一些 RISC-V 核心，但是遇到调试相关的内容的时候就两眼一抹黑，不知道原理，出了问题也不知道如何排查，趁此机会研究一下工作原理。
架构 为了调试 RISC-V 核心，需要很多部件一起工作。按 RISC-V Debug Spec 所述，有这么几部分：
 Debugger: GDB，连接到 OpenOCD 启动的 GDB Server Debug Translator: OpenOCD，向 GDB 提供 Server 实现，同时会通过 FTDI 等芯片控制 JTAG Debug Transport Hardware: 比如 FTDI 的芯片，可以提供 USB 接口，让 OpenOCD 控制 JTAG 信号 TMS/TDI/TCK 的变化，并读取 TDO Debug Transport Module: 在芯片内部的 JTAG 控制器（TAP），符合 JTAG 标准 Debug Module Interface：RISC-V 自定义的一系列寄存器，通过这些寄存器来控制 Debug Module 的行为 Debug Module：调试器，控制 RISC-V 核心，同时也支持直接访问总线，也有内部的 Program Buffer  可以看到，DMI 是实际的调试接口，而 JTAG 可以认为是一个传输协议。</description>
    </item>
    
    <item>
      <title>Manycore 处理器架构分析</title>
      <link>https://jia.je/hardware/2021/12/06/manycore/</link>
      <pubDate>Mon, 06 Dec 2021 00:11:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/06/manycore/</guid>
      <description>参考文档  Intel® Many Integrated Core Architecture (Intel® MIC Architecture) - Advanced Intel® Xeon Phi coprocessor (codename Knights Corner) https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;amp;arnumber=7453080 Knights Landing (KNL): 2nd Generation Intel® Xeon Phi™ Processor Fujitsu A64FX Fujitsu Presents Post-K CPU Specifications Fujitsu High Performance CPU for the Post-K Computer SUPERCOMPUTER FUGAKU - SUPERCOMPUTER FUGAKU, A64FX 48C 2.2GHZ, TOFU INTERCONNECT D Preliminary Performance Evaluation of the Fujitsu A64FX Using HPC Applications FUJITSU Processor A64FX NVIDIA A100 Tensor Core GPU Architecture NVIDIA TESLA V100 GPU ARCHITECTURE NVIDIA A100 TENSOR CORE GPU  Xeon Phi - Intel MIC MIC: Many Integrated Core Architecture</description>
    </item>
    
    <item>
      <title>Sunway 处理器架构分析</title>
      <link>https://jia.je/hardware/2021/12/04/sunway/</link>
      <pubDate>Sat, 04 Dec 2021 09:13:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/04/sunway/</guid>
      <description>参考文档  高性能众核处理器申威26010 稀疏矩阵向量乘法在申威众核架构上的性能优化 Sunway SW26010 The Sunway TaihuLight supercomputer: system and applications Report on the Sunway TaihuLight System Closing the “Quantum Supremacy” Gap: Achieving Real-Time Simulation of a Random Quantum Circuit Using a New Sunway Supercomputer SW_Qsim: A Minimize-Memory Quantum Simulator with High-Performance on a New Sunway Supercomputer 18.9-Pflops Nonlinear Earthquake Simulation on Sunway TaihuLight: Enabling Depiction of 18-Hz and 8-Meter Scenarios A FIRST PEEK AT CHINA’S SUNWAY EXASCALE SUPERCOMPUTER THE NITTY GRITTY OF THE SUNWAY EXASCALE SYSTEM NETWORK AND STORAGE Sunway supercomputer architecture towards exascale computing: analysis and practice  SW26010 Sunway TaihuLight 的层次：</description>
    </item>
    
    <item>
      <title>浅谈乱序执行 CPU</title>
      <link>https://jia.je/hardware/2021/09/14/brief-into-ooo/</link>
      <pubDate>Tue, 14 Sep 2021 13:47:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/09/14/brief-into-ooo/</guid>
      <description>背景 最早学习乱序执行 CPU 的时候，是在 Wikipedia 上自学的，后来在计算机系统结构课上又学了一遍，但发现学的和现在实际采用的乱序执行 CPU 又有很大区别，后来又仔细研究了一下，觉得理解更多了，就想总结一下。
经典 Tomasulo 参考 Stanford 教材
经典 Tomasulo，也是 Wikipedia 上描述的 Tomasulo 算法，它的核心是保留站。指令在 Decode 之后，会被分配到一个保留站中。保留站有以下的这些属性：
 Op：需要执行的操作 Qj，Qk：操作数依赖的指令目前所在的保留站 ID Vj，Qk：操作数的值 Rj，Rk：操作数是否 ready（或者用特殊的 Qj，Qk 值表示是否 ready） Busy：这个保留站被占用  此外还有一个 mapping（Wikipedia 上叫做 RegisterStat），记录了寄存器是否会被某个保留站中的指令写入。
指令分配到保留站的时候，会查询 RegisterStat，得知操作数寄存器是否 ready，如果不 ready，说明有一个先前的指令要写入这个寄存器，那就记录下对应的保留站 ID。当操作数都 ready 了，就可以进入计算单元计算。当一条指令在执行单元中完成的时候，未出现 WAW 时会把结果写入寄存器堆，并且通过 Common Data Bus 进行广播，目前在保留站中的指令如果发现，它所需要的操作数刚好计算出来了，就会把取值保存下来。
这里有一些细节：因为保留站中的指令可能要等待其他指令的完成，为了保证计算单元利用率更高，对于同一个计算类型（比如 ALU），需要有若干个同类的保留站（比如 Add1，Add2，Add3）。在 Wikipedia 的表述中，每个保留站对应了一个计算单元，这样性能比较好，但自然面积也就更大。如果节省面积，也可以减少计算单元的数量，然后每个计算单元从多个保留站中获取计算的指令。
可以思考一下，这种方法的瓶颈在什么地方。首先，每条指令都放在一个保留站中，当保留站满的时候就不能发射新的指令。其次，如果计算单元的吞吐跟不上保留站的填充速度，也会导致阻塞。
这种方法的一个比较麻烦的点在于难以实现精确异常。精确异常的关键在于，异常之前的指令都生效，异常和异常之后的指令不生效，但这种方法无法进行区分。
从寄存器重命名的角度来看，可以认为这种方法属于 Implicit Register Renaming，也就是说，把 Register 重命名为保留站的 ID。
再分析一下寄存器堆需要哪些读写口。有一条规律是，寄存器堆的面积与读写口个数的平方成正比。对于每条发射的指令，都需要从寄存器堆读操作数，所以读口是操作数x指令发射数。当执行单元完成计算的时候，需要写入寄存器堆，所以每个执行单元都对应一个寄存器堆的写口。
硬件实现的时候，为了性能，希望保留站可以做的比较多，这样可以容纳更多的指令。但是，保留站里面至少要保存操作数的值，会比较占用面积，并且时延也比较大。
ROB（ReOrder Buffer） 参考教材
为了实现精确异常，我们需要引入 ROB。在上面的 Tomasulo 算法中，计算单元计算完成的时候，就会把结果写入到寄存器堆中，因此精确异常时难以得到正确的寄存器堆取值。既然我们希望寄存器堆的状态与顺序执行的结果一致，我们需要引入 ROB。</description>
    </item>
    
    <item>
      <title>Verilog 初体验</title>
      <link>https://jia.je/programming/2018/06/21/verilog-first-try/</link>
      <pubDate>Thu, 21 Jun 2018 21:36:00 +0800</pubDate>
      
      <guid>https://jia.je/programming/2018/06/21/verilog-first-try/</guid>
      <description>自己以前一直对硬件方面没有接触，但是大二大三很快就要接触相关知识，所以自己就先预习一下 Verilog HDL，以便以后造计算机。听学长们推荐了一本书叫《自己动手写CPU》，由于自己手中只有很老的 Spartan-3 板子，手上没有可以用来试验的 FPGA ，所以选择用 Verilog + Verilator 进行模拟。既然是模拟，自然是会有一定的问题，不过这个以后再说。
然后就是模仿着这本书的例子，写了指令的获取和指令的解码两部分很少很少的代码，只能解码 ori (or with immidiate) 这一个指令。然后，通过 verilator 跑模拟，输出 vcd 文件，再用 gtkwave 显示波形，终于能够看到我想要的结果了。能够看到，前一个时钟周期获取指令，下一个时钟周期进行解码，出现了流水线的结果。这让我十分开心。
接下来就是实现一些基本的算术指令，然后讲计算的结果写入到相应的寄存器中。这样做完之后，就可以做一个基于 verilator 的简易 A+B 程序了。
我的代码发布在jiegec/learn_verilog中。最近马上到考试周，可能到暑假会更频繁地更新吧。</description>
    </item>
    
    <item>
      <title>用CPUID获取评测机器的CPU</title>
      <link>https://jia.je/others/2017/10/30/use-cpuid-to-get-machine-cpu/</link>
      <pubDate>Mon, 30 Oct 2017 21:07:23 +0800</pubDate>
      
      <guid>https://jia.je/others/2017/10/30/use-cpuid-to-get-machine-cpu/</guid>
      <description>受用 CPUID 检测各大 OJ 测评机所用的 CPU（以及日常黑 BZOJ）的启发，我决定去测试一下徐老师自己写的OJ（名为Tyche）所跑的机器是什么CPU。于是我改造一下代码，用以下代码测评：
#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;cpuid.h&amp;gt;#include &amp;lt;sys/time.h&amp;gt;static void cpuid(uint32_t func, uint32_t sub, uint32_t data[4]) {  __cpuid_count(func, sub, data[0], data[1], data[2], data[3]); } int main() {  uint32_t data[4];  char str[48];  for(int i = 0; i &amp;lt; 3; ++i) {  cpuid(0x80000002 + i, 0, data);  for(int j = 0; j &amp;lt; 4; ++j)  reinterpret_cast&amp;lt;uint32_t*&amp;gt;(str)[i * 4 + j] = data[j];  }   struct timeval stop, start;  gettimeofday(&amp;amp;start, NULL);  while(1) {  gettimeofday(&amp;amp;stop, NULL);  if(stop.</description>
    </item>
    
  </channel>
</rss>
