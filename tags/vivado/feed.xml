<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vivado on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/vivado/</link>
    <description>Recent content in vivado on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Apr 2022 09:36:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/vivado/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>导出 Vivado 下载 Bitstream 的 SVF 文件</title>
      <link>https://jia.je/hardware/2022/04/10/vivado-program-bitstream-svf/</link>
      <pubDate>Sun, 10 Apr 2022 09:36:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/04/10/vivado-program-bitstream-svf/</guid>
      <description>背景 最近在研究如何实现一个远程 JTAG 的功能，目前实现在 jiegec/jtag-remote-server，实现了简单的 XVC 协议，底层用的是 libftdi 的 MPSSE 协议来操作 JTAG。但是，在用 Vivado 尝试的时候，SysMon 可以正常使用，但是下载 Bitstream 会失败，所以要研究一下 Vivado 都做了什么（目前已经修好，是最后一个字节的部分位读取的处理问题）。
SVF SVF 格式其实是一系列的 JTAG 上的操作。想到这个，也是因为在网上搜到了一个 dcfeb_v45.svf，里面描述的就是一段 JTAG 操作：
// Created using Xilinx Cse Software [ISE - 12.4] // Date: Mon May 09 11:00:32 2011 TRST OFF; ENDIR IDLE; ENDDR IDLE; STATE RESET; STATE IDLE; FREQUENCY 1E6 HZ; //Operation: Program -p 0 -dataWidth 16 -rs1 NONE -rs0 NONE -bpionly -e -loadfpga TIR 0 ; HIR 0 ; TDR 0 ; HDR 0 ; TIR 0 ; HIR 0 ; HDR 0 ; TDR 0 ; //Loading device with &amp;#39;idcode&amp;#39; instruction.</description>
    </item>
    
    <item>
      <title>「教学」AXI Quad SPI 时序分析</title>
      <link>https://jia.je/hardware/2021/09/27/xilinx-axi-quad-spi-timing/</link>
      <pubDate>Mon, 27 Sep 2021 22:22:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/09/27/xilinx-axi-quad-spi-timing/</guid>
      <description>背景 之前一直没搞懂 Vivado 中 xdc 需要怎么编写，遇到一些必须要写 xdc 的时候就很头疼，不知道怎么写才可以得到正确的结果。今天分析了一下 AXI Quad SPI 的时序 xdc，终于理解了其中的含义。
AXI Quad SPI AXI Quad SPI 是一个 SPI 的控制器，它支持 XIP（eXecute In Place）模式，即可以暴露一个只读 AXI Slave 接口，当接收到读请求的时候，就按照标准的 SPI Flash 命令去对应的地址进行读取，然后返回结果。由于不同厂家的 SPI Flash 支持有所不同，所以 IP 上的设置可以看到厂家的选择。
特别地，一个常见的需求是希望访问 Cfg（Configuration） Flash，亦即用来保存 Bitstream 的 Flash。当 FPGA 上电的时候，如果启动模式设置为 SPI Flash，FPGA 就会向 Cfg Flash 读取 Bitstream，Cfg Flash 需要连接到 FPGA 的指定引脚上，当 FPGA 初始化的时候由内部逻辑驱动，初始化完成后又要转交给用户逻辑。转交的方式就是通过 STARTUP 系列的 primitive。
通常，如果要连接外部的 SPI Flash，需要连接几条信号线到顶层，然后通过 xdc 把信号绑定到引脚上，然后引脚连接了一个外部的 SPI Flash。但由于 Cfg Flash 比较特殊，所以信号从 AXI Quad SPI 直接连到 STARTUP 系列的 primitive 上。如果是采用 STARTUPE2 原语的 7 系列的 FPGA，那么只有时钟会通过 STARTUPE2 pritimive 连接到 SPI Flash 上，其他数据信号还是正常通过顶层绑定；如果是采用 STARTUPE3 原语的 UltraScale 系列的 FPGA，那么时钟和数据都通过 STARTUPE3 primitive 连接到 SPI Flash。</description>
    </item>
    
    <item>
      <title>在命令行中进行 Vivado 仿真</title>
      <link>https://jia.je/hardware/2020/04/04/vivado-simulation-command/</link>
      <pubDate>Sat, 04 Apr 2020 18:50:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2020/04/04/vivado-simulation-command/</guid>
      <description>想要在命令行里进行 Vivado 仿真，所以查了下 Xilinx 的 UG900 文档，找到了命令行仿真的方法。首先是生成仿真所需的文件：
# assuming batch mode open_project xxx.xpr set_property top YOUR_SIM_TOP [current_fileset -simset] export_ip_user_files -no_script -force export_simulation -simulator xsim -force 可以把这些语句放到 tcl 文件里然后用 batch mode 执行。执行成功以后，会在 export_sim/xsim 目录下生成一些文件。里面会有生成的脚本以供仿真：
cd export_sim/xsim &amp;amp;&amp;amp; ./YOUR_SIM_TOP.sh 默认情况下它会执行 export_sim/xsim/cmd.tcl 里面的命令。如果想要记录 vcd 文件，修改内容为：
open_vcd log_vcd run 20us close_vcd quit 这样就可以把仿真的波形输出到 dump.vcd 文件，拖到本地然后用 GTKWave 看。更多支持的命令可以到 UG900 里找。</description>
    </item>
    
    <item>
      <title>在 Vivado 中对 chisel3 产生的 verilog 代码仿真</title>
      <link>https://jia.je/hardware/2020/02/10/simulate-chisel3-on-vivado/</link>
      <pubDate>Mon, 10 Feb 2020 23:09:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2020/02/10/simulate-chisel3-on-vivado/</guid>
      <description>默认情况下，chisel3 生成的 verilog 代码在 Vivado 中仿真会出现很多信号大面积变成 X。解决方法在一个不起眼的 Wiki 页面：Randomization flags：
`define RANDOMIZE_REG_INIT `define RANDOMIZE_MEM_INIT `define RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE_INVALID_ASSIGN 在生成的 verilog 前面加上这四句，就可以正常仿真了。</description>
    </item>
    
    <item>
      <title>给 Rocket Chip 挂接串口外设</title>
      <link>https://jia.je/os/2019/05/08/axi-uart-interrupt/</link>
      <pubDate>Wed, 08 May 2019 11:04:00 +0800</pubDate>
      
      <guid>https://jia.je/os/2019/05/08/axi-uart-interrupt/</guid>
      <description>前言 最近在给 rCore 添加 Rocket Chip 支持。下面讲讲最近做了哪些工作，遇到了哪些坑，都是怎么解决的。
踩坑过程 Rocket Chip 运行代码 首先分析了一下已有的代码和工作方式，这个 Rocket Chip （ucb-bar/fpga-zynq）的设计大概是这样的：在 PS 上通过 fesvr 向 Rocket Chip 写入程序。Rocket Chip 本身暴露出一个 TSI ，一个串口的调试接口，通过 Zynq Adapter 挂到了 PS 下的 AXI 总线，暴露出若干个寄存器，大概如下：
 /** * Address Map * 0x00 - serial out FIFO data * 0x04 - serial out FIFO data available (words) * 0x08 - serial in FIFO data * 0x0C - serial in FIFO space available (words) * 0x10 - system reset * 0x20 - req FIFO data * 0x24 - req FIFO data available (words) * 0x28 - data FIFO data * 0x2C - data FIFO data available (words) * 0x30 - resp FIFO data * 0x34 - resp FIFO space available (words) * 0x38 - nsectors * 0x3C - max request length */ 前面的是调试接口，后面的是 block device 和 network ，我们暂时还没有用到这些 UCB BAR 做的私货。在 Vivado 中，地址 Offset 是 0x43C00000 ，所以代码中就这样访问对应的物理地址：</description>
    </item>
    
  </channel>
</rss>
