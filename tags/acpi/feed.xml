<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>acpi on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/acpi/</link>
    <description>Recent content in acpi on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Dec 2022 20:44:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/acpi/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ACPI 学习笔记</title>
      <link>https://jia.je/hardware/2022/12/10/acpi-notes/</link>
      <pubDate>Sat, 10 Dec 2022 20:44:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/12/10/acpi-notes/</guid>
      <description>标准 ACPI 标准可以从官网下载。
ACPI 的表现形式为一颗树，结点可能是属性，或者是一些函数。操作系统可以操作上面的属性，调用 ACPI 中的函数，来进行一些硬件相关的操作。ACPI 一般与主板密切相关，主板厂家配置好 ACPI 后，操作系统就不需要给每个主板都写一遍代码了。
ASL 为了开发 ACPI，需要使用 ACPI Source Language(ASL) 来进行编程，使用 iasl 编译成 ACPI 表以后，由操作系统进行解释执行。推荐阅读一个比较好的 ASL 教程：ACPI Source Language (ASL) Tutorial。
简单来说，ASL 中的变量类型：
Integer: int32_t/int64_t String: char * Buffer: uint8_t [] Package: object [] Object Reference: object &amp;amp; Method ACPI 需要访问硬件，一般是通过 MMIO 或者 IO Port 来进行访问。在内核开发的时候，MMIO 一般是用一系列 volatile 指针来对应硬件的寄存器定义。ASL 中也可以做类似的事情，分为两步：OperationRegion 和 Field。
OperationRegion 就是声明了一片地址空间，以及对应的类型，常见的类型有 SystemMemory、SystemIO、PCI_Config、SMBus 等等。当 ACPI 中的代码要访问 OperationRegion 中的数据的时候，内核按照类型去进行实际的访问。
有了地址空间以后，还需要根据寄存器的定义，给各个字段起个名字，这就是 Field。Field 给 OperationRegion 中的字段起名，与硬件的定义想对应，这就像在内核中定义一个结构体，保证结构体的成员的偏移和硬件是一致的。这样就可以通过成员来访问，而不是每次都去计算一次偏移。</description>
    </item>
    
  </channel>
</rss>
