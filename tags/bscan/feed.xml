<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bscan on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jiege.ch/tags/bscan/</link>
    <description>Recent content in bscan on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 09 Feb 2020 15:11:00 +0800</lastBuildDate>
    
	<atom:link href="https://jiege.ch/tags/bscan/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>研究 Rocket Chip 的 BSCAN 调试原理</title>
      <link>https://jiege.ch/hardware/2020/02/09/rocket-chip-bscan-analysis/</link>
      <pubDate>Sun, 09 Feb 2020 15:11:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/2020/02/09/rocket-chip-bscan-analysis/</guid>
      <description>前言 最近 @jsteward 在研究如何通过 JTAG 对 FPGA 里的 Rocket Chip 进行调试。之前 @sequencer 已经做了一些实践，我们在重复他的工作，同时也研究了一下这是怎么工作的。
原理 我们从 @sequencer 得到了一份可用的 Scala 代码 和 OpenOCD 配置，并且了解到：
 可以通过 openocd 找到并调试 Rocket Chip openocd 是通过 JTAG 向 FPGA 的 TAP 的 IR 写入 USER4，然后往 DR 写入特定格式的数据，然后控制 Rocket Chip 的 JTAG。  这里涉及到一个“封装”的过程，在一个仅可以控制 DR 的 JTAG 中控制另一个 JTAG。首先可以找到 OpenOCD 端的操作代码：
tunneled_ir[3].num_bits = 3; tunneled_ir[3].out_value = bscan_zero; tunneled_ir[3].in_value = NULL; tunneled_ir[2].num_bits = bscan_tunnel_ir_width; tunneled_ir[2].out_value = ir_dtmcontrol; tunneled_ir[1].in_value = NULL; tunneled_ir[1].</description>
    </item>
    
  </channel>
</rss>