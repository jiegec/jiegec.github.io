<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xilinx on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/xilinx/</link>
    <description>Recent content in xilinx on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Apr 2023 17:19:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/xilinx/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在 LiteX 中使用 UART over JTAG</title>
      <link>https://jia.je/hardware/2023/04/24/litex-uart-over-jtag/</link>
      <pubDate>Mon, 24 Apr 2023 17:19:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/04/24/litex-uart-over-jtag/</guid>
      <description>背景 在给 Alinx AX7021 适配 LiteX 的时候，遇到一个问题：PL 上没有连接串口，只有 PS 连接了串口，如果用 RISC-V 软核的话，就会面临无串口可用的情况，除非在扩展 IO 上自己定义一个串口。
因此研究了一下 LiteX 自带的 UART over JTAG 功能，在 Alinx AX7021 中调试出来了。
LiteX 配置 启用很简单，直接在命令里添加 --uart-name jtag_uart 即可：
$ python3 -m litex_boards.targets.alinx_ax7021 --build --uart-name jtag_uart 如果要设置成默认的话，也可以在代码中添加：
if kwargs.get(&amp;#34;uart_name&amp;#34;, &amp;#34;serial&amp;#34;) == &amp;#34;serial&amp;#34;: # Defaults to JTAG-UART since UART is connected to PS instead of PL kwargs[&amp;#34;uart_name&amp;#34;] = &amp;#34;jtag_uart&amp;#34; 那么 FPGA 部分的准备就完成了，把 bitstream 下载到 FPGA 即可进入下一步。
OpenOCD 配置 下一步是使用 litex_term 来连接 UART over JTAG。它的启动方式是：</description>
    </item>
    
    <item>
      <title>在 Arty A7 上用 LiteX 和 VexRiscv 跑 Linux</title>
      <link>https://jia.je/hardware/2023/04/19/litex-digilent-arty-a7/</link>
      <pubDate>Wed, 19 Apr 2023 15:55:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/04/19/litex-digilent-arty-a7/</guid>
      <description>litex 安装 litex 安装过程按照 https://github.com/enjoy-digital/litex/wiki/Installation 进行，由于需要 pip install，建议用 venv 来开一个干净的环境：
python3 -m venv venv source venv/bin/activate cd litex ./litex_setup.py --init --install 构建 bitstream litex-boards 已经内建了 Arty A7 的支持，直接运行下列命令，就可以得到 bitstream：
python3 -m litex_boards.targets.digilent_arty --build --with-ethernet 这样就可以在 build/digilent_arty/gateware 目录下找到 bitstream。可以通过命令行参数来自定义需要的功能，详见 https://github.com/litex-hub/litex-boards/blob/f5e51d72bca6ed0325c1213791a78362326002f8/litex_boards/targets/digilent_arty.py#L162-L180。
如果想切换 CPU 为 Rocket Chip 的话，克隆并安装 https://github.com/litex-hub/pythondata-cpu-rocket，添加 --cpu-type rocket --cpu-variant small 参数即可。
下载 bitstream 最后，连接 microUSB 和网线到电脑，然后下载 bitstream：
openFPGALoader -b arty digilent_arty.bit screen /dev/tty.usbserial-XXXXXXXXXXXXX 115200 就可以看到 litex 的输出：
--=============== SoC ==================-- CPU: VexRiscv @ 100MHz BUS: WISHBONE 32-bit @ 4GiB CSR: 32-bit data ROM: 128.</description>
    </item>
    
    <item>
      <title>RAM 读写冲突</title>
      <link>https://jia.je/hardware/2023/04/07/ram-read-write-collision/</link>
      <pubDate>Fri, 07 Apr 2023 00:48:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/04/07/ram-read-write-collision/</guid>
      <description>背景 在 FPGA 或者 ASIC 中，通常都需要使用 RAM，通过读口、写口或者读写口来进行访问。常见的配置有单读写口（1RW），一读一写（1R1W）等等，读口通常有 1 个周期的延时。那么，如果在同一个周期内，读口和写口访问了同一个地址，会发生什么呢？可能会想到几种情况：
读和写都失败，读出的数据未定义，数据没写进去 数据写进去了，读出的数据未定义 数据写进去了，读出了写之前的旧数据 数据写进去了，读出了同一个周期写入的新数据 下面以具体的例子来看看，实际情况是什么样子。
Xilinx FPGA 首先测试的是 Xilinx FPGA 上的 RAM，测试的对象是 XPM，统一设置读延迟为一个周期，使用 Vivado 仿真。
一读一写 首先测试一读一写，也就是 xpm_memory_sdpram 模块。模块支持三种模式：NO_CHANGE（默认值）、READ_FIRST 和 WRITE_FIRST，因此我例化了三份，输入一样的信号，设置为三种不同的模式，然后比较输出结果。为了简化，读写使用一个时钟。下面是测试的波形：
图中第一个周期向地址 0 写入了 1111，然后第三个周期同时读写地址 0 的数据，此时 NO_CHANGE 和 WRITE_FIRST 两种模式中，写入成功，读取失败；READ_FIRST 模式读取成功，并且读取的是写入之前的数据。第四个周期时，读写没有出现冲突，三种模式都可以读出写入的新数据。
这有些出乎我的意料：之前在很多地方用过 XPM，但是都没考虑过读写地址相同的情况，而且默认设置（NO_CHANGE）下，输出结果是不确定的。实际上这个行为在 PG058 Block Memory Generator 里面提到了：
Synchronous Write-Read Collisions: A synchronous Write-Read collision might occur if a port attempts to Write a memory location and the other port reads the same location.</description>
    </item>
    
    <item>
      <title>DRAM 在 Kintex 7 FPGA 上内部 Vref 的性能问题</title>
      <link>https://jia.je/hardware/2021/12/13/dram-fpga-vref-problem/</link>
      <pubDate>Mon, 13 Dec 2021 20:06:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/13/dram-fpga-vref-problem/</guid>
      <description>背景 最近我们设计的 Kintex 7 FPGA 开发板在测试 DDR SDRAM 的时候遇到了一个问题，因为采用了 Internel VREF，MIG 在配置的时候限制了频率只能是 400 MHz，对应 800 MT/s，这样无法达到 DDR 的最好性能。
原理 首先，VREF 在 DDR 中是用来区分低电平和高电平的。在 JESD79-4B 标准中，可以看到，对于直流信号，电压不小于 VREF+0.075V 时表示高电平，而电压不高于 VREF-0.075V 时表示低电平。VREF 本身应该介于 VDD 的 0.49 倍到 0.51 倍之间。
在连接 FPGA 的时候，有两种选择：
Internal VREF: 从 FPGA 输出 VREF 信号到 DRAM External VREF：接入 FPGA 以外的 VREF 对于 7 Series 的 FPGA，Xilinx 要求如下：
For DDR3 SDRAM interfaces running at or below 800 Mb/s (400 MHz), users have the option of selecting Internal VREF to save two I/O pins or using external VREF.</description>
    </item>
    
    <item>
      <title>「教学」AXI Quad SPI 时序分析</title>
      <link>https://jia.je/hardware/2021/09/27/xilinx-axi-quad-spi-timing/</link>
      <pubDate>Mon, 27 Sep 2021 22:22:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/09/27/xilinx-axi-quad-spi-timing/</guid>
      <description>背景 之前一直没搞懂 Vivado 中 xdc 需要怎么编写，遇到一些必须要写 xdc 的时候就很头疼，不知道怎么写才可以得到正确的结果。今天分析了一下 AXI Quad SPI 的时序 xdc，终于理解了其中的含义。
AXI Quad SPI AXI Quad SPI 是一个 SPI 的控制器，它支持 XIP（eXecute In Place）模式，即可以暴露一个只读 AXI Slave 接口，当接收到读请求的时候，就按照标准的 SPI Flash 命令去对应的地址进行读取，然后返回结果。由于不同厂家的 SPI Flash 支持有所不同，所以 IP 上的设置可以看到厂家的选择。
特别地，一个常见的需求是希望访问 Cfg（Configuration）Flash，亦即用来保存 Bitstream 的 Flash。当 FPGA 上电的时候，如果启动模式设置为 SPI Flash，FPGA 就会向 Cfg Flash 读取 Bitstream，Cfg Flash 需要连接到 FPGA 的指定引脚上，当 FPGA 初始化的时候由内部逻辑驱动，初始化完成后又要转交给用户逻辑。转交的方式就是通过 STARTUP 系列的 primitive。
通常，如果要连接外部的 SPI Flash，需要连接几条信号线到顶层，然后通过 xdc 把信号绑定到引脚上，然后引脚连接了一个外部的 SPI Flash。但由于 Cfg Flash 比较特殊，所以信号从 AXI Quad SPI 直接连到 STARTUP 系列的 primitive 上。如果是采用 STARTUPE2 原语的 7 系列的 FPGA，那么只有时钟会通过 STARTUPE2 pritimive 连接到 SPI Flash 上，其他数据信号还是正常通过顶层绑定；如果是采用 STARTUPE3 原语的 UltraScale 系列的 FPGA，那么时钟和数据都通过 STARTUPE3 primitive 连接到 SPI Flash。</description>
    </item>
    
    <item>
      <title>给 Rocket Chip 挂接串口外设</title>
      <link>https://jia.je/os/2019/05/08/axi-uart-interrupt/</link>
      <pubDate>Wed, 08 May 2019 11:04:00 +0800</pubDate>
      
      <guid>https://jia.je/os/2019/05/08/axi-uart-interrupt/</guid>
      <description>前言 最近在给 rCore 添加 Rocket Chip 支持。下面讲讲最近做了哪些工作，遇到了哪些坑，都是怎么解决的。
踩坑过程 Rocket Chip 运行代码 首先分析了一下已有的代码和工作方式，这个 Rocket Chip（ucb-bar/fpga-zynq）的设计大概是这样的：在 PS 上通过 fesvr 向 Rocket Chip 写入程序。Rocket Chip 本身暴露出一个 TSI，一个串口的调试接口，通过 Zynq Adapter 挂到了 PS 下的 AXI 总线，暴露出若干个寄存器，大概如下：
/** * Address Map * 0x00 - serial out FIFO data * 0x04 - serial out FIFO data available (words) * 0x08 - serial in FIFO data * 0x0C - serial in FIFO space available (words) * 0x10 - system reset * 0x20 - req FIFO data * 0x24 - req FIFO data available (words) * 0x28 - data FIFO data * 0x2C - data FIFO data available (words) * 0x30 - resp FIFO data * 0x34 - resp FIFO space available (words) * 0x38 - nsectors * 0x3C - max request length */ 前面的是调试接口，后面的是 block device 和 network，我们暂时还没有用到这些 UCB BAR 做的私货。在 Vivado 中，地址 Offset 是 0x43C00000，所以代码中就这样访问对应的物理地址：</description>
    </item>
    
  </channel>
</rss>
