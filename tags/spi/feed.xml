<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spi on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/spi/</link>
    <description>Recent content in spi on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Apr 2023 00:28:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/spi/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SPI 协议</title>
      <link>https://jia.je/hardware/2023/04/26/spi/</link>
      <pubDate>Wed, 26 Apr 2023 00:28:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/04/26/spi/</guid>
      <description>本文的内容已经整合到知识库中。
背景 最近数设课上，同学们开始购买外设，其中就涉及到 SPI 协议，因此顺带写一下 SPI 协议的教程，帮助同学们进行理解。
接口 SPI 协议涉及到四个信号：
SCLK: 时钟信号，Master -&amp;gt; Slave MOSI：数据信号，Master -&amp;gt; Slave MISO：数据信号，Slave -&amp;gt; Master CS：芯片使能，一般是低有效 要通过 SPI 协议发送命令的时候，通常需要先拉低 CS，然后启动 SCLK 时钟，同时收发数据。注意 SPI 是全双工的，也就是发送的同时也在接收，只不过通常来说，外设等到主机发送了命令本身，才知道要回复什么，所以很多时候命令设计成了事实上的半双工：前半部分主机在发命令，外设发送无用的数据；后半部分外设在发送响应，主机发送无用的数据。
波形 SPI 有不同的类型，下面讲一种比较常见的配置（即 CPOL=0，CPHA=0），在这种模式下，Master 和 Slave 都是在时钟的下降沿修改输出的数据，然后在时钟（sclk）的上升沿对接收到的数据进行采样：
波形图中，时钟（sclk）上升沿时，数据处于稳定的状态，所以此时 Master 对 MISO 采样，Slave 对 MOSI 采样，可以得到稳定的数据；时钟下降沿时，Master 和 Slave 修改输出的数据。
实际在 RTL 中实现的时候，Master 可以不写 negedge 逻辑，而是写一个分频器，在分频出来的负半周期里，实现数据的修改，如上图中的 clk 分频到 sclk。一般使用一个状态机来实现 SPI Master，记录当前传输到哪一个 bit，以及记录当前是 sclk 的正半周期还是负半周期。
SPI 本身很简单，所以核心不在 SPI，而是在 SPI 之上定义的各种协议。
SPI Flash SPI Flash 是一种很常见的 SPI 外设，可以用来访问 NAND/NOR Flash。</description>
    </item>
    
    <item>
      <title>「教学」AXI Quad SPI 时序分析</title>
      <link>https://jia.je/hardware/2021/09/27/xilinx-axi-quad-spi-timing/</link>
      <pubDate>Mon, 27 Sep 2021 22:22:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/09/27/xilinx-axi-quad-spi-timing/</guid>
      <description>本文的内容已经整合到知识库中。
背景 之前一直没搞懂 Vivado 中 xdc 需要怎么编写，遇到一些必须要写 xdc 的时候就很头疼，不知道怎么写才可以得到正确的结果。今天分析了一下 AXI Quad SPI 的时序 xdc，终于理解了其中的含义。
AXI Quad SPI AXI Quad SPI 是一个 SPI 的控制器，它支持 XIP（eXecute In Place）模式，即可以暴露一个只读 AXI Slave 接口，当接收到读请求的时候，就按照标准的 SPI Flash 命令去对应的地址进行读取，然后返回结果。由于不同厂家的 SPI Flash 支持有所不同，所以 IP 上的设置可以看到厂家的选择。
特别地，一个常见的需求是希望访问 Cfg（Configuration）Flash，亦即用来保存 Bitstream 的 Flash。当 FPGA 上电的时候，如果启动模式设置为 SPI Flash，FPGA 就会向 Cfg Flash 读取 Bitstream，Cfg Flash 需要连接到 FPGA 的指定引脚上，当 FPGA 初始化的时候由内部逻辑驱动，初始化完成后又要转交给用户逻辑。转交的方式就是通过 STARTUP 系列的 primitive。
通常，如果要连接外部的 SPI Flash，需要连接几条信号线到顶层，然后通过 xdc 把信号绑定到引脚上，然后引脚连接了一个外部的 SPI Flash。但由于 Cfg Flash 比较特殊，所以信号从 AXI Quad SPI 直接连到 STARTUP 系列的 primitive 上。如果是采用 STARTUPE2 原语的 7 系列的 FPGA，那么只有时钟会通过 STARTUPE2 pritimive 连接到 SPI Flash 上，其他数据信号还是正常通过顶层绑定；如果是采用 STARTUPE3 原语的 UltraScale 系列的 FPGA，那么时钟和数据都通过 STARTUPE3 primitive 连接到 SPI Flash。</description>
    </item>
    
  </channel>
</rss>
