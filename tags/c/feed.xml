<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/c/</link>
    <description>Recent content in c on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Apr 2023 09:24:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/c/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C/C&#43;&#43; 数参数个数的特别方法</title>
      <link>https://jia.je/programming/2023/04/14/counting-arguments/</link>
      <pubDate>Fri, 14 Apr 2023 09:24:00 +0800</pubDate>
      
      <guid>https://jia.je/programming/2023/04/14/counting-arguments/</guid>
      <description>背景 群友上个月提了一个未知来源问题：
实现一个你自己的 printf(int, ...) 函数，该函数包含可变参数。为简便期间，假设所有参数均为 int 类型。
第一个参数是一个普通参数，不表示后续可变参数的数目 在 printf 中逐个输出所有传入的整数值（可使用系统自带的 kprintf 实现输出） 思考如何判定参数结束，是否有副作用 va_args 我们知道，传统的处理可变参数的方法是 va_args，但是它无法知道传入了多少参数，而要像 POSIX printf 那样，解析 format 参数，然后一个一个去取。
所以问题的关键是，如何获取参数的个数？一个思路是宏，尝试用宏的魔法来计算出参数个数，这个方法可能是可以的，但是没有深究。另一个思路是利用 ABI 的特点，例如 i386 上参数是通过栈传递的，那或许可以在栈上找到所有的 int，但是问题是无法确认参数在哪里结束。
__builtin_va_arg_pack_len 今天，另一位群友发了一个链接：https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls，讲述了 GCC 中一些特别的 builtin 函数，用于函数调用相关的魔法，其中一段描述吸引了我的眼球：
Built-in Function: int __builtin_va_arg_pack_len () This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using __attribute__ ((__always_inline__)) or __attribute__ ((__gnu_inline__)) extern inline functions.</description>
    </item>
    
    <item>
      <title>IP 前缀转换上意外遇到的 Undefined Behavior</title>
      <link>https://jia.je/programming/2019/06/21/ip-prefix-unexpected-undefined-behavior/</link>
      <pubDate>Fri, 21 Jun 2019 21:23:00 +0800</pubDate>
      
      <guid>https://jia.je/programming/2019/06/21/ip-prefix-unexpected-undefined-behavior/</guid>
      <description>最近发现了两个很神奇的 Undefined Behavior，出现在 Prefix Len 和 Netmask 的转换的问题下。一个简单思路可能是：
#define PREFIX_BIN2DEC(bin) (32 - __builtin_ctz((bin))) #define PREFIX_DEC2BIN(hex) (((~0) &amp;gt;&amp;gt; (32 - (hex))) &amp;lt;&amp;lt; (32 - (hex)) 乍一看，似乎没有什么问题。但是，在一些平台下，可能会出现这样的结果：
PREFIX_BIN2DEC(0x00000000) = 33 PREFIX_DEC2BIN(0) = 0xFFFFFFFF 而且只能在一些平台上不确定地复现，最后发现其实是 Undefined Behavior，在 C 的标准中：
In any case, the behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs. 意味着， 0xFFFFFFFF &amp;gt;&amp;gt; 32 是一个 UB，所以出现了上面的问题。
另外，__builtin_ctz 有这样的说明：
Returns the number of trailing 0-bits in x, starting at the least significant bit position.</description>
    </item>
    
    <item>
      <title>在 Linux 中用 C 代码获取 DNS 服务器列表</title>
      <link>https://jia.je/software/2019/04/30/get-resolvers-in-c/</link>
      <pubDate>Tue, 30 Apr 2019 17:39:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2019/04/30/get-resolvers-in-c/</guid>
      <description>最近在做一个作业的时候，发现里面有个步骤是获取 Linux 系统中的 DNS 服务器列表，它的方法很粗暴，直接 cat grep cut 再处理。我就在想有没有完全代码的实现，然后搜了一下，果然有：
#include &amp;lt;resolv.h&amp;gt; // ... res_init(); // _res.nsaddr_list is an array of resolvers 用到了全局变量 _res ，虽然很 hacky，但是至少是工作的，不清楚兼容性几何。</description>
    </item>
    
    <item>
      <title>再次吐槽 VS 关于 scanf 和 scanf_s 的问题</title>
      <link>https://jia.je/programming/2018/01/30/more-on-scanf-and-scanf_s/</link>
      <pubDate>Tue, 30 Jan 2018 16:05:33 +0800</pubDate>
      
      <guid>https://jia.je/programming/2018/01/30/more-on-scanf-and-scanf_s/</guid>
      <description>继上次的吐槽后，今天再次遇到同学因为 scanf 在 VS 下的 deprecation error 感到十分迷茫，在知乎上求助又因为拍照的原因被说，我就在此再次吐槽一下 VS 这对初学者很不友善很不友善的两点。
一点就是上面提到的这个，另一点就是程序结束后任意键以退出这一功能要做得更加醒目一点。前者由于大多数新手在学习 C/C++ 的时候都会跟着书上或者网上的代码敲一遍输入输出的代码，很容易就会撞到这个问题。后者则会让新手习惯性地以为程序闪退了，没有出结果，而不知道其实是程序执行结束后关闭而已。</description>
    </item>
    
    <item>
      <title>关于 scanf 和 scanf_s 的问题</title>
      <link>https://jia.je/programming/2017/10/17/on-scanf-and-scanf_s/</link>
      <pubDate>Tue, 17 Oct 2017 16:46:40 +0800</pubDate>
      
      <guid>https://jia.je/programming/2017/10/17/on-scanf-and-scanf_s/</guid>
      <description>最近作为程设基础的小教员，收到很多同学的求助，关于scanf和scanf_s的问题已经遇到了两次，特此写一篇博文来叙述一下这个问题。
一开始，有同学问我，
char a; scanf(&amp;#34;%c&amp;#34;,&amp;amp;a); 为什么会报错？我说，vs 默认强制要求使用 scanf_s 函数，于是我建议这位同学把这个错误信息关掉了。嗯。经过百度，这位同学的问题解决了。
后来，又有一位同学问我，
char a; scanf_s(&amp;#34;%c&amp;#34;,&amp;amp;a); 程序为什么会崩溃？我想了想，如果 scanf_s 和 scanf 是一样的行为，这段代码是没问题的。但 scanf_s 既然安全，必然是在字符串方面做了处理。这里的 char*勉强也算一个？网上一查，果然，应该写成scanf_s(&amp;quot;%c&amp;quot;,&amp;amp;a,1);，字符串则要写成scanf_s(&amp;quot;%s&amp;quot;,str,sizeof(str))，来保证缓冲区不会溢出。
但是，这样解决这个问题又面临着不同的选择：
学习scanf_s和scanf的不同，把所有scanf换成scanf_s并做相应的修改。 这样当然符合了语言进化的潮流，也会让 vs 闭嘴。但是，scanf_s 只有在 C11 标准中有，而且，根据cpprefrence.com 上关于 scanf 的描述，只有在__STDC_LIB_EXT1__被定义且在#include&amp;lt;stdio.h&amp;gt;之前#define __STDC_WANT_LIB_EXT1__才能确保使用scanf_s能使用，当然在 vs 较新版本中是默认可以使用的。但是，程设基础的作业是要丢到 oj 上的，而 oj 上的编译器不一定支持这些，所以这个选项不行。 坚持用scanf，自己按照题目要求保证缓冲区不溢出，同时让 vs 闭嘴。 网上已有教程，已经讲的很全面了，大家可以根据这个教程把 vs 教训一顿。为了能在 oj 里跑，建议用里面的方法五到八。（个人最推荐在文件头添加#define _CRT_SECURE_NO_WARNINGS） 以后再遇到这个问题，我就丢这个连接上来就好了咯。yeah！</description>
    </item>
    
  </channel>
</rss>
