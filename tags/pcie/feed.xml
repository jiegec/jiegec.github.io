<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pcie on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/pcie/</link>
    <description>Recent content in pcie on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Jan 2023 15:41:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/pcie/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PCIe Bifurcation</title>
      <link>https://jia.je/hardware/2023/01/05/pcie-bifurcation/</link>
      <pubDate>Thu, 05 Jan 2023 15:41:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2023/01/05/pcie-bifurcation/</guid>
      <description>背景 最近看到两篇关于 PCIe Bifurcation 的文章：
intel 部分桌面级 CPU 的 pcie 通道拆分另类低成本实现 Intel Alder Lake 12 代酷睿 CPU PCIe 拆分实现方法 文章讲的是如何在 CPU 上进行跳线，从而实现 PCIe Bifurcation 的配置。正好借此机会来研究一下 PCIe Bifurcation。
PCIe Bifurcation PCIe Bifurcation 的目的是让 PCIe 有更好的灵活性。从 CPU 出来的几路 PCIe，它的宽度一般是确定的，比如有一个 x16，但是实际使用的时候，想要接多个设备，例如把 x16 当成两个 x8 来用，这就是 PCIe Bifurcation。这需要 PCIe 两端的支持，CPU 端需要可配置 PCIe Bifurcation，不然只能从一个 x16 降级到一个 x8，剩下的 8x 就没法利用了；设备端需要拆分卡，把 x16 的信号分成两路，然后提供两个 PCIe 插槽以及使用 Clock Buffer 来提供下游设备的时钟，有时则是主板设计时就做了拆分，不需要额外的拆分卡。
那么怎么配置 CPU 端的 PCIe Bifurcation 呢？其实就是上面两篇文章提到的办法：CPU 根据 CFG 信号来决定 PCIe Bifurcation 配置，例如要选择 1x16，2x8 还是 1x8+2x4 等等。简单总结一下实现思路都是：</description>
    </item>
    
    <item>
      <title>PCIe 学习笔记</title>
      <link>https://jia.je/hardware/2022/11/12/pcie-notes/</link>
      <pubDate>Sat, 12 Nov 2022 14:56:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2022/11/12/pcie-notes/</guid>
      <description>背景 最近在知乎上看到 LogicJitterGibbs 的 资料整理：可以学习 1W 小时的 PCIe，我跟着资料学习了一下，然后在这里记录一些我学习 PCIe 的笔记。
下面的图片主要来自 PCIe 3.0 标准以及 MindShare 的 PCIe 3.0 书本。
分层 PCIe 定义了三个层：Transaction Layer，Data Link Layer，Physical Layer，和 TCP/IP 四层模型很像。PCIe 也是基于 Packet 传输的。
Transaction Layer Transaction Layer 的核心是 Transaction Layer Packet(TLP)。TLP 格式：
即可选的若干个 Prefix，一个 Header，可选的 Data Payload，可选的 Digest。
Prefix 和 Header 开头的一个字节是 Fmt[2:0] 和 Type[4:0] 字段。Fmt 决定了 header 的长度，有无数据，或者这是一个 Prefix。
它支持几类 Packet：
Memory: MMIO Read Request(MRd)/Completion(CplD) Write Request(MWr): 注意只有 Request，没有 Completion AtomicOp Request(FetchAdd/Swap/CAS)/Completion(CplD) Locked Memory Read(MRdLk)/Completion(CplDLk): Legacy IO: Legacy Read Request(IORd)/Completion(CplD) Write Request(IOWr)/Completion(Cpl) Configuration: 访问配置空间 Read Request(CfgRd0/CfgRd1)/Completion(CplD) Write Request(CfgWr0/CfgWr1)/Completion(Cpl) Message: 传输 event Request(Msg/MsgD) 括号里的是 TLP Type，对应了它 Fmt 和 Type 字段的取值。如果 Completion 失败了，原来应该是 CplD/CplDLk 的 Completion 会变成不带数据的 Cpl/CplLk。</description>
    </item>
    
    <item>
      <title>硬盘相关的概念</title>
      <link>https://jia.je/hardware/2021/05/06/disk/</link>
      <pubDate>Thu, 06 May 2021 11:37:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/05/06/disk/</guid>
      <description>ATA ATA 定义了发送给硬盘的命令，标准定义了命令：
ech IDENTIFY DEVICE: 获取设备信息 25h READ DMA EXT: 读取扇区 35h WRITE DMA EXT: 写入扇区 ATA 同时也是接口，图片如下。ATA 前身是 IDE，现在 ATA 叫做 PATA。
AHCI AHCI 可以简单理解为 PCIe &amp;lt;-&amp;gt; SATA 的转换器。AHCI 暴露为一个 PCIe 设备：
$ lspci -vv 00:1f.2 SATA controller: Intel Corporation C600/X79 series chipset 6-Port SATA AHCI Controller (rev 05) Kernel modules: ahci 处理器通过 IO port/MMIO 访问 AHCI，然后 AHCI HBA 连接到 SATA 设备。
SATA SATA 一般说的是接口。它一般分为两个部分，数据和电源。数据部分只有 7 个 pin，三个 GND 和两对差分线（A+A- B+B-），图片如下：</description>
    </item>
    
  </channel>
</rss>
