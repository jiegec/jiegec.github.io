<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gcc on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/gcc/</link>
    <description>Recent content in gcc on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 May 2022 20:35:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/gcc/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LoongArch64 工具链构建</title>
      <link>https://jia.je/software/2022/05/02/loongarch64-toolchain/</link>
      <pubDate>Mon, 02 May 2022 20:35:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2022/05/02/loongarch64-toolchain/</guid>
      <description>最近因为龙芯杯的原因，想自己搞个 LoongArch64 的交叉编译工具链试试，结果遇到了很多坑，最后终于算是搞出来了。
一开始是想搞一个 newlib 的工具链，比较简单，而且之前做过一个仓库：jiegec/riscv-toolchain，就是构建的 riscv64-unknown-elf 工具链，照着 riscv-gnu-toolchain 就可以了。不过研究发现，newlib 还不支持 loongarch，目前只有 glibc 支持，只好硬着头皮上了。
于是我就在 riscv-toolchain 的基础上搞 loongarch64-unknown-linux-gnu，也就是带 glibc 的工具链，结果发现遇到很多坑。首先编译 libgcc 的时候就找不到头文件，于是先要从 glibc 和 linux 安装头文件到 sysroot 里面，对于 sysroot 里面的头文件路径到底是 include 还是 usr/include 也折腾了半天。然后编译 libgcc 又各种出问题，最后折腾了半天，结果是 gcc stage1 和 glibc 都没问题，gcc stage2 会报链接错误，但是不管它也能用，可以编译出正常的程序，毕竟 libc 是好的。
于是转念一想，要不要试试 crosstool-ng。克隆了一份上游的版本，照着 riscv 的部分抄了一份变成了 loongarch，然后把 config 里面的 linux/glibc/gcc/binutils-gdb 都替换为 custom location，这样我就可以用上游的最新版本了。中途还遇到了 crosstool-ng 对 gcc 12/13 不兼容的 bug，还好下面有人提出了解决方法。这些都搞定以后，终于构建出了一个完整的 loongarch64-unknown-linux-gnu 工具链。仓库地址是 jiegec/ct-ng-loongarch64，需要配合添加了 LoongArch 的 jiegec/crosstool-ng loongarch 分支 使用。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 11 的 ABI 问题</title>
      <link>https://jia.je/programming/2021/06/23/cpp-11-abi-problem/</link>
      <pubDate>Wed, 23 Jun 2021 14:48:00 +0800</pubDate>
      
      <guid>https://jia.je/programming/2021/06/23/cpp-11-abi-problem/</guid>
      <description>背景 有同学遇到这样的一个问题，代码中链接了一个第三方的动态库，在链接的时候出现了不一致的问题，比如有一个函数签名如下：
void foobar(std::string s) {} 使用 GCC 11.1.0 编译上面的代码，可以发现它需要的符号是 _Z6foobarNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE，但是第三方库里面却是 _Z6foobarSs，因此找不到对应的符号，链接失败。
问题 经过一番研究，发现 Ss 在 Itanium ABI 中表示的是缩写：
In addition, the following catalog of abbreviations of the form &amp;#34;Sx&amp;#34; are used: &amp;lt;substitution&amp;gt; ::= St # ::std:: &amp;lt;substitution&amp;gt; ::= Sa # ::std::allocator &amp;lt;substitution&amp;gt; ::= Sb # ::std::basic_string &amp;lt;substitution&amp;gt; ::= Ss # ::std::basic_string &amp;lt; char, ::std::char_traits&amp;lt;char&amp;gt;, ::std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;lt;substitution&amp;gt; ::= Si # ::std::basic_istream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt; &amp;lt;substitution&amp;gt; ::= So # ::std::basic_ostream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt; &amp;lt;substitution&amp;gt; ::= Sd # ::std::basic_iostream&amp;lt;char, std::char_traits&amp;lt;char&amp;gt; &amp;gt; 这看起来很正常，_Z6foobarSs 表示的是 foobar(std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;)，但是 GCC 11.</description>
    </item>
    
    <item>
      <title>在 Big Sur(M1) 上解决 LaTeX 找不到楷体字体的问题</title>
      <link>https://jia.je/software/2021/02/09/big-sur-m1-latex-kaiti-fonts/</link>
      <pubDate>Tue, 09 Feb 2021 20:08:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2021/02/09/big-sur-m1-latex-kaiti-fonts/</guid>
      <description>背景 最近在尝试移植 MiKTeX 到 Apple Silicon 上，添加了一些 patch 以后就可以工作了，但遇到了新的问题，即找不到 KaiTi
~/Library/Application Support/MiKTeX/texmfs/install/tex/latex/ctex/fontset/ctex-fontset-macnew.def:99: Package fontspec Error: The font &amp;#34;Kaiti SC&amp;#34; cannot be found. 用 miktex-fc-list 命令找了一下，确实没有找到：
$ /Applications/MiKTeX\ Console.app/Contents/bin/miktex-fc-list | grep Kaiti # Nothing 上网搜了一下，找到了一个解决方案：字体在目录 /System/Library/Frameworks/ApplicationServices.framework/Versions/A/Frameworks/ATS.framework/Versions/A/Support/FontSubsets/Kaiti.ttc 里，所以手动安装一下，就可以让 LaTeX 找到了。但我觉得，与其安装多一份在文件系统里，不如让 LaTeX 去找它。
解决方法 按照上面的线索，找到了 Kaiti.ttc 所在的路径：
$ fd Kaiti.ttc /System/Library/PrivateFrameworks/FontServices.framework/Versions/A/Resources/Fonts/Subsets/Kaiti.ttc 可以看到，和上面的路径又不大一样。研究了一下 fontconfig，发现可以用 miktex-fc-conflist 找到配置文件的目录：
$ /Applications/MiKTeX\ Console.app/Contents/bin/miktex-fc-conflist + ~/Library/Application Support/MiKTeX/texmfs/config/fontconfig/config/localfonts2.conf: No description + ~/Library/Application Support/MiKTeX/texmfs/config/fontconfig/config/localfonts.conf: No description ... 看了下第一个文件（localfonts.conf）：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>COMMON 符号</title>
      <link>https://jia.je/software/2021/02/09/common-symbols-linking/</link>
      <pubDate>Tue, 09 Feb 2021 19:02:00 +0800</pubDate>
      
      <guid>https://jia.je/software/2021/02/09/common-symbols-linking/</guid>
      <description>背景 在编译一个程序的时候，遇到了 undefined symbol 的问题。具体情况是这样的：
一开始的时候，直接把所有的源代码编译成 .o，再一次性链接，这样不会报错 后来，把一些代码编译成静态库，即把其中一部分源代码编译成 .o 后，用 ar 合并到一个 .a 中，再和其余的 .o 链接在一起，这时候就报错了： Undefined symbols for architecture arm64: &amp;#34;_abcd&amp;#34;, referenced from: ... 如果换台机器，编译（使用的是 gcc 10.2.0）就没有问题。
而如果去找这个符号存在的 .o 里，是可以找到的：
$ objdump -t /path/to/abcd.o 0000000000000028 *COM* 00000008 _abcd 在合成的静态库 .a 里，也是存在的（一个定义 + 若干个引用）：
$ objdump -t /path/to/libabc.a | grep abcd 0000000000000028 *COM* 00000008 _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 0000000000000000 *UND* _abcd 于是觉得很奇怪，就上网搜了一下，找到了一篇 StackOverflow 讲了这个问题。解决方案很简单，就是：</description>
    </item>
    
  </channel>
</rss>
