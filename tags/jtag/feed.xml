<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jtag on 杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jia.je/tags/jtag/</link>
    <description>Recent content in jtag on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Dec 2021 14:01:00 +0800</lastBuildDate><atom:link href="https://jia.je/tags/jtag/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RISC-V Debug 分析</title>
      <link>https://jia.je/hardware/2021/12/12/riscv-debug/</link>
      <pubDate>Sun, 12 Dec 2021 14:01:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2021/12/12/riscv-debug/</guid>
      <description>参考文档  RISC-V Debug Spec 0.13 IEEE Standard for JTAG 1149.1-2013 OpenOCD 相关代码  背景 之前用过一些 RISC-V 核心，但是遇到调试相关的内容的时候就两眼一抹黑，不知道原理，出了问题也不知道如何排查，趁此机会研究一下工作原理。
架构 为了调试 RISC-V 核心，需要很多部件一起工作。按 RISC-V Debug Spec 所述，有这么几部分：
 Debugger: GDB，连接到 OpenOCD 启动的 GDB Server Debug Translator: OpenOCD，向 GDB 提供 Server 实现，同时会通过 FTDI 等芯片控制 JTAG Debug Transport Hardware: 比如 FTDI 的芯片，可以提供 USB 接口，让 OpenOCD 控制 JTAG 信号 TMS/TDI/TCK 的变化，并读取 TDO Debug Transport Module: 在芯片内部的 JTAG 控制器（TAP），符合 JTAG 标准 Debug Module Interface：RISC-V 自定义的一系列寄存器，通过这些寄存器来控制 Debug Module 的行为 Debug Module：调试器，控制 RISC-V 核心，同时也支持直接访问总线，也有内部的 Program Buffer  可以看到，DMI 是实际的调试接口，而 JTAG 可以认为是一个传输协议。</description>
    </item>
    
    <item>
      <title>通过 BSCAN JTAG 对 Rocket Chip 进行调试</title>
      <link>https://jia.je/hardware/2020/02/10/rocket-chip-bscan-debug/</link>
      <pubDate>Mon, 10 Feb 2020 15:08:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2020/02/10/rocket-chip-bscan-debug/</guid>
      <description>前言 在上一个 post 里研究了原理，今天也是成功在 Artix 7 上实现了调试。效果如下：
OpenOCD 输出：
Info : JTAG tap: riscv.cpu tap/device found: 0x0362d093 (mfg: 0x049 (Xilinx), part: 0x362d, ver: 0x0) Info : datacount=1 progbufsize=16 Info : Disabling abstract command reads from CSRs. Info : Examined RISC-V core; found 1 harts Info : hart 0: XLEN=32, misa=0x40801105 Info : Listening on port 3333 for gdb connections GDB 输出：
Remote debugging using localhost:3333 0x0001018c in getc () at bootloader.</description>
    </item>
    
    <item>
      <title>研究 Rocket Chip 的 BSCAN 调试原理</title>
      <link>https://jia.je/hardware/2020/02/09/rocket-chip-bscan-analysis/</link>
      <pubDate>Sun, 09 Feb 2020 15:11:00 +0800</pubDate>
      
      <guid>https://jia.je/hardware/2020/02/09/rocket-chip-bscan-analysis/</guid>
      <description>前言 最近 @jsteward 在研究如何通过 JTAG 对 FPGA 里的 Rocket Chip 进行调试。之前 @sequencer 已经做了一些实践，我们在重复他的工作，同时也研究了一下这是怎么工作的。
原理 我们从 @sequencer 得到了一份可用的 Scala 代码 和 OpenOCD 配置，并且了解到：
 可以通过 openocd 找到并调试 Rocket Chip openocd 是通过 JTAG 向 FPGA 的 TAP 的 IR 写入 USER4，然后往 DR 写入特定格式的数据，然后控制 Rocket Chip 的 JTAG。  这里涉及到一个“封装”的过程，在一个仅可以控制 DR 的 JTAG 中控制另一个 JTAG。首先可以找到 OpenOCD 端的操作代码：
tunneled_ir[3].num_bits = 3; tunneled_ir[3].out_value = bscan_zero; tunneled_ir[3].in_value = NULL; tunneled_ir[2].num_bits = bscan_tunnel_ir_width; tunneled_ir[2].out_value = ir_dtmcontrol; tunneled_ir[1].in_value = NULL; tunneled_ir[1].</description>
    </item>
    
  </channel>
</rss>
