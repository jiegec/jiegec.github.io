<!DOCTYPE html>
<html>
<head>
    <title>杰哥的{运维,编程,调板子}小笔记</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="杰哥的{运维,编程,调板子}小笔记" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://jia.je/" />
    
<link href="/feed.xml" rel="alternate" type="application/rss+xml" title="杰哥的{运维,编程,调板子}小笔记" />
    <link rel="shortcut icon" href="/favicon.ico">

    <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/style.css">
    
    <script src="/js/wavedrom/default.js" type="text/javascript"></script>
    <script src="/js/wavedrom/wavedrom.min.js" type="text/javascript" /></script>

    <meta name="generator" content="Hugo 0.111.3">
</head>

<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="/">杰哥的{运维,编程,调板子}小笔记</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">关于</a>
                
                <a class="main-nav-link" href="/category/">分类</a>
                
                <a class="main-nav-link" href="/open-source-contributions/">开源</a>
                
                <a class="main-nav-link" href="/tags/">标签</a>
                
                <a class="main-nav-link" href="/kb/">知识库</a>
                
                <a class="main-nav-link" href="/series/">系列</a>
                
                <a class="main-nav-link" href="/feed.xml">订阅</a>
                
                <a class="main-nav-link" href="/projects/readme/">项目</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2023/04/20/dram-topology-training/">DRAM 的拓扑和训练</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2023/04/20/dram-topology-training/" class="article-date">
                        <time datetime='2023-04-20T09:11:00.000&#43;08:00' itemprop="datePublished">2023-04-20</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2023/04/20/dram-topology-training/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    本文的内容已经整合到知识库中。
DRAM Training DRAM 一直有一个比较麻烦的初始化过程，就是 DRAM Training，其中很重要的一步就是计算出各个数据线相对于时钟的偏移（skew）。这个偏移是怎么来的呢？
我们知道，对于 SRAM，如果想要更多的位宽，只需要把地址线和控制信号连接到多个 SRAM 上，然后把 SRAM 的数据信号并行连接到 FPGA 上就可以了，但是前提是要尽量保证等长，否则一样有偏移的问题。DRAM 也是采用类似的方法进行扩展的，但是 DRAM 通常需要并行连接很多个芯片，例如 8 个 x8 的芯片的合并成一个 64 位的 DDR SDRAM。此时数据线依然是并行连接，但是地址线和控制信号就出现了走线困难：很难在那么小的空间里，等长地把地址和控制信号分布到各个芯片上，而且还有信号完整性的问题。
Fly-by topology 因此，实际上地址和控制信号是采用了串联的方式连接，也就是下图的右边的连接方式：
图源 Versal ACAP PCB Design User Guide (UG863)。
但是数据信号（DQ 和 DQS）依然是并行点对点连接到 DRAM 上的（上图左侧）。这就出现了问题：不同的 DRAM 芯片，数据和时钟的偏差不同，数据可能差不多时间到，但是时钟的延迟越来越大：
注：这里简化了，当成 SDR 来画。
不做任何处理的话，DRAM 采样得到的数据就不正确了。为了解决这个问题，就需要人为地在数据信号上也加上可变的延迟，保证时钟和数据同步，这样 DRAM 才可以实现正确的写入：
Write Leveling 为了解决写入时，时钟和数据有偏移的问题，需要采用 Write Leveling 方法来解决。具体思路是这样的：如果 DRAM 以时钟信号去采样数据信号可以得到正确的结果，那反过来，如果认为数据信号是时钟信号，在数据信号的上升沿去采样时钟，应该也可以观测到稳定的结果。
所以 Write Leveling 的工作方式就是：
设置 DRAM 进入 Write Leveling 模式，此时 DRAM 会使用 DQS 信号来采样 CK 信号，把结果输出到 DQ 上 DDR 控制器不断地修改 DQS 的输出延迟，然后统计 DQ 上的输出 示意图如下：
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2023/04/20/dram-topology-training/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/ddr">ddr
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sdram">sdram
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/dram">dram
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2023/04/19/litex-digilent-arty-a7/">在 Arty A7 上用 LiteX 和 VexRiscv 跑 Linux</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2023/04/19/litex-digilent-arty-a7/" class="article-date">
                        <time datetime='2023-04-19T15:55:00.000&#43;08:00' itemprop="datePublished">2023-04-19</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2023/04/19/litex-digilent-arty-a7/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    litex 安装 litex 安装过程按照 https://github.com/enjoy-digital/litex/wiki/Installation 进行，由于需要 pip install，建议用 venv 来开一个干净的环境：
python3 -m venv venv source venv/bin/activate cd litex ./litex_setup.py --init --install 构建 bitstream litex-boards 已经内建了 Arty A7 的支持，直接运行下列命令，就可以得到 bitstream：
python3 -m litex_boards.targets.digilent_arty --build --with-ethernet 这样就可以在 build/digilent_arty/gateware 目录下找到 bitstream。可以通过命令行参数来自定义需要的功能，详见 https://github.com/litex-hub/litex-boards/blob/f5e51d72bca6ed0325c1213791a78362326002f8/litex_boards/targets/digilent_arty.py#L162-L180。
如果想切换 CPU 为 Rocket Chip 的话，克隆并安装 https://github.com/litex-hub/pythondata-cpu-rocket，添加 --cpu-type rocket --cpu-variant small 参数即可。
下载 bitstream 最后，连接 microUSB 和网线到电脑，然后下载 bitstream：
openFPGALoader -b arty digilent_arty.bit screen /dev/tty.usbserial-XXXXXXXXXXXXX 115200 就可以看到 litex 的输出：
--=============== SoC ==================-- CPU: VexRiscv @ 100MHz BUS: WISHBONE 32-bit @ 4GiB CSR: 32-bit data ROM: 128.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2023/04/19/litex-digilent-arty-a7/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/digilent">digilent
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/arty">arty
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/xilinx">xilinx
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/fpga">fpga
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/litex">litex
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/programming/2023/04/14/counting-arguments/">C/C&#43;&#43; 数参数个数的特别方法</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/programming/2023/04/14/counting-arguments/" class="article-date">
                        <time datetime='2023-04-14T09:24:00.000&#43;08:00' itemprop="datePublished">2023-04-14</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/programming/2023/04/14/counting-arguments/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 群友上个月提了一个未知来源问题：
实现一个你自己的 printf(int, ...) 函数，该函数包含可变参数。为简便期间，假设所有参数均为 int 类型。
第一个参数是一个普通参数，不表示后续可变参数的数目 在 printf 中逐个输出所有传入的整数值（可使用系统自带的 kprintf 实现输出） 思考如何判定参数结束，是否有副作用 va_args 我们知道，传统的处理可变参数的方法是 va_args，但是它无法知道传入了多少参数，而要像 POSIX printf 那样，解析 format 参数，然后一个一个去取。
所以问题的关键是，如何获取参数的个数？一个思路是宏，尝试用宏的魔法来计算出参数个数，这个方法可能是可以的，但是没有深究。另一个思路是利用 ABI 的特点，例如 i386 上参数是通过栈传递的，那或许可以在栈上找到所有的 int，但是问题是无法确认参数在哪里结束。
__builtin_va_arg_pack_len 今天，另一位群友发了一个链接：https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls，讲述了 GCC 中一些特别的 builtin 函数，用于函数调用相关的魔法，其中一段描述吸引了我的眼球：
Built-in Function: int __builtin_va_arg_pack_len () This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using __attribute__ ((__always_inline__)) or __attribute__ ((__gnu_inline__)) extern inline functions.
                    </p>
                    <p class="article-more-link">
                        <a href="/programming/2023/04/14/counting-arguments/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/c">c
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/printf">printf
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gcc">gcc
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/builtin">builtin
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/system/2023/04/10/sco6/">SCO OpenServer 6.0.0 虚拟机安装</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/system/2023/04/10/sco6/" class="article-date">
                        <time datetime='2023-04-10T20:21:00.000&#43;08:00' itemprop="datePublished">2023-04-10</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/system/2023/04/10/sco6/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    安装过程 首先从 https://www.sco.com/support/update/download/product.php?pfid=12&amp;prid=20 下载 SCO OpenServer 的安装 ISO。尝试过用 QEMU 启动，但是会卡在无法读取硬盘的错误上。
最后使用 VirtualBox 7.0.6 成功启动，注意创建虚拟机的时候不要给太多内存，例如 4GB 就起不来，2GB 可以。硬盘我也只给了 4GB 的空间。
安装过程中会询问 License number 和 License code，可以选择使用 Evaluation License，或者使用下面参考文档中提供的 License。按照流程一直走就可以了。如果重启出现无法 mount root 的问题，就 poweroff 再开机。
参考文档 本博客参考了以下文档中的命令：
https://virtuallyfun.com/2020/11/21/fun-with-openserver-6-and-mergepro/ 
                    </p>
                    <p class="article-more-link">
                        <a href="/system/2023/04/10/sco6/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sco">sco
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unixware">unixware
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unix">unix
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/system/2023/04/10/unixware7/">UnixWare 7.1.4 虚拟机安装</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/system/2023/04/10/unixware7/" class="article-date">
                        <time datetime='2023-04-10T19:11:00.000&#43;08:00' itemprop="datePublished">2023-04-10</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/system/2023/04/10/unixware7/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    安装过程 在 https://www.sco.com/support/update/download/product.php?pfid=1&amp;prid=6 可以看到 UnixWare 7.1.4 的相关下载，其中首先要下载 UnixWare 的安装 ISO：https://www.sco.com/support/update/download/release.php?rid=346，尝试过用 QEMU 启动，会遇到找不到 CD-ROM 的问题，虽然通过设置 ATAPI_DMA_DISABLE=YES 解决了，但是又遇到了找不到硬盘的问题。
最后换成了 VirtualBox 7.0.6。用 VirtualBox 创建虚拟机的时候，不要给太多内存，4GB 就会无法启动，2GB 可以，硬盘也不要给太多，4GB 就足够。
剩下就是按照安装界面一路默认即可，License 可以选择 Defer，使用 Evaluation License。
关机以后，修改启动顺序，把硬盘放到 CD 前，然后启动，就可以进入系统了。如果重启出现无法 mount root 的问题，就 poweroff 再开机。
参考文档 本博客参考了以下文档中的命令：
https://virtuallyfun.com/2018/01/31/revisiting-a-unixware-7-1-1-install-on-qemu-kvm/ 
                    </p>
                    <p class="article-more-link">
                        <a href="/system/2023/04/10/unixware7/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unixware">unixware
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unix">unix
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/system/2023/04/09/sco5/">SCO OpenServer 5.0.7 虚拟机安装</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/system/2023/04/09/sco5/" class="article-date">
                        <time datetime='2023-04-09T23:03:00.000&#43;08:00' itemprop="datePublished">2023-04-09</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/system/2023/04/09/sco5/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    安装过程 首先从 https://www.sco.com/support/update/download/release.php?rid=218 下载 SCO OpenServer 的安装 ISO 和从 https://www.sco.com/support/update/download/release.php?rid=187 下载 Supplement CD 5 ISO，然后用 QEMU 启动，这次需要用图形界面：
qemu-system-i386 -accel kvm -m 16384 -serial mon:stdio -drive file=sco-hdd.qcow2,if=ide -cdrom ../../ISOs/OpenServer-5.0.7Hw-10Jun05_1800.iso 安装过程中会询问 License number 和 License code，按照 https://virtuallyfun.com/2020/11/03/fun-with-openserver-and-merge/ 进行输入。
安装的时候，在 hard disk setup 那一步，记得关掉 bad tracking，否则会把整个盘扫一遍，我一开始建了 20GB 的 qcow2，结果这一步跑了一晚上，而且把 qcow2 撑满了。
安装后，重新启动，这次打开网络，同时挂载 Supplement CD 5 ISO：
qemu-system-i386 -accel kvm -m 16384 -serial chardev:mouse -drive file=sco-hdd.qcow2,if=ide -cdrom osr507suppcd5.iso -net nic -net tap,script=no,ifname=tap0 -chardev msmouse,id=mouse 启动以后，运行 custom 命令，然后从 CD-ROM 安装 Graphics and NIC Drivers。我尝试了安装 Maintenance Pack 5，但是启动以后会找不到硬盘，只好恢复之前的 qcow2 备份。可能是缺少了运行 /etc/conf/cf.
                    </p>
                    <p class="article-more-link">
                        <a href="/system/2023/04/09/sco5/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sco">sco
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unixware">unixware
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unix">unix
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/system/2023/04/09/aix/">AIX 7.2 虚拟机安装</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/system/2023/04/09/aix/" class="article-date">
                        <time datetime='2023-04-09T12:47:00.000&#43;08:00' itemprop="datePublished">2023-04-09</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/system/2023/04/09/aix/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    安装过程 宿主机环境是 Debian bookworm，不需要像其他教程那样自己编译 qemu，直接 apt install 即可。
通过 google 可以搜索到 AIX 7.2 的 ISO，下载第一个 ISO 到本地，然后在 QEMU 中启动安装镜像：
qemu-img create -f qcow2 aix-hdd.qcow2 20G qemu-system-ppc64 -cpu POWER8 -machine pseries -m 16384 -serial mon:stdio -drive file=aix-hdd.qcow2,if=none,id=drive-virtio-disk0 -device virtio-scsi-pci,id=scsi -device scsi-hd,drive=drive-virtio-disk0 -cdrom aix_7200-04-02-2027_1of2_072020.iso -prom-env boot-command=&#39;boot cdrom:\ppc\chrp\bootfile.exe&#39; -display none 进去以后，耐心等待，直到进入安装界面，按照提示进行安装，建议安装上 SSH Server，关掉图形界面，这样安装会比较快。安装需要几十分钟，安装完成后会进入 bootloop，关掉 QEMU。接着，准备好网络：
sudo ip tuntap add tap0 mode tap sudo ip link set tap0 up sudo ip a add 10.0.2.15/24 dev tap0 再启动虚拟机，注意启动选项修改了，并且多了网络的配置：
                    </p>
                    <p class="article-more-link">
                        <a href="/system/2023/04/09/aix/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/aix">aix
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/unix">unix
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2023/04/07/ram-read-write-collision/">RAM 读写冲突</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2023/04/07/ram-read-write-collision/" class="article-date">
                        <time datetime='2023-04-07T00:48:00.000&#43;08:00' itemprop="datePublished">2023-04-07</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2023/04/07/ram-read-write-collision/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 在 FPGA 或者 ASIC 中，通常都需要使用 RAM，通过读口、写口或者读写口来进行访问。常见的配置有单读写口（1RW），一读一写（1R1W）等等，读口通常有 1 个周期的延时。那么，如果在同一个周期内，读口和写口访问了同一个地址，会发生什么呢？可能会想到几种情况：
读和写都失败，读出的数据未定义，数据没写进去 数据写进去了，读出的数据未定义 数据写进去了，读出了写之前的旧数据 数据写进去了，读出了同一个周期写入的新数据 下面以具体的例子来看看，实际情况是什么样子。
Xilinx FPGA 首先测试的是 Xilinx FPGA 上的 RAM，测试的对象是 XPM，统一设置读延迟为一个周期，使用 Vivado 仿真。
一读一写 首先测试一读一写，也就是 xpm_memory_sdpram 模块。模块支持三种模式：NO_CHANGE（默认值）、READ_FIRST 和 WRITE_FIRST，因此我例化了三份，输入一样的信号，设置为三种不同的模式，然后比较输出结果。为了简化，读写使用一个时钟。下面是测试的波形：
图中第一个周期向地址 0 写入了 1111，然后第三个周期同时读写地址 0 的数据，此时 NO_CHANGE 和 WRITE_FIRST 两种模式中，写入成功，读取失败；READ_FIRST 模式读取成功，并且读取的是写入之前的数据。第四个周期时，读写没有出现冲突，三种模式都可以读出写入的新数据。
这有些出乎我的意料：之前在很多地方用过 XPM，但是都没考虑过读写地址相同的情况，而且默认设置（NO_CHANGE）下，输出结果是不确定的。实际上这个行为在 PG058 Block Memory Generator 里面提到了：
Synchronous Write-Read Collisions: A synchronous Write-Read collision might occur if a port attempts to Write a memory location and the other port reads the same location.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2023/04/07/ram-read-write-collision/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sram">sram
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/collision">collision
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/readunderwrite">readunderwrite
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/xpm">xpm
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/xilinx">xilinx
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/bram">bram
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2023/04/04/firtool/">firtool 尝试</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2023/04/04/firtool/" class="article-date">
                        <time datetime='2023-04-04T20:33:00.000&#43;08:00' itemprop="datePublished">2023-04-04</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2023/04/04/firtool/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 Chisel 3.6 很快就要发布了（目前最新版本是 3.6.0-RC2），这个大版本的主要更新内容就是引入了 CIRCT 的 firtool 作为 FIRRTL 到 Verilog 的转换流程：
The primary change in Chisel v3.6.0 is the transition from the Scala FIRRTL Compiler to the new MLIR FIRRTL Compiler. This will have a minimal impact on typical Chisel user APIs but a large impact on custom compiler flows. For more information, please see the ROADMAP. 因此提前测试一下 firtool，看看其和 Scala FIRRTL Compiler 有哪些区别，是否有更好的输出。
使用 firtool 使用 firtool 有两种方法：
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2023/04/04/firtool/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/chisel">chisel
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/verilog">verilog
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/hdl">hdl
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/firtool">firtool
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/circt">circt
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2023/03/23/core-cosim/">单核处理器的协同仿真</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2023/03/23/core-cosim/" class="article-date">
                        <time datetime='2023-03-23T11:18:00.000&#43;08:00' itemprop="datePublished">2023-03-23</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2023/03/23/core-cosim/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 今年的龙芯杯又开始报名了，我来写一篇关于协同仿真（cosim）的博客蹭蹭热度。下面的内容参考了一些已有的协同仿真的框架，例如 ibex co-sim 和 OpenXiangShan/difftest。
协同仿真 RTL 层次的协同仿真可以做不同层次的，这里讨论的是指令提交层次，具体来讲，就是把 CPU 和一个模拟器放在一起协同仿真，检查每条指令执行完以后的状态是否一致。基于代码样例的测试虽然可以覆盖很多情况，但是如果出了错误，报错的地方不一定是出现问题的地方，有些时候就需要往回找很久，才能找到刚出现问题的地方。软件上，大家经常苦于内存错误，经常找不到刚出现溢出的地方，所以要用 valgrind 或者 asan 等工具来直接定位第一次出错的地方。硬件上也是类似，为了精确定位到出错的波形，可以用 cosim。
cosim 是怎么工作的呢？模拟器是软件实现的，它原子地执行一条条指令，同时记录下当前的状态，例如寄存器的取值、内存的状态等等。如果可以让 CPU 和模拟器锁步运行，也就是 CPU 执行一条指令，模拟器执行一条指令，然后比对状态，一旦出现不一致，就直接报错。但实际上 CPU 可能会更加复杂，因为它指令的执行拆分成了很多部分，需要针对流水线进行一些修改，使得它可以生成一个匹配模拟器的原子的执行流。
整体的工作流程如下：
选择一个模拟器，自己写或者使用一个现成的。考虑到模拟器实现的功能和 CPU 不一定一致，有时候需要修改模拟器的源码，所以可以考虑使用一些现成的开源软件，如果是为了 cosim 设计的就更好了。 找到模拟器的单步执行接口，并且让模拟器可以把内部状态暴露出来。这一步可能需要修改源代码。 修改 RTL，把指令的提交信息、寄存器堆的内容通过一些方法传递出来。 修改仿真顶层，每当指令提交的时候，单步执行模拟器，然后比对双方的状态。 模拟器 选择模拟器，要根据你所实现的指令集来选择。下面以 Spike 为例，用来和 RISC-V CPU 进行协同仿真。spike 实现了比较完整的 RISC-V 指令集，并且以库的形式提供了它的 API，但还需要一些修改，让它更加适合协同仿真。这一部分参考了 ibex co-sim的文档。
首先，spike 提供了 step 函数，就是我们想要的单步执行。但是，spike 的 step 在遇到异常或者中断的时候也会返回，但实际上在处理器一侧，通常异常是单独处理的，所以这时候就要修改 spike 的 step 函数，如果遇到异常了，继续执行，直到执行了一条指令为止。与此同时，spike 没有记录最后一次执行的指令的 pc，只记录了下一个 PC，那么在发生异常的时候，就不会记录异常处理的第一条指令的 PC，这里也要进行针对性的修改。
state.last_inst_pc = pc; pc = execute_insn_logged(this, pc, fetch); advance_pc(); 做了这些修改以后，就足够在 cosim 中运行一些简单的程序了。
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2023/03/23/core-cosim/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/riscv">riscv
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cpu">cpu
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/spike">spike
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cosim">cosim
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/simulation">simulation
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/verilator">verilator
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        

        

<nav id="page-nav">
    
    
    
    <span class="page-number current">1</span>
    
    
    
    <a href="/page/2/">2</a>
    
    
    
    <a href="/page/3/">3</a>
    
    
    
    <a href="/page/4/">4</a>
    
    
    
    <a href="/page/5/">5</a>
    
    
    
    <a href="/page/6/">6</a>
    
    
    
    <a href="/page/7/">7</a>
    
    
    
    <a href="/page/8/">8</a>
    
    
    
    <a href="/page/9/">9</a>
    
    
    
    <a href="/page/10/">10</a>
    
    
    
    <a href="/page/11/">11</a>
    
    
    
    <a href="/page/12/">12</a>
    
    
    
    <a href="/page/13/">13</a>
    
    
    
    <a href="/page/14/">14</a>
    
    
    
    <a href="/page/15/">15</a>
    
    
    
    <a href="/page/16/">16</a>
    
    
    
    <a href="/page/17/">17</a>
    
    
    
    <a href="/page/18/">18</a>
    
    
    
    <a href="/page/19/">19</a>
    
    
    
    <a href="/page/20/">20</a>
    
    
    
    <a href="/page/21/">21</a>
    
    
    
    <a href="/page/22/">22</a>
    
    
    
    <a href="/page/23/">23</a>
    
    
    
    <a href="/page/24/">24</a>
    
    
    
    <a href="/page/25/">25</a>
    
    
    
    <a href="/page/26/">26</a>
    
    
    
    <a href="/page/27/">27</a>
    
    
    
    <a href="/page/28/">28</a>
    
    
    
    <a href="/page/29/">29</a>
    
    
    
    <a href="/page/30/">30</a>
    
    
    
    <a href="/page/31/">31</a>
    
    
    
    <a href="/page/32/">32</a>
    
    
    
    <a href="/page/33/">33</a>
    
    
    
    <a href="/page/34/">34</a>
    
    
    
    <a href="/page/35/">35</a>
    
    

    
    <a href="/page/2/" rel="next" class="extend next">Next &raquo;</a>
    
</nav>


    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2023 杰哥的{运维,编程,调板子}小笔记
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3109FRSVTT"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3109FRSVTT', { 'anonymize_ip': false });
}
</script>


    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
        <script>renderMathInElement(document.body);</script>
    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>