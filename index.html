<!DOCTYPE html>
<html>
<head>
    <title>杰哥的{运维,编程,调板子}小笔记</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="杰哥的{运维,编程,调板子}小笔记" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://jia.je/" />
    
<link href="/feed.xml" rel="alternate" type="application/rss+xml" title="杰哥的{运维,编程,调板子}小笔记" />
    <link rel="shortcut icon" href="/favicon.ico">

    <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/style.css">
    
    <script src="/js/wavedrom/default.js" type="text/javascript"></script>
    <script src="/js/wavedrom/wavedrom.min.js" type="text/javascript" /></script>

    <meta name="generator" content="Hugo 0.99.1" />
</head>

<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="/">杰哥的{运维,编程,调板子}小笔记</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">关于</a>
                
                <a class="main-nav-link" href="/category/">分类</a>
                
                <a class="main-nav-link" href="/open-source-contributions/">开源</a>
                
                <a class="main-nav-link" href="/tags/">标签</a>
                
                <a class="main-nav-link" href="/series/">系列</a>
                
                <a class="main-nav-link" href="/feed.xml">订阅</a>
                
                <a class="main-nav-link" href="/projects/readme/">项目</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2022/07/06/install-nvidia-cuda/">NVIDIA 驱动和 CUDA 安装速查</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2022/07/06/install-nvidia-cuda/" class="article-date">
                        <time datetime='2022-07-06T11:42:00.000&#43;08:00' itemprop="datePublished">2022-07-06</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2022/07/06/install-nvidia-cuda/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在 Ubuntu 上配置 NVIDIA 驱动和 CUDA 环境的次数比较多，在此总结一下整个流程，作为教程供大家学习。
配置 NVIDIA APT 源 Ubuntu 源有自带的 NVIDIA 驱动版本，但这里我们要使用 NVIDIA 的 APT 源。首先，我们要访问 https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=20.04&amp;target_type=deb_network，在网页中选择我们的系统，例如：
 Operating System: Linux Architecture: x86_64 Distribution: Ubuntu Version: 20.04 Installer Type: deb (network)  此时，下面就会显示一些命令，复制下来执行：
 wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-ubuntu2004.pin sudo mv cuda-ubuntu2004.pin /etc/apt/preferences.d/cuda-repository-pin-600 sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/3bf863cc.pub sudo add-apt-repository &#34;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/ /&#34; sudo apt-get update 最后一步的 sudo apt-get -y install cuda 可以不着急安装，我们在后面再来讨论 CUDA 版本的问题。
NVIDIA 驱动 配置好源以后，接下来，我们就要安装 NVIDIA 驱动了。首先，我们要选取一个 NVIDIA 版本，选择的标准如下：
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2022/07/06/install-nvidia-cuda/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/nvidia">nvidia
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cuda">cuda
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2022/07/02/connectx-4-switch-to-ethernet/">切换 ConnectX-4 为以太网模式</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2022/07/02/connectx-4-switch-to-ethernet/" class="article-date">
                        <time datetime='2022-07-02T20:26:00.000&#43;08:00' itemprop="datePublished">2022-07-02</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2022/07/02/connectx-4-switch-to-ethernet/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在给机房配置网络，遇到一个需求，就是想要把 ConnectX-4 当成以太网卡用，它既支持 Infiniband，又支持 Ethernet，只不过默认是 Infiniband 模式，所以需要用 mlxconfig 工具来做这个切换。
切换方法 在 Using mlxconfig 文档中，写了如何切换网卡为 Infiniband 模式：
$ mlxconfig -d /dev/mst/mt4103_pci_cr0 set LINK_TYPE_P1=1 LINK_TYPE_P2=1  Device #1: ---------- Device type: ConnectX3Pro PCI device: /dev/mst/mt4103_pci_cr0 Configurations: Next Boot New  LINK_TYPE_P1 ETH(2) IB(1)  LINK_TYPE_P2 ETH(2) IB(1)  Apply new Configuration? ? (y/n) [n] : y Applying... Done! -I- Please reboot machine to load new configurations. 那么，我们只需要反其道而行之，设置模式为 ETH(2) 即可。
MST 安装 要使用 mlxconfig，就需要安装 MFT(Mellanox Firmware Tools)。我们用的是 Debian bookworm，于是要下载 DEB：
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2022/07/02/connectx-4-switch-to-ethernet/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/linux">linux
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/mellanox">mellanox
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/connectx4">connectx4
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/ethernet">ethernet
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/infiniband">infiniband
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/mst">mst
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/mft">mft
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2022/07/01/rsyslog-remote/">rsyslog 收集远程日志</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2022/07/01/rsyslog-remote/" class="article-date">
                        <time datetime='2022-07-01T20:14:00.000&#43;08:00' itemprop="datePublished">2022-07-01</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2022/07/01/rsyslog-remote/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在运维的时候发现网络设备（如交换机）有一个远程发送日志的功能，即可以通过 syslog udp 协议发送日志到指定的服务器。为此，可以在服务器上运行 rsyslog 并收集日志。
rsyslog 配置 默认的 rsyslog 配置是收集系统本地的配置，因此我们需要编写一个 rsyslog 配置，用于收集远程的日志。
首先复制 /etc/rsyslog.conf 到 /etc/rsyslog-remote.conf，然后修改：
 注释掉 imuxsock 和 imklog 相关的 module 加载 去掉 imudp 和 imtcp 相关的注释，这样就会监听在相应的端口上 修改 $WorkDirectory，例如 $WorkDirectory /var/spool/rsyslog-remote，防止与已有的 rsyslog 冲突 注释 $IncludeConfig，防止引入了不必要的配置 注释所有已有的 RULES 下面的配置 添加如下配置：  $template FromIp,&#34;/var/log/rsyslog-remote/%FROMHOST-IP%.log&#34; *.* ?FromIp 这样，就会按照来源的 IP 地址进行分类，然后都写入到 /var/log/rsyslog-remote/x.x.x.x.log 文件里。
systemd service 最后，写一个 systemd service 让它自动启动：
[Unit] ConditionPathExists=/etc/rsyslog-remote.conf Description=Remote Syslog Service  [Service] Type=simple PIDFile=/var/run/rsyslogd-remote.pid ExecStart=/usr/sbin/rsyslogd -n -f /etc/rsyslog-remote.
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2022/07/01/rsyslog-remote/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/linux">linux
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/rsyslog">rsyslog
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/remote">remote
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/logging">logging
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/06/19/wishbone/">「教学」Wishbone 总线协议</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/06/19/wishbone/" class="article-date">
                        <time datetime='2022-06-19T17:05:00.000&#43;08:00' itemprop="datePublished">2022-06-19</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/06/19/wishbone/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在研究如何把 Wishbone 总线协议引入计算机组成原理课程，因此趁此机会学习了一下 Wishbone 的协议。
总线 总线是什么？总线通常用于连接 CPU 和外设，为了更好的兼容性和可复用性，会想到能否设计一个统一的协议，其中 CPU 实现的是发起请求的一方（又称为 master），外设实现的是接收请求的一方（又称为 slave），那么如果要添加外设、或者替换 CPU 实现，都会变得比较简单，减少了许多适配的工作量。
那么，我们来思考一下，一个总线协议需要包括哪些内容？对于 CPU 来说，程序会读写内存，读写内存就需要以下几个信号传输到内存：
 地址（addr）：例如 32 位处理器就是 32 位地址，或者按照内存的大小计算地址线的宽度 数据（w_data 和 r_data）：分别是写数据和读数据，宽度通常为 32 位 或 64 位，也就是一个时钟周期可以传输的数据量 读还是写（we）：高表示写，低表示读 字节有效（be）：例如为了实现单字节写，虽然 w_data 可能是 32 位宽，但是实际写入的是其中的一个字节  除了请求的内容以外，为了表示 CPU 想要发送请求，还需要添加 valid 信号：高表示发送请求，低表示不发送请求。很多时候，外设的速度比较慢，可能无法保证每个周期都可以处理请求，因此外设可以提供一个 ready 信号：当 valid=1 &amp;&amp; ready=1 的时候，发送并处理请求；当 valid=1 &amp;&amp; ready=0 的时候，表示外设还没有准备好，此时 CPU 需要一直保持 valid=1 不变，等到外设准备好后，valid=1 &amp;&amp; ready=1 请求生效。
简单总结一下上面的需求，可以得到 master 和 slave 端分别的信号列表。这次，我们在命名的时候用 _o 表示输出、_i 表示输入，可以得到 master 端（CPU 端）的信号：
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/06/19/wishbone/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/wishbone">wishbone
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/bus">bus
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/teaching">teaching
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2022/06/07/nix-cookbook/">Nix Cookbook</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2022/06/07/nix-cookbook/" class="article-date">
                        <time datetime='2022-06-07T22:29:00.000&#43;08:00' itemprop="datePublished">2022-06-07</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2022/06/07/nix-cookbook/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在尝试 NixOS 和在 macOS 上跑 Nix，下面记录一些我在使用过程中遇到的一些小问题和解决思路。
NixOS 全局配置 NixOS 的全局配置路径：/etc/nixos/configuration.nix 和 /etc/nixos/hardware-configuration.nix
应用更新后的全局配置：
nixos-rebuild switch # or nixos-rebuild switch --upgrade 应用 Flakes 配置文件并显示变化：
#!/usr/bin/env python3 import os  user = os.getenv(&#34;USER&#34;) home = f&#34;/nix/var/nix/profiles/&#34; old = home + os.readlink(f&#34;{home}system&#34;) os.system(&#34;sudo nixos-rebuild switch --flake .&#34;) new = home + os.readlink(f&#34;{home}system&#34;) os.system(f&#34;nix store diff-closures {old}{new}&#34;) 更新大版本 如果要更新 NixOS 21.11 到 22.05:
nix-channel --list nix-channel --add https://nixos.org/channels/nixos-22.05 nixos nixos-rebuild switch --upgrade 可以考虑改或者不改 /etc/nixos/configuration.
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2022/06/07/nix-cookbook/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/nix">nix
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/nixos">nixos
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cookbook">cookbook
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2022/05/31/qemu-rv64-in-libvirt/">在 libvirt 中运行 RISC-V 虚拟机</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2022/05/31/qemu-rv64-in-libvirt/" class="article-date">
                        <time datetime='2022-05-31T09:22:00.000&#43;08:00' itemprop="datePublished">2022-05-31</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2022/05/31/qemu-rv64-in-libvirt/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 我在 libvirt 中跑了几个 KVM 加速的虚拟机，然后突发奇想，既然 libvirt 背后是 qemu，然后 qemu 是支持跨指令集的，那是否可以让 libvirt 来运行 RISC-V 架构的虚拟机？经过一番搜索，发现可以跑 ARM：How To: Running Fedora-ARM under QEMU，既然如此，我们也可以试试用 libvirt 来运行 RV64 虚拟机。
准备 rootfs 第一步是根据 Debian 的文档 Creating a riscv64 chroot 来创建 rootfs，然后再用 virt-make-fs 来打包。
首先是用 mmdebstrap 来生成一个 chroot：
$ sudo mkdir -p /tmp/riscv64-chroot $ sudo apt install mmdebstrap qemu-user-static binfmt-support debian-ports-archive-keyring $ sudo mmdebstrap --architectures=riscv64 --include=&#34;debian-ports-archive-keyring&#34; sid /tmp/riscv64-chroot &#34;deb http://deb.debian.org/debian-ports sid main&#34; &#34;deb http://deb.debian.org/debian-ports unreleased main&#34; 进入 chroot 以后，进行一些配置：
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2022/05/31/qemu-rv64-in-libvirt/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/qemu">qemu
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/libvirt">libvirt
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/virtmanager">virtmanager
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/debian">debian
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/riscv">riscv
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/rv64">rv64
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/05/19/async-sram-timing/">「教学」异步 SRAM 时序</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/05/19/async-sram-timing/" class="article-date">
                        <time datetime='2022-05-19T08:40:00.000&#43;08:00' itemprop="datePublished">2022-05-19</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/05/19/async-sram-timing/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 在一些场合里，我们会使用异步的（即没有时钟信号的）外部 SRAM 来存储数据，而我们经常使用的很多外部接口都是同步接口（即有时钟信号的接口），比如 SPI 和 I2C 等等，UART 虽然是异步，但是它速度很低，不怎么需要考虑时序的问题。所以在 FPGA 上编写一个正确的异步 SRAM 控制器是具有一定的挑战的。
寄存器时序 考虑到读者可能已经不记得寄存器的时序了，这里首先来复习一下 setup 和 hold 的概念。如果你已经比较熟悉了，可以直接阅读下一节。
寄存器在时钟的上升沿（下图的 a）进行采样，为了保证采样的稳定性，输入引脚 D 需要在时钟上升沿之前 \(t_{su}\) 的时刻（下图的 b）到时钟上升沿之后 \(t_h\) 的时刻（下图的 c）保持稳定，输出引脚 Q 会在时钟上升沿之后 \(t_{cko}\) 的时刻（下图的 d）变化：
{ signal: [ { name: "C", wave: "p.", period: 4, node: ".a"}, { name: "D", wave: "x..3.x", phase: 0.2, node: "...b.c"}, { name: "Q", wave: "x...3.", node: "....d"} ] }  接口 首先我们来看看异步 SRAM 的接口。下文中，采用 IS61WV102416BLL-10TLI 和 AS7C34098A-10TCN 作为例子：
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/05/19/async-sram-timing/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sram">sram
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/timing">timing
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/teaching">teaching
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/05/16/ace/">「教学」ACE 缓存一致性协议</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/05/16/ace/" class="article-date">
                        <time datetime='2022-05-16T00:34:00.000&#43;08:00' itemprop="datePublished">2022-05-16</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/05/16/ace/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近几天分析了 TileLink 的缓存一致性协议部分内容，见TileLink 总线协议分析，趁此机会研究一下之前尝试过研究，但是因为缺少一些基础知识而弃坑的 ACE 协议分析。
下面主要参考了 IHI0022E 的版本，也就是 AXI4 对应的 ACE 版本。
回顾 首先回顾一下一个缓存一致性协议需要支持哪些操作。对于较上一级 Cache 来说，它需要这么几件事情：
 读或写 miss 的时候，需要请求这个缓存行的数据，并且更新自己的状态，比如读取到 Shared，写入到 Modified 等。 写入一个 valid &amp;&amp; !dirty 的缓存行的时候，需要升级自己的状态，比如从 Shared 到 Modified。 需要 evict 一个 valid &amp;&amp; dirty 的缓存行的时候，需要把 dirty 数据写回，并且降级自己的状态，比如 Modified -&gt; Shared/Invalid。如果需要 evict 一个 valid &amp;&amp; !dirty 的缓存行，可以选择通知，也可以选择不通知下一级。 收到 snoop 请求的时候，需要返回当前的缓存数据，并且更新状态。 需要一个方法来通知下一级 Cache/Interconnect，告诉它第一和第二步完成了。  如果之前看过我的 TileLink 分析，那么上面的这些操作对应到 TileLink 就是：
 读或写 miss 的时候，需要请求这个缓存行的数据（发送 AcquireBlock，等待 GrantData），并且更新自己的状态，比如读取到 Shared，写入到 Modified 等。 写入一个 valid &amp;&amp; !
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/05/16/ace/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/axi">axi
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/bus">bus
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cache">cache
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/coherence">coherence
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/teaching">teaching
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/05/13/rocket-chip-custom-debug/">向 Rocket Chip 添加自定义调试信号</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/05/13/rocket-chip-custom-debug/" class="article-date">
                        <time datetime='2022-05-13T08:35:00.000&#43;08:00' itemprop="datePublished">2022-05-13</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/05/13/rocket-chip-custom-debug/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在尝试把核心作为一个 Tile 加到 Rocket System 中，所以想要把核心之前自定义的调试信号接到顶层上去。Rocket System 自带的支持是 trace，也就是输出每个周期 retire 的指令信息，但和自定义的不大一样，所以研究了一下怎么添加自定义的调试信号，并且连接到顶层。
分析 Trace 信号连接方式 首先，观察 Rocket Chip 自己使用的 Trace 信号是如何连接到顶层的。在顶层上，可以找到使用的是 testchipip.CanHaveTraceIO:
trait CanHaveTraceIO { this: HasTiles =&gt;  val module: CanHaveTraceIOModuleImp   // Bind all the trace nodes to a BB; we&#39;ll use this to generate the IO in the imp  val traceNexus = BundleBridgeNexusNode[Vec[TracedInstruction]]()  val tileTraceNodes = tiles.flatMap {  case ext_tile: WithExtendedTraceport =&gt; None  case tile =&gt; Some(tile)  }.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/05/13/rocket-chip-custom-debug/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/rocketchip">rocketchip
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/riscv">riscv
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/debug">debug
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/05/10/memory-authentication/">「教学」内存认证算法</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/05/10/memory-authentication/" class="article-date">
                        <time datetime='2022-05-10T20:28:00.000&#43;08:00' itemprop="datePublished">2022-05-10</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/05/10/memory-authentication/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 之前 @松 给我讲过一些内存认证（Memory Authentication）算法的内容，受益匪浅，刚好今天某硬件群里又讨论到了这个话题，于是趁此机会再学习和整理一下相关的知识。
内存认证计算的背景是可信计算，比如要做一些涉及重要数据的处理，从软件上，希望即使系统被攻击非法进入了，也可以保证重要信息不会泄漏；从硬件上，希望即使系统可以被攻击者进行一些物理的操作（比如导出或者修改内存等等），也可以保证攻击者无法读取或者篡改数据。
下面的内容主要参考了 Hardware Mechanisms for Memory Authentication: A Survey of Existing Techniques and Engines 这篇 2009 年的文章。
威胁模型 作为一个防御机制，首先要确定攻击方的能力。一个常见的威胁模型是认为，攻击者具有物理的控制，可以任意操控内存中的数据，但是无法读取或者修改 CPU 内部的数据。也就是说，只有 CPU 芯片内的数据是可信的，离开了芯片都是攻击者掌控的范围。一个简单的想法是让内存中保存的数据是加密的，那么怎样攻击者可以如何攻击加密的数据？下面是几个典型的攻击方法：
 Spoofing attack：把内存数据改成任意攻击者控制的数据；这种攻击可以通过签名来解决 Splicing or relocation attack：把某一段内存数据挪到另一部分，这样数据的签名依然是正确的；所以计算签名时需要把地址考虑进来，这样地址变了，验证签名就会失败 Replay attack：如果同一个地址的内存发生了改变，攻击者可以把旧的内存数据再写进去，这样签名和地址都是正确的；为了防止重放攻击，还需要引入计数器或者随机 nonce  Authentication Primitives 为了防御上面几种攻击方法，上面提到的文章里提到了如下的思路：
一是 Hash Function，把内存分为很多个块，每一块计算一个密码学 Hash 保存在片内，那么读取数据的时候，把整块数据读取进来，计算一次 Hash，和片内保存的结果进行比对；写入数据的时候，重新计算一次修改后数据的 Hash，更新到片内的存储。这个方法的缺点是没有加密，攻击者可以看到内容，只不过一修改就会被 CPU 发现（除非 Hash 冲突），并且存储代价很大：比如 512-bit 的块，每一块计算一个 128-bit 的 Hash，那就浪费了 25% 的空间，而片内空间是十分宝贵的。
二是 MAC Function，也就是密码学的消息验证码，它需要一个 Key，保存在片内；由于攻击者不知道密码，根据 MAC 的性质，攻击者无法篡改数据，也无法伪造 MAC，所以可以直接把计算出来的 MAC 也保存到内存里。为了防御重放攻击，需要引入随机的 nonce，并且把 nonce 保存在片内，比如每 512-bit 的数据，保存 64-bit 的 nonce，这样片内需要保存 12.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/05/10/memory-authentication/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/memory">memory
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/bus">bus
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/dram">dram
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/auth">auth
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/teaching">teaching
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        

        

<nav id="page-nav">
    
    
    
    <span class="page-number current">1</span>
    
    
    
    <a href="/page/2/">2</a>
    
    
    
    <a href="/page/3/">3</a>
    
    
    
    <a href="/page/4/">4</a>
    
    
    
    <a href="/page/5/">5</a>
    
    
    
    <a href="/page/6/">6</a>
    
    
    
    <a href="/page/7/">7</a>
    
    
    
    <a href="/page/8/">8</a>
    
    
    
    <a href="/page/9/">9</a>
    
    
    
    <a href="/page/10/">10</a>
    
    
    
    <a href="/page/11/">11</a>
    
    
    
    <a href="/page/12/">12</a>
    
    
    
    <a href="/page/13/">13</a>
    
    
    
    <a href="/page/14/">14</a>
    
    
    
    <a href="/page/15/">15</a>
    
    
    
    <a href="/page/16/">16</a>
    
    
    
    <a href="/page/17/">17</a>
    
    
    
    <a href="/page/18/">18</a>
    
    
    
    <a href="/page/19/">19</a>
    
    
    
    <a href="/page/20/">20</a>
    
    
    
    <a href="/page/21/">21</a>
    
    
    
    <a href="/page/22/">22</a>
    
    
    
    <a href="/page/23/">23</a>
    
    
    
    <a href="/page/24/">24</a>
    
    
    
    <a href="/page/25/">25</a>
    
    
    
    <a href="/page/26/">26</a>
    
    
    
    <a href="/page/27/">27</a>
    
    
    
    <a href="/page/28/">28</a>
    
    
    
    <a href="/page/29/">29</a>
    
    
    
    <a href="/page/30/">30</a>
    
    
    
    <a href="/page/31/">31</a>
    
    

    
    <a href="/page/2/" rel="next" class="extend next">Next &raquo;</a>
    
</nav>


    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2022 杰哥的{运维,编程,调板子}小笔记
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3109FRSVTT"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3109FRSVTT', { 'anonymize_ip': false });
}
</script>


    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
        <script>renderMathInElement(document.body);</script>
    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>