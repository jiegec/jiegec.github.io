<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>杰哥的{运维,编程,调板子}小笔记</title><description>杰哥的{运维,编程,调板子}小笔记</description><link>https://jia.je/</link><atom:link href="https://jia.je/feed_rss_updated.xml" rel="self" type="application/rss+xml" /><language>en-None</language> <pubDate>Fri, 14 Jul 2023 15:13:45 -0000</pubDate> <lastBuildDate>Fri, 14 Jul 2023 15:13:45 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.7.0</generator> <item> <title>把博客生成器从 Hugo 迁移到 Mkdocs</title> <category>meta</category> <category>site</category> <description>&lt;h1&gt;把博客生成器从 Hugo 迁移到 Mkdocs&lt;/h1&gt;&lt;p&gt;距离上一次 &lt;a href=&#34;migrate-from-jekyll-to-hugo.md&#34;&gt;Jekyll 迁移到 Hugo&lt;/a&gt; 已经过去了四年，这次正好 mkdocs-material 发了新的 beta 版本，加入了对博客的支持，所以就当小白鼠，把博客迁移到了 Mkdocs + Mkdocs-Material。&lt;/p&gt;&lt;p&gt;这次迁移比较顺利，除了 tag 和 category 少了一些页面以外，原来的文章的链接都是正常的。为什么要迁移呢，主要是最近写各种文档，Mkdocs 用的比较多，但是 Mkdocs 的 Markdown 很多地方和 Hugo 不太一样，下面列一些最难以忍受的 Hugo 的问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数学公式：Hugo 的 &lt;code&gt;\&lt;/code&gt; 需要转义，导致很多地方写数学公式都很麻烦，然后因为我经常要在 Hugo 和 Mkdocs 之间复制 Markdown，此时就需要很多手动工作。&lt;/li&gt;&lt;li&gt;资源路径：Hugo 的资源路径默认都是绝对路径，要引用其他文章的话，要么用啰嗦的 relref，要么就写绝对路径，比较头疼。Mkdocs 就很好，自动检测，帮我计算出实际的地址。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;迁移的时候有很多细节上的不同，不过基本靠 VSCode 的正则表达式替换解决了。&lt;/p&gt;&lt;p&gt;不过，Mkdocs 又出现了 Jekyll 的老问题，就是性能比较差。当然了，不一定是 Mkdocs 本身的问题，也可能是 Mkdocs-Material 加各种插件的问题，目前还有待观察。无论如何，Python 调起来总归是比 Ruby 要容易。希望不要在未来的某一天，由从 Mkdocs 迁移回 Hugo。&lt;/p&gt;</description><link>https://jia.je/meta/2023/07/15/migrate-from-hugo-to-mkdocs/</link> <pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/meta/2023/07/15/migrate-from-hugo-to-mkdocs/</guid> </item> <item> <title>ECDSA</title> <category>crypto</category> <category>crypto</category> <category>ecc</category> <category>ecdsa</category> <description>&lt;h1&gt;ECDSA&lt;/h1&gt;&lt;p&gt;本文参考 &lt;a href=&#34;https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm&#34;&gt;ECDSA - Wikipedia&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;ECDSA 是一个基于椭圆曲线的签名算法，使用时需要确定一个椭圆曲线，以及它的 base point $G$，且 $G$ 的阶是素数 $n$。&lt;/p&gt;&lt;h2&gt;生成 key pair&lt;/h2&gt;&lt;p&gt;生成 key pair 的时候，私钥是整数 $d_A \in [1, n-1]$，那么公钥就是圆锥曲线上一点 $Q_A = d_A \times G$，这里 $\times$ 表示整数与圆锥曲线上一点的乘法。&lt;/p&gt;&lt;h2&gt;签名&lt;/h2&gt;&lt;p&gt;签名的时候，对于给定的消息 $m$，签名流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;计算哈希：$e = \mathrm{HASH}(m)$，例如用 SHA 系列的哈希算法&lt;/li&gt;&lt;li&gt;考虑到 $e$ 的位数可能比 $n$ 的位数更多，取 $e$ 的高位，使得位数和 $n$ 一致，得到的结果记为 $z$&lt;/li&gt;&lt;li&gt;生成一个密码学安全的随机数 $k \in [1, n-1]$&lt;/li&gt;&lt;li&gt;计算 $k \times G$，取它的 X 坐标为 $x_1$&lt;/li&gt;&lt;li&gt;计算 $r = x_1 \bmod n$&lt;/li&gt;&lt;li&gt;计算 $s = k^{-1}(z + r d_A) \bmod n$&lt;/li&gt;&lt;li&gt;如果 $r$ 或者 $s$ 等于 0，取新的 $k$ 再重试&lt;/li&gt;&lt;li&gt;得到的 ECDSA 签名就是 $(r, s)$ 两个数&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;验证&lt;/h2&gt;&lt;p&gt;验证签名的时候，已知 $r, s, m, Q_A$，按照下面的流程进行：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;前两步和计算签名的算法一致，求哈希和截断后得到 $z$&lt;/li&gt;&lt;li&gt;计算 $u_1 = zs^{-1} \bmod n, u_2 = rs^{-1} \bmod n$&lt;/li&gt;&lt;li&gt;计算 $u_1 \times G + u_2 \times Q_A$，取它的 X 坐标为 $x_2$&lt;/li&gt;&lt;li&gt;如果 $r \equiv x_2 \pmod n$，则签名合法&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;上面的过程忽略了一些边界情况的检查，详细版本见 Wikipedia。&lt;/p&gt;&lt;p&gt;下面进行验算：&lt;/p&gt;&lt;p&gt;\begin{align}&amp;amp; u_1 \times G + u_2 \times Q_A \\&amp;amp;= zs^{-1} \times G + rs^{-1} \times Q_A \\&amp;amp;= zs^{-1} \times G + rs^{-1}d_A \times G \\&amp;amp;= (zs^{-1} + rs^{-1}d_A) \times G \\&amp;amp;= (z+rd_A)s^{-1} \times G \\&amp;amp;= (z+rd_A)k(z+rd_A)^{-1} \times G \\&amp;amp;= k \times G\end{align}&lt;/p&gt;&lt;p&gt;等式左边的 X 坐标等于等式右边的 X 坐标，等价于 $r \equiv x_2 \pmod n$，验算没问题。&lt;/p&gt;&lt;h2&gt;公钥恢复&lt;/h2&gt;&lt;p&gt;ECDSA 支持公钥恢复算法，已知 $r, s, m$，恢复 $Q_A$。首先进行推导：&lt;/p&gt;&lt;p&gt;\begin{align}Q_A &amp;amp;= d_A \times G \\s &amp;amp;= k^{-1}(z + rd_A) \bmod n \\sk &amp;amp;= z + rd_A \bmod n \\sk \times G &amp;amp;= (z + rd_A) \times G \\rd_A \times G &amp;amp;= (z - sk) \times G \\Q_A &amp;amp;= d_A \times G = r^{-1}(z-sk) \times G \\Q_A &amp;amp;= r^{-1}(z \times G - s(k \times G))\end{align}&lt;/p&gt;&lt;p&gt;上式中 $r, s$ 已知，$z$ 可以从 $m$ 通过哈希计算得出，$k \times G$ 的 X 坐标 $x_1$ 满足 $r = x_1 \bmod n$，因此恢复过程就是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在椭圆曲线上找到 X 坐标模 $n$ 等于 $r$ 的点，这个点就是 $k \times G$&lt;/li&gt;&lt;li&gt;按照计算哈希的前两步，从 $m$ 计算出 $z$&lt;/li&gt;&lt;li&gt;按照上述公式，计算出 $Q_A$&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;但是实际上第一步没有这么简单：首先同一个 X 坐标对应椭圆曲线上的两个点，其次 $r$ 和 $x_1$ 只是同余关系，可能二者之间差了一个倍数。因此实际在 BTC 或者 ETH 里使用的时候，还额外附加了一个参数 recid，范围是 0 到 3，对应 Y 坐标是正还是负，$r$ 和 $x_1$ 之间差 0 还是 $n$：&lt;/p&gt;&lt;p&gt;&lt;code&gt;c// Source: https://github.com/ethereum/go-ethereum/blob/e1fe6bc8469c626afaa86b1dfb819737e980a574/crypto/secp256k1/libsecp256k1/src/modules/recovery/main_impl.h#L104-L112if (recid &amp;amp; 2) { if (secp256k1_fe_cmp_var(&amp;amp;fx, &amp;amp;secp256k1_ecdsa_const_p_minus_order) &amp;gt;= 0) { return 0; } secp256k1_fe_add(&amp;amp;fx, &amp;amp;secp256k1_ecdsa_const_order_as_fe);}if (!secp256k1_ge_set_xo_var(&amp;amp;x, &amp;amp;fx, recid &amp;amp; 1)) { return 0;}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&#34;https://medium.com/asecuritysite-when-bob-met-alice/crypto-magic-recovering-alices-public-key-from-an-ecdsa-signature-e7193df8df6e&#34;&gt;Crypto Magic: Recovering Alice’s Public Key From An ECDSA Signature&lt;/a&gt; 和 &lt;a href=&#34;https://medium.com/asecuritysite-when-bob-met-alice/can-we-recover-the-public-key-from-an-ecdsa-signature-7af4b56a8a0f&#34;&gt;Can We Recover The Public Key from an ECDSA Signature?&lt;/a&gt;&lt;/p&gt;</description><link>https://jia.je/crypto/2023/07/14/ecdsa/</link> <pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/crypto/2023/07/14/ecdsa/</guid> </item> <item> <title>在 Apple M1 上试用 Gentoo/Prefix</title> <category>devops</category> <category>gentoo</category> <category>gentoo-prefix</category> <category>m1</category> <category>macos</category> <description>&lt;h1&gt;在 Apple M1 上试用 Gentoo/Prefix&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;上一次折腾 Gentoo/Prefix 是&lt;a href=&#34;/devops/2017/12/27/try-gentoo-prefix-on-macos/&#34;&gt;五年多以前&lt;/a&gt;，当时还是用的 Intel Mac，最近需要探索一下在现在的 macOS 系统上用 Gentoo/Prefix 会遇到哪些问题，因此今天在 Apple M1 上重新尝试一次。&lt;/p&gt;&lt;h2&gt;安装&lt;/h2&gt;&lt;p&gt;按照&lt;a href=&#34;https://wiki.gentoo.org/wiki/Project:Prefix/Bootstrap&#34;&gt;官网&lt;/a&gt;的文档，下载脚本并运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellwget https://gitweb.gentoo.org/repo/proj/prefix.git/plain/scripts/bootstrap-prefix.shchmod +x bootstrap-prefix.sh./bootstrap-prefix.sh&lt;/code&gt;&lt;/p&gt;&lt;p&gt;按照提示输入即可。&lt;/p&gt;&lt;p&gt;编译使用了四到五个多小时，占用 3GB 的硬盘空间。成功以后进入 Gentoo Prefix：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell./startprefix&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;折腾&lt;/h2&gt;&lt;p&gt;编译并运行大概两个小时以后，遇到了编译错误：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellUndefined symbols for architecture arm64: &#34;_libintl_bindtextdomain&#34;, referenced from: __locale_bindtextdomain in _localemodule.o &#34;_libintl_dcgettext&#34;, referenced from: __locale_dcgettext in _localemodule.o &#34;_libintl_dgettext&#34;, referenced from: __locale_dgettext in _localemodule.o &#34;_libintl_gettext&#34;, referenced from: __locale_gettext in _localemodule.o &#34;_libintl_setlocale&#34;, referenced from: __locale_setlocale in _localemodule.o __locale_localeconv in _localemodule.o &#34;_libintl_textdomain&#34;, referenced from: __locale_textdomain in _localemodule.old: symbol(s) not found for architecture arm64&lt;/code&gt;&lt;/p&gt;&lt;p&gt;是在编译 python3.11.3 的时候遇到的问题，经过一番搜索，发现有一个错误信息比较相关：&lt;a href=&#34;https://bugs.gentoo.org/906507&#34;&gt;dev-lang/python-3.11.3: bootstrap-prefix.sh stage3 fails (on MacOS/Darwin)&lt;/a&gt;，也是在编译 python3.11.3 的时候出错，只不过错误信息不太一样。&lt;/p&gt;&lt;p&gt;我看到这个 bug report 时，里面说问题在新的 commit 已经修复了，但是我仔细看了一下，修复的时间正好在我跑 bootstrap 脚本后几个小时，也就是说我跑的版本是修复前的版本。于是我重新下载了最新版，重新 bootstrap，又等了两个小时，还是出现了同样的问题，说明问题并没有被解决。&lt;/p&gt;&lt;h3&gt;libintl&lt;/h3&gt;&lt;p&gt;观察错误信息，发现是 libintl 相关的符号缺失。向 @heroxbd 学习到了 libintl 的机制：它是一套 API，在 glibc 和 musl 等一些 libc 中有实现，在 gettext 中也有实现，系统里只需要有一份就行。因此在常见的 Linux 发行版里，libintl 是由 libc 提供的，此时 gettext 编译的时候就不会附带 libintl；而如果在 macOS 上，由于 macOS 的 libc 没有 libintl 的 API，所以 gettext 编译的时候就要附带 libintl。&lt;/p&gt;&lt;p&gt;例如 Homebrew 的编译脚本里，就做了这个特殊处理：&lt;/p&gt;&lt;p&gt;```shell$ brew cat gettext&lt;/p&gt;&lt;h1&gt;omitted&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;args &amp;lt;&amp;lt; if OS.mac? # Ship libintl.h. Disabled on linux as libintl.h is provided by glibc # https://gcc-help.gcc.gnu.narkive.com/CYebbZqg/cc1-undefined-reference-to-libintl-textdomain # There should never be a need to install gettext&#39;s libintl.h on # GNU/Linux systems using glibc. If you have it installed you&#39;ve borked # your system somehow. &#34;--with-included-gettext&#34;else &#34;--with-libxml2-prefix=#{Formula[&#34;libxml2&#34;].opt_prefix}&#34;end&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;omitted&lt;/h1&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;在 Gentoo 中，处理方式是这样的：把 gettext 的源码编译两份，对应两个包，一个包叫做 gettext，也就是 gettext 去掉 libintl 的部分；另一个包叫做 libintl，也就是 gettext 的 libintl 部分。两个包用同一份源码，只是编译选项不同，因此得到了不同的结果。&lt;/p&gt;&lt;p&gt;那么，接下来的问题就是，为什么会缺符号呢？比较一下 homebrew 和 gentoo 编译出来的 libintl.dylib 符号，可以发现区别：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -t /opt/homebrew/opt/gettext/lib/libintl.a | grep bindtextdomain0000000000000000 g F __TEXT,__text _libintl_bindtextdomain000000000000001c g F __TEXT,__text _bindtextdomain0000000000000000 *UND* _libintl_bindtextdomain$ objdump -t $EPREFIX/tmp/usr/lib/libintl.dylib | grep bindtextdomain0000000000009a34 l F __TEXT,__text _bindtextdomain0000000000004800 g F __TEXT,__text _libintl_bindtextdomain&lt;/code&gt;&lt;/p&gt;&lt;p&gt;可以看到，两者的区别是 visibility 从 global 变成了 local，链接的时候也出现了 warning：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ld: warning: cannot export hidden symbol _bindtextdomain from .libs/intl-compat.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;@heroxbd 给出了临时的解决方法：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ gl_cv_cc_visibility=no $EPREFIX/tmp/usr/bin/emerge -1v libintl&lt;/code&gt;&lt;/p&gt;&lt;p&gt;编译的时候强制把 &lt;code&gt;-fvisibility=hidden&lt;/code&gt; 覆盖掉，这样就不会有 visibility 的问题：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -t /Volumes/Data/gentoo/tmp/usr/lib/libintl.dylib | grep bindtextdomain0000000000009a34 g F __TEXT,__text _bindtextdomain0000000000004800 g F __TEXT,__text _libintl_bindtextdomain&lt;/code&gt;&lt;/p&gt;&lt;p&gt;此时问题就解决了，可以正常编译 python3。&lt;/p&gt;&lt;h3&gt;其他问题&lt;/h3&gt;&lt;p&gt;目前还遇到了一个小 bug：gettext 强制打开了 xattr（https://bugs.gentoo.org/910070），但是 attr 在 macOS 上编译不过，解决办法是再 force 把 xattr USE 删掉：&lt;/p&gt;&lt;p&gt;```shell$ cat /etc/portage/profile/package.use.force&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;=sys-devel/gettext-0.22-r1 -xattr```&lt;/p&gt;&lt;/blockquote&gt;</description><link>https://jia.je/devops/2023/07/08/gentoo-prefix-m1/</link> <pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/devops/2023/07/08/gentoo-prefix-m1/</guid> </item> <item> <title>生成树协议</title> <category>mstp</category> <category>networking</category> <category>pvst</category> <category>rstp</category> <category>stp</category> <category>vbst</category> <description>&lt;h1&gt;生成树协议&lt;/h1&gt;&lt;h2&gt;Spanning Tree Protocol&lt;/h2&gt;&lt;p&gt;STP（Spanning Tree Protocol）可以在 &lt;a href=&#34;https://ieeexplore.ieee.org/document/1389253&#34;&gt;802.1D-1998&lt;/a&gt; 第 8 章中找到。STP 协议工作在交换机上，需要根据交换机连接的拓扑，自动计算出一个生成树，并且把不在生成树上的边禁用，这样即使连接的拓扑有环路，禁用以后就没有环了。有了 STP 以后，连接交换机的时候就可以刻意连成环，从而提供冗余。&lt;/p&gt;&lt;p&gt;在 STP 协议提出的时候，网络还不像现在这样以点对点为主，因此需要考虑共享介质的场景，也就是多个交换机连到同一个局域网，并且这个局域网通过 Hub 来共享介质。因此，实际上局域网也属于拓扑的一部分，对应生成树的一个结点。为了统一点对点和共享介质，不妨认为点对点连接中，也连接了一个共享介质的局域网，只不过这个局域网没有其他网络设备。这样设定以后，从网络拓扑上来看，就是很多个独立的局域网，用交换机连接起来。&lt;/p&gt;&lt;p&gt;STP 协议工作的第一步是选举出一个 Root Bridge，也就是生成树的根结点。为了保证选举出唯一的 Root Bridge，选择的标准是，找到最小的 Bridge ID，ID 由人为设定的优先级以及 MAC 地址组成。由于 MAC 地址是唯一的，所以 Bridge ID 也是唯一的，因此一定可以找到一个最小的 ID，那么它就是 Root Bridge。&lt;/p&gt;&lt;p&gt;实际工作的时候，交换机会收发 BPDU，并且把其他交换机发给自己的 Root ID 和自己的 ID 进行比较：如果自己的 ID 比别人发的 Root ID 都小，那么自己是 Root；如果别人发的 Root ID 比自己小，那自己肯定不是 Root。经过一段时间，拥有最小 ID 的 Bridge 信息会逐渐传播到整个网络，最后所有交换机都会对 Root Bridge 达成共识。&lt;/p&gt;&lt;p&gt;确定好 Root Bridge 之后，接下来就是得到生成树。每个交换机会接收相邻交换机发送的 BPDU，得知相邻交换机到 Root Bridge 的距离，然后像路由协议那样，计算出走从哪个 Port 走到达 Root Bridge 的距离最短，就把这个 Port 标记为 Root Port，意思是沿着这个方向走，就会一跳一跳地到达 Root Bridge。同时也会更新自己到 Root Bridge 的距离，发给相邻的交换机。这些 Root Port 的方向就对应了生成树里面的父亲节点。&lt;/p&gt;&lt;p&gt;得到生成树以后，就知道如何禁用不在生成树的边了：如果在某个非 Root 端口上监听到了其他交换机发送的 BPDU，那就说明交换机在这个端口方向上存在一条不在生成树上的边。但是，这条边上有一个局域网（前面提到，即使是交换机之间点对点连接，也可以认为有一个没有网络设备的局域网在中间），这个局域网依然需要能够访问其他局域网。因此，连接到同一个局域网的多个交换机，需要选择出一个交换机，负责这个局域网的所有流量，也就是 Designated Bridge。Designated Bridge 连向局域网的 Port 就是 Designated Port。而连接到局域网的非 Designated Bridge，就需要禁用端口，不收不发数据，只处理 BPDU，此时就是 Block Port。&lt;/p&gt;&lt;p&gt;因此，从交换机的视角，如果是 Root Bridge，看到的就是若干个 Designated Port；如果不是 Root Bridge，那么会看到一个 Root Port，若干个 Designated Port，可能还有 Blocked Port。&lt;/p&gt;&lt;p&gt;需要区分两个概念：Role 和 State。每个交换机在每个 Port 上，都有一个 Role 和一个 State：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Role：Root，Designated，Blocked&lt;/li&gt;&lt;li&gt;State：Disabled，Blocking，Listening，Learning，Forwarding&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Role 指的是端口的属性，用于 STP 内部：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Root：连向 Root 的最短路径的方向&lt;/li&gt;&lt;li&gt;Designated：负责转发局域网流量&lt;/li&gt;&lt;li&gt;Blocked：出现了环导致不能转发&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;State 指的是端口的状态，可以认为是 STP 的输出，把端口设置为对应的状态：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Blocking：不转发以太网帧&lt;/li&gt;&lt;li&gt;Listening：不转发以太网帧，但是收发 BPDU&lt;/li&gt;&lt;li&gt;Learning：在 Listening 的基础上，监听流量，学习 MAC 地址，添加到转发表&lt;/li&gt;&lt;li&gt;Forwarding：正常工作&lt;/li&gt;&lt;li&gt;Disabled：被管理员禁用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;小结一下 STP 的工作流程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;选举出 Root Bridge&lt;/li&gt;&lt;li&gt;对于每个 LAN Segment，选举出 Designated Switch&lt;/li&gt;&lt;li&gt;把不在生成树上的端口设置为 Blocking&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;Rapid Spanning Tree Protocol&lt;/h2&gt;&lt;p&gt;RSTP（Rapid Spanning Tree Protocol）是 STP 协议的升级，在 &lt;a href=&#34;https://ieeexplore.ieee.org/document/1309630&#34;&gt;802.1D-2004&lt;/a&gt; 标准中定义。&lt;/p&gt;&lt;p&gt;和 STP 不同，RSTP 定义了五个 Role：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Root：连向 Root 的最短路径的方向&lt;/li&gt;&lt;li&gt;Designated：负责转发局域网流量&lt;/li&gt;&lt;li&gt;Alternate：连向 Root 的另一条路径的方向&lt;/li&gt;&lt;li&gt;Backup：已经有另一个交换机连接的局域网方向&lt;/li&gt;&lt;li&gt;Disabled：被管理员禁用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了 Disabled 以外，RSTP 和 STP 的区别在于，RSTP 把 Blocked 改成了 Alternate 和 Backup：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Alternate 作为 Root 的备份：记录交换机到 Root 的第二条路径，当 Root Port 出问题了，那么 Alternate Port 可以成为新的 Root Port&lt;/li&gt;&lt;li&gt;Backup 作为 Designated 的备份：连接的局域网有别的 Designated Bridge，如果 Designated Bridge 出问题了，自己可以成为新的 Designated Bridge&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这样的好处是，如果 Root Port 出问题了，可以及时切换到别的路径上，提高收敛速度。&lt;/p&gt;&lt;p&gt;相比 STP，RSTP 把 State 简化成了三个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Discarding：不转发以太网帧，对应 STP 的 Blocking 和 Listening&lt;/li&gt;&lt;li&gt;Learning：不转发以太网帧，学习 MAC 地址&lt;/li&gt;&lt;li&gt;Forwarding：正常工作&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;VLAN&lt;/h2&gt;&lt;p&gt;STP 和 RSTP 都没有考虑 VLAN，只考虑了交换机的拓扑。但实际上，每个 VLAN 可能是不同的一个拓扑，可能只有部分交换机参与到特定的 VLAN 中，这时候就希望可以做一个 Per VLAN 的 STP。&lt;/p&gt;&lt;p&gt;Per VLAN 的 STP 相关协议有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;STP + VLAN: Per-VLAN Spanning Tree(PVST/PVST+) by Cisco&lt;/li&gt;&lt;li&gt;RSTP + VLAN: Rapid Per-VLAN Spanning Tree(Rapid PVST/Rapid PVST+) by Cisco&lt;/li&gt;&lt;li&gt;RSTP + VLAN: Vlan-based Spanning Tree(VBST) by Huawei&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据文档，VBST 和 Rapid PVST 是兼容的，虽然名字不同，但大概率是一样的协议。&lt;/p&gt;&lt;p&gt;此外还有 Multiple Spanning Tree Protocol(MSTP)，定义在 IEEE 802.1s-2002 标准中，它并不是 Per-VLAN Spanning Tree，而支持跨 VLAN 的生成树计算。&lt;/p&gt;&lt;p&gt;下面是在不同型号的交换机上观察到支持的协议：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Dell：stp pvst rstp rapid-pvst mstp&lt;/li&gt;&lt;li&gt;Huawei：stp rstp mstp vbst&lt;/li&gt;&lt;li&gt;Mellanox：rst mst rpvst&lt;/li&gt;&lt;li&gt;Cisco：mst rapid-pvst&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实践中，可以使用 rapid-pvst/vbst/rpvst 的配置。&lt;/p&gt;&lt;h2&gt;STP Port Type&lt;/h2&gt;&lt;p&gt;在交换机设置中，经常可以看到对 STP Port Type 的支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Edge：仅主机&lt;/li&gt;&lt;li&gt;Network：仅交换机&lt;/li&gt;&lt;li&gt;Normal：自适应&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;STP 协议在工作的时候，为了防止协议初始化过程中引入了不必要的环路，初始化时是不转发流量的。那么，如果事先知道端口连接的只有主机，没有交换机，就可以跳过这个过程，直接开始进入 Forwarding 状态，此时就可以设置为 Edge 模式。在 Edge 模式下，交换机不会发送 BPDU。&lt;/p&gt;&lt;p&gt;如果事先知道连接的是交换机，可以选择 Network，但是需要注意的是，Cisco 实现了 Bridge Assurance，也就是说，如果设置为 Network 模式，&lt;strong&gt;必须要求对方也设置为 Network 模式&lt;/strong&gt;，否则就不会工作。&lt;/p&gt;&lt;p&gt;普适的方法是设置为 Normal，此时就会按照正常的方法来初始化。&lt;/p&gt;&lt;h2&gt;BPDU Filter&lt;/h2&gt;&lt;p&gt;BPDU Filter 顾名思义，在特定端口上禁用 STP 协议：不发送 BPDU，收到的 BPDU 都忽略，可以用来限制 STP 工作的范围。&lt;/p&gt;&lt;h2&gt;Virtual Port Channel (vPC)&lt;/h2&gt;&lt;p&gt;STP 解决了环路的问题，使得网络管理员在设计拓扑的时候，可以添加更多边来提供冗余。但是，STP 的工作原理决定了，冗余链路平时是被禁用的，不会走流量。是否有办法，在提供冗余的同时，又能够利用上冗余链路的带宽？&lt;/p&gt;&lt;p&gt;针对这个场景，厂商提供了不同的解决方案，这里以 Cisco 的 vPC 作为一个例子来介绍。vPC 就是虚拟的 Port Channel 的意思，Port Channel 就是链路聚合，把两个交换机之间的多条链路当成一个用；Virtual Port Channel(vPC) 则是把 Port Channel 扩展到了跨交换机，二对一，一部分链路连到 Switch 1，剩下的链路连到 Switch 2，但是从外面看过来，等价于只有一个交换机：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/vpc.png&#34;&gt;&lt;/p&gt;&lt;p&gt;来源：&lt;a href=&#34;https://www.ciscopress.com/articles/article.asp?p=3150966&amp;amp;seqNum=2&#34;&gt;Port Channels and vPCs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这样就实现了对冗余链路的利用。&lt;/p&gt;&lt;p&gt;在 vPC 的 Peer Switch 模式下，为了让 Switch 3 看到的只是一个交换机，它把 Switch 1 和 Switch 2 伪装成同一个交换机：STP 的 Bridge ID 相同，在 STP 协议中看起来到就是一个 Root Bridge。&lt;/p&gt;&lt;p&gt;在 Dell 和 Mellanox 交换机中，类似的功能叫做 MLAG(Multi-switch LAG/Multi-chassis LAG)。&lt;/p&gt;</description><link>https://jia.je/networking/2023/06/20/spanning-tree-protocol/</link> <pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/networking/2023/06/20/spanning-tree-protocol/</guid> </item> <item> <title>从 libvirtd 迁移到 Proxmox VE</title> <category>libvirtd</category> <category>proxmoxve</category> <category>pve</category> <category>qemu</category> <category>software</category> <description>&lt;h1&gt;从 libvirtd 迁移到 Proxmox VE&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;之前用 libvirtd + virt-manager 做 Linux 上的虚拟化，好处是比较轻量级，但是远程控制起来比较麻烦，要么通过 RDP 访问 virt-manager 的 UI，要么就用 cockpit 在网页里去配置虚拟机。此时就会比较怀念 VMware ESXi 的网页，但是 ESXi 装完以后，宿主机就很不自由了，很多东西没法自定义。最后就想到在 Debian 上装一个 Proxmox VE，希望得到一个比较好的中间态。&lt;/p&gt;&lt;h2&gt;Proxmox VE 安装&lt;/h2&gt;&lt;p&gt;按照官方的 &lt;a href=&#34;https://pve.proxmox.com/wiki/Install_Proxmox_VE_on_Debian_11_Bullseye&#34;&gt;Install Proxmox VE on Debian 11 Bullseye&lt;/a&gt; 去安装即可。我的环境是 Debian Bookworm，把路径改成 Bookworm 的 pvetest 即可。安装的时候可能会遇到一些小问题，例如用 ifupdown2 替换 ifupdown 的时候会检查 config 是否正确等等。安装完以后重启，就可以用 root 用户访问 Proxmox VE 了。&lt;/p&gt;&lt;h2&gt;迁移 libvirtd 虚拟机&lt;/h2&gt;&lt;p&gt;下一步是迁移 libvirtd 虚拟机。在网上搜索，会看到提供的方法是，在 Proxmox VE 里创建一个同样大小的镜像，然后把原来的 qcow2 的数据复制一份，但是这样复制的时候得存两份数据，而且对稀疏 qcow2 的支持也不太好。&lt;/p&gt;&lt;p&gt;最后实际的解决办法是：在 Proxmox VE 里创建一个和 qcow2 大小一样的镜像，设置为 qcow2 格式，然后去 &lt;code&gt;/var/lib/vz/images&lt;/code&gt; 路径下找到新建的 qcow2，直接用原来 libvirtd 创建的 qcow2 覆盖过去。目前来看，还没有遇到问题，毕竟 ProxmoxVE 用的也是 QEMU，和 libvirtd 一样。&lt;/p&gt;&lt;h2&gt;UEFI&lt;/h2&gt;&lt;p&gt;在 Proxmox VE 创建虚拟机，如果选的是 UEFI，由于它会采用新的 EFI vars 镜像，所以原来的 UEFI vars 就丢失了，启动的时候，如果 grub 的 EFI 程序不在标准的路径下，可能会找不到 grub。&lt;/p&gt;&lt;p&gt;解决办法是，先删掉网卡，然后修改 boot order，把 ESP 分区所在的盘加上去，这样 UEFI 启动的时候直接进 shell，然后在 fs0 里找到 grub 的 EFI 程序再启动。&lt;/p&gt;&lt;p&gt;在启动 NixOS 的时候，还发现运行 systemd-boot 的 EFI 程序的时候会 Access Denied，查询了一下，是因为 Secure Boot。进入 UEFI Firmware Setup，把 Secure Boot 关掉再重启，就可以正常进入了。&lt;/p&gt;&lt;h2&gt;Windows&lt;/h2&gt;&lt;p&gt;在创建虚拟机的时候，如果指定了 Windows 11，就会自动勾选上 TPM 相关的配置。但启动的时候，说 swtpm 报错无法启动，按照错误信息查询了一下，找到了 &lt;a href=&#34;https://github.com/quickemu-project/quickemu/issues/487&#34;&gt;Apparmor &amp;gt; swtpm: Could not open UnixIO socket: Permission denied&lt;/a&gt;：原因是 AppArmor 拦截了 swtpm 的操作，可以用命令来解除 AppArmor 的拦截：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellsudo aa-complain /usr/bin/swtpmsudo apparmor_parser -r /etc/apparmor.d/usr.bin.swtpm&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样处理以后就可以正常启动 Windows 了。&lt;/p&gt;</description><link>https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</link> <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</guid> </item> <item> <title>LoongArch 初尝试</title> <category>hardware</category> <category>la32</category> <category>la32r</category> <category>la64</category> <category>loongarch</category> <category>qemu</category> <description>&lt;h1&gt;LoongArch 初尝试&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近应龙芯要求把监控程序移植到了 LoongArch 32 Reduced 架构上，趁此机会体验了一下 LoongArch 相关的软件和系统。&lt;/p&gt;&lt;h2&gt;在 QEMU 中运行 LoongArch Arch Linux&lt;/h2&gt;&lt;p&gt;主页：https://github.com/loongarchlinux&lt;/p&gt;&lt;p&gt;环境：Debian Bookworm&lt;/p&gt;&lt;p&gt;QEMU 启动流程，参考&lt;a href=&#34;https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/README.html&#34;&gt;官方文档&lt;/a&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellwget https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/archlinux-xfce4-2023.05.10-loong64.qcow2.zstzstd -d archlinux-xfce4-2023.05.10-loong64.qcow2.zstwget https://mirrors.wsyu.edu.cn/loongarch/archlinux/images/QEMU_EFI_7.2.fd&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后就可以启动 QEMU 7.2.2 了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellqemu-system-loongarch64 \ -m 4G \ -cpu la464-loongarch-cpu \ -machine virt \ -smp 4 \ -bios ./QEMU_EFI_7.2.fd \ -serial stdio \ -device virtio-gpu-pci \ -net nic -net user \ -device nec-usb-xhci,id=xhci,addr=0x1b \ -device usb-tablet,id=tablet,bus=xhci.0,port=1 \ -device usb-kbd,id=keyboard,bus=xhci.0,port=2 \ -hda archlinux-xfce4-2023.05.10-loong64.qcow2&lt;/code&gt;&lt;/p&gt;&lt;p&gt;启动后，可以正常看到 Xfce4 的界面，用 loongarch:loongarch 登录：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/loongarchlinux.png&#34;&gt;&lt;/p&gt;&lt;p&gt;如果不想用 UI，可以先在虚拟机里启动 SSHD，再打开 SSH 转发：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;in vm&lt;/h1&gt;&lt;p&gt;sudo systemctl enable --now sshd&lt;/p&gt;&lt;h1&gt;in host&lt;/h1&gt;&lt;p&gt;qemu-system-loongarch64 \ -m 4G \ -cpu la464-loongarch-cpu \ -machine virt \ -smp 4 \ -bios ./QEMU_EFI_7.2.fd \ -nographic \ -device virtio-net,netdev=net0 \ -netdev user,id=net0,hostfwd=tcp::4444-:22 \ -hda archlinux-xfce4-2023.05.10-loong64.qcow2```&lt;/p&gt;&lt;p&gt;然后就可以通过 SSH 访问 LoongArch 虚拟机了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ ssh loongarch@localhost -p 4444loongarch@localhost&#39;s password:[loongarch@archlinux ~]$ uname -aLinux archlinux 6.3.0-12 #1 SMP Thu, 27 Apr 2023 12:24:56 +0000 loongarch64 GNU/Linux&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;LoongArch 架构&lt;/h2&gt;&lt;p&gt;LoongArch 分为三个版本：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;LoongArch 32 Reduced：精简版本，系统和用户态都是 32 位&lt;/li&gt;&lt;li&gt;LoongArch 32：系统和用户态都是 32 位&lt;/li&gt;&lt;li&gt;LoongArch 64：系统是 64 位，用户态可以是 32 位，也可以是 64 位&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;目前上游工具链支持的是 LoongArch 64。&lt;/p&gt;&lt;p&gt;龙芯杯采用的是 LoongArch 32 Reduced 版本，相比 LoongArch 32 的区别有：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;删掉了部分算术指令&lt;/li&gt;&lt;li&gt;删掉了位操作指令&lt;/li&gt;&lt;li&gt;删除了边界检查访存指令&lt;/li&gt;&lt;li&gt;删除了 Atomic 原子指令，只保留了 LL+SC&lt;/li&gt;&lt;li&gt;删除了部分浮点运算指令&lt;/li&gt;&lt;li&gt;删除了 IOCSR 访问指令&lt;/li&gt;&lt;li&gt;删除了软件页表遍历指令&lt;/li&gt;&lt;li&gt;TLB Refill 异常的相关 CSR（ERA/BADV/PRMD/EHI/ELO0/ELO1/SAVE）不再单独提供一份，而是和其他异常共用&lt;/li&gt;&lt;li&gt;去掉了 STLB，只保留了 MTLB&lt;/li&gt;&lt;li&gt;去掉了部分 CSR&lt;/li&gt;&lt;li&gt;直接映射配置窗口数量砍到了两个&lt;/li&gt;&lt;li&gt;删除了 RAS，PMU，Watchpoint 和硬件调试功能&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;从用户态来看，主要是差了一些运算指令，需要编译器注意生成的指令范围。内核态上删减的比较多。&lt;/p&gt;&lt;h2&gt;LoongArch 32 Reduced&lt;/h2&gt;&lt;p&gt;龙芯提供了一些 LoongArch 32 Reduced 的工具链：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;GCC + Binutils：&lt;a href=&#34;https://gitee.com/loongson-edu/la32r-toolchains/releases/download/v0.0.2/loongarch32r-linux-gnusf-2022-05-20-x86.tar.gz&#34;&gt;loongarch32r-linux-gnusf-2022-05-20-x86.tar.gz&lt;/a&gt;，有源码。&lt;/li&gt;&lt;li&gt;GDB：&lt;a href=&#34;https://gitee.com/loongson-edu/la32r-toolchains/releases/download/v0.0.2/loongarch32r-linux-gnusf-gdb-x86&#34;&gt;loongarch32r-linux-gnusf-gdb-x86&lt;/a&gt;，依赖的动态库较多，建议起一个 CentOS Docker。没有找到源码。&lt;/li&gt;&lt;li&gt;QEMU：&lt;a href=&#34;https://gitee.com/loongson-edu/la32r-QEMU/releases/download/v0.0.1-alpha/qemu-system-loongarch32_centos_x86_64&#34;&gt;qemu-system-loongarch32_centos_x86_64&lt;/a&gt;，依赖的动态库较多，建议克隆下来自己编译：&lt;code&gt;mkdir build; cd build; ../configure --target-list=loongarch32-softmmu --disable-werror --enable-debug&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在 &lt;a href=&#34;https://gitee.com/loongson-edu/la32r-QEMU&#34;&gt;la32r-QEMU&lt;/a&gt; 中运行 &lt;a href=&#34;https://gitee.com/loongson-edu/la32r-Linux/&#34;&gt;la32r-Linux&lt;/a&gt;：&lt;/p&gt;&lt;p&gt;```shellwget https://gitee.com/loongson-edu/la32r-Linux/releases/download/v0.2/vmlinuxqemu-system-loongarch32 -m 4G -kernel vmlinux -M ls3a5k32 -nographicloongson32_init: num_nodes 1loongson32_init: node 0 mem 0x100000000[ 0.000000] Linux version 5.14.0-rc2-g32a8c74db8fc-dirty (mengfanrui@5.5) (loongarch32r-linux-gnusf-gcc (GCC) 8.3.0, GNU ld (GNU Binutils) 2.31.1.20190122) #26 PREEMPT Tue May 31 13:46:54 CST 2022[ 0.000000] Standard 32-bit Loongson Processor probed[ 0.000000] the link is empty![ 0.000000] Scan bootparam failed[ 0.000000] printk: bootconsole [early0] enabled[ 0.000000] Can&#39;t find EFI system table.[ 0.000000] start_pfn=0x0, end_pfn=0x8000, num_physpages:0x8000[ 0.000000] The BIOS Version: (null)[ 0.000000] Initrd not found or empty - disabling initrd[ 0.000000] CPU0 revision is: 00004200 (Loongson-32bit)[ 0.000000] Primary instruction cache 8kB, 2-way, VIPT, linesize 16 bytes.[ 0.000000] Primary data cache 8kB, 2-way, VIPT, no aliases, linesize 16 bytes[ 0.000000] Zone ranges:[ 0.000000] DMA32 [mem 0x0000000000000000-0x00000000ffffffff][ 0.000000] Normal empty[ 0.000000] Movable zone start for each node[ 0.000000] Early memory node ranges[ 0.000000] node 0: [mem 0x0000000000000000-0x0000000007ffffff][ 0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000007ffffff][ 0.000000] eentry = 0xa0210000,tlbrentry = 0xa0201000[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 32480[ 0.000000] Kernel command line: earlycon[ 0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes, linear)[ 0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes, linear)[ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off[ 0.000000] Memory: 117732K/131072K available (4926K kernel code, 1114K rwdata, 944K rodata, 2480K init, 473K bss, 13340K reserved, 0K cma-reserved)[ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1[ 0.000000] rcu: Preemptible hierarchical RCU implementation.[ 0.000000] rcu: RCU event tracing is enabled.[ 0.000000] Trampoline variant of Tasks RCU enabled.[ 0.000000] Tracing variant of Tasks RCU enabled.[ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.[ 0.000000] NR_IRQS: 320[ 0.000000] ------------[ cut here ]------------[ 0.000000] WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:38 cev_delta2ns.isra.15+0x17c/0x1c8[ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.14.0-rc2-g32a8c74db8fc-dirty #26[ 0.000000] Stack :[ 0.000000] Call Trace:[ 0.000000][ 0.000000][ 0.000000] random: get_random_bytes called from print_oops_end_marker+0x30/0x68 with crng_init=0[ 0.000000] ---[ end trace a8581308883ff14d ]---[ 0.000000] Constant clock event device register[ 0.000000] clocksource: Constant: mask: 0xffffffffffffffff max_cycles: 0xffffffffffffffff, max_idle_ns: 9007199254740991 ns[ 0.000000] Constant clock source device register[ 0.752000] Console: colour dummy device 80x25[ 0.816000] printk: console [tty0] enabled[ 0.856000] printk: bootconsole [early0] disabled[ 0.000000] Linux version 5.14.0-rc2-g32a8c74db8fc-dirty (mengfanrui@5.5) (loongarch32r-linux-gnusf-gcc (GCC) 8.3.0, GNU ld (GNU Binutils) 2.31.1.20190122) #26 PREEMPT Tue May 31 13:46:54 CST 2022[ 0.000000] Standard 32-bit Loongson Processor probed[ 0.000000] the link is empty![ 0.000000] Scan bootparam failed[ 0.000000] printk: bootconsole [early0] enabled[ 0.000000] Can&#39;t find EFI system table.[ 0.000000] start_pfn=0x0, end_pfn=0x8000, num_physpages:0x8000[ 0.000000] The BIOS Version: (null)[ 0.000000] Initrd not found or empty - disabling initrd[ 0.000000] CPU0 revision is: 00004200 (Loongson-32bit)[ 0.000000] Primary instruction cache 8kB, 2-way, VIPT, linesize 16 bytes.[ 0.000000] Primary data cache 8kB, 2-way, VIPT, no aliases, linesize 16 bytes[ 0.000000] Zone ranges:[ 0.000000] DMA32 [mem 0x0000000000000000-0x00000000ffffffff][ 0.000000] Normal empty[ 0.000000] Movable zone start for each node[ 0.000000] Early memory node ranges[ 0.000000] node 0: [mem 0x0000000000000000-0x0000000007ffffff][ 0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000007ffffff][ 0.000000] eentry = 0xa0210000,tlbrentry = 0xa0201000[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 32480[ 0.000000] Kernel command line: earlycon[ 0.000000] Dentry cache hash table entries: 16384 (order: 4, 65536 bytes, linear)[ 0.000000] Inode-cache hash table entries: 8192 (order: 3, 32768 bytes, linear)[ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off[ 0.000000] Memory: 117732K/131072K available (4926K kernel code, 1114K rwdata, 944K rodata, 2480K init, 473K bss, 13340K reserved, 0K cma-reserved)[ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1[ 0.000000] rcu: Preemptible hierarchical RCU implementation.[ 0.000000] rcu: RCU event tracing is enabled.[ 0.000000] Trampoline variant of Tasks RCU enabled.[ 0.000000] Tracing variant of Tasks RCU enabled.[ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.[ 0.000000] NR_IRQS: 320[ 0.000000] ------------[ cut here ]------------[ 0.000000] WARNING: CPU: 0 PID: 0 at kernel/time/clockevents.c:38 cev_delta2ns.isra.15+0x17c/0x1c8[ 0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 5.14.0-rc2-g32a8c74db8fc-dirty #26[ 0.000000] Stack :[ 0.000000] Call Trace:[ 0.000000][ 0.000000][ 0.000000] random: get_random_bytes called from print_oops_end_marker+0x30/0x68 with crng_init=0[ 0.000000] ---[ end trace a8581308883ff14d ]---[ 0.000000] Constant clock event device register[ 0.000000] clocksource: Constant: mask: 0xffffffffffffffff max_cycles: 0xffffffffffffffff, max_idle_ns: 9007199254740991 ns[ 0.000000] Constant clock source device register[ 0.752000] Console: colour dummy device 80x25[ 0.816000] printk: console [tty0] enabled[ 0.856000] printk: bootconsole [early0] disabled[ 1.024000] random: fast init done[ 1.240000] Calibrating delay loop... 0.65 BogoMIPS (lpj=1312)[ 1.444000] pid_max: default: 32768 minimum: 301[ 1.860000] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 1.868000] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 10.740000] rcu: Hierarchical SRCU implementation.[ 13.408000] devtmpfs: initialized[ 15.948000] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns[ 15.980000] futex hash table entries: 256 (order: -1, 3072 bytes, linear)[ 16.948000] NET: Registered PF_NETLINK/PF_ROUTE protocol family[ 28.832000] pps_core: LinuxPPS API ver. 1 registered[ 28.840000] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#103;&amp;#105;&amp;#111;&amp;#109;&amp;#101;&amp;#116;&amp;#116;&amp;#105;&amp;#64;&amp;#108;&amp;#105;&amp;#110;&amp;#117;&amp;#120;&amp;#46;&amp;#105;&amp;#116;&#34;&gt;&amp;#103;&amp;#105;&amp;#111;&amp;#109;&amp;#101;&amp;#116;&amp;#116;&amp;#105;&amp;#64;&amp;#108;&amp;#105;&amp;#110;&amp;#117;&amp;#120;&amp;#46;&amp;#105;&amp;#116;&lt;/a&gt;[ 32.492000] clocksource: Switched to clocksource Constant[ 32.492000] FS-Cache: Loaded[ 32.492000] NET: Registered PF_INET protocol family[ 32.492000] IP idents hash table entries: 2048 (order: 2, 16384 bytes, linear)[ 32.492000] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes, linear)[ 32.492000] TCP established hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 32.492000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 32.492000] TCP: Hash tables configured (established 1024 bind 1024)[ 32.492000] UDP hash table entries: 256 (order: 0, 4096 bytes, linear)[ 32.492000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes, linear)[ 32.492000] NET: Registered PF_UNIX/PF_LOCAL protocol family[ 32.492000] workingset: timestamp_bits=14 max_order=15 bucket_order=1[ 32.492000] IPMI message handler: version 39.2[ 32.492000] ipmi device interface[ 32.492000] ipmi_si: IPMI System Interface driver[ 32.492000] ipmi_si: Unable to find any System Interface(s)[ 32.492000] Serial: 8250/16550 driver, 16 ports, IRQ sharing enabled[ 32.492000] 1fe001e0.serial: ttyS0 at MMIO 0x1fe001e0 (irq = 18, base_baud = 2062500) is a 16550A[ 32.492000] printk: console [ttyS0] enabled[ 32.492000] ls1a-nand driver initializing[ 32.492000] ls1a_nand : mtd struct base address is a102b800[ 32.492000] info-&amp;gt;data_buff===================0x81130000[ 32.492000] nand: No NAND device found[ 32.492000] ls1a-nand 1fe78000.nand: failed to scan nand[ 32.492000] ITC MAC 10/100M Fast Ethernet Adapter driver 1.0 init[ 32.492000] libphy: Fixed MDIO Bus: probed[ 32.492000] mousedev: PS/2 mouse device common for all mice[ 32.492000] IR MCE Keyboard/mouse protocol handler initialized[ 32.492000] hid: raw HID events driver (C) Jiri Kosina[ 32.492000] NET: Registered PF_INET6 protocol family[ 32.492000] random: crng init done[ 32.492000] Segment Routing with IPv6[ 32.492000] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver[ 32.492000] Warning: unable to open an initial console.[ 32.492000] Freeing unused kernel image (initmem) memory: 2480K[ 32.492000] This architecture does not have kernel memory protection.[ 32.492000] Run /init as init process&lt;/p&gt;&lt;p&gt;Processing /etc/profile... Done&lt;/p&gt;&lt;p&gt;/ #```&lt;/p&gt;&lt;p&gt;我在 la32r-QEMU 的基础上，把 LoongArch 32 Reduced 的支持部分移植到了 QEMU 8.0.0 上：&lt;a href=&#34;https://github.com/jiegec/qemu/commits/la32r-8.0.0&#34;&gt;https://github.com/jiegec/qemu/commits/la32r-8.0.0&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;虚实地址映射&lt;/h2&gt;&lt;p&gt;LoongArch 有两种虚实地址映射方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;直接地址翻译模式（CSR.CRMD.DA=1，CSR.CRMD.PG=0），此时物理地址等于虚拟地址，如果虚拟地址位数更多，则截断高位。&lt;/li&gt;&lt;li&gt;映射地址翻译模式（CSR.CRMD.DA=0，CSR.CRMD.PG=1），此时按照顺序进行下面的翻译：&lt;ol&gt;&lt;li&gt;直接映射模式：CSR.DMW 定义了四个（LA32R 只有两个）窗口，这些窗口内的虚拟地址与物理地址是平移的关系。&lt;/li&gt;&lt;li&gt;页表映射模式：如果没有匹配上直接映射模式，则会查询 TLB。虽说是页表映射模式，但依然是 MIPS 传统的 TLB 做法。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;相比 MIPS 来讲，LoongArch 的地址映射还是容易理解一些。&lt;/p&gt;&lt;p&gt;从复位中出来的时候，CSR.CRMD.DA=1，CSR.CRMD.PG=0，意味着是直接地址翻译模式。PC 是 0x1C000000，由于是直接地址翻译模式，所以物理地址也是 0x1C000000。&lt;/p&gt;&lt;p&gt;在遇到 TLB Refill 异常的时候，处理器会跳到 CSR.TLBRENTRY 的地址，同时进入直接地址翻译模式（CSR.CRMD.DA=1，CSR.CRMD.PG=0），意味着虚拟地址直接对应物理地址，所以此时需要做好相应的准备。LoongArch 提供了 lddir 和 ldpte 指令来加快页表到 TLB 项目的查询性能，例如下面是 &lt;a href=&#34;https://github.com/tianocore/edk2-platforms/blob/4c3e742e931538a1ee6cb3b571b1281e7fba2564/Platform/Loongson/LoongArchQemuPkg/Library/MmuLib/Mmu.S#L37&#34;&gt;EDK2 的 TLB Refill 异常处理函数&lt;/a&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;asmASM_PFX(HandleTlbRefill): csrwr T0, LOONGARCH_CSR_TLBRSAVE csrrd T0, LOONGARCH_CSR_PGD lddir T0, T0, 3 #Put pud BaseAddress into T0 lddir T0, T0, 2 #Put pmd BaseAddress into T0 lddir T0, T0, 1 #Put pte BaseAddress into T0 ldpte T0, 0 ldpte T0, 1 tlbfill csrrd T0, LOONGARCH_CSR_TLBRSAVE ertn&lt;/code&gt;&lt;/p&gt;&lt;p&gt;比较有意思的是，csrwr 指令会把旧的 CSR 值写回到通用寄存器里，所以看起来名字是 write，其实是 swap。为了方便查表，还给用户态和内核态分别一个页表基地址：CSR.PGDL，CSR.PGDH，根据异常的高位判断要选择哪一个页表基地址。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/06/12/try-loongarch/</link> <pubDate>Mon, 12 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/06/12/try-loongarch/</guid> </item> <item> <title>Tar 文件格式</title> <category>software</category> <category>tar</category> <description>&lt;h1&gt;Tar 文件格式&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/software/tar.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近在解压 tar.gz 文件的时候，发现如果用 unar 解压，就会出现文件名截断到 100 个字节的问题，而如果用 gnu tar 解压，文件名就是正常的，因此深入研究了一下 Tar 的文件格式。实际上，这是因为早期 tar 格式设计的时候，就设定了路径最长 100 字节的限制，后来的扩展解决了这个问题，但是 unar 没能正确地识别扩展，导致解压路径出错。&lt;/p&gt;&lt;h2&gt;Tar 文件格式&lt;/h2&gt;&lt;p&gt;Tar 的文件格式比较简单，就是一系列的 File Entry，最后是两个 512 字节的全 0，表示结束。每个 File Entry 由头部和数据组成，头部的格式是：&lt;/p&gt;&lt;p&gt;```c/&lt;em&gt; tar Header Block, from POSIX 1003.1-1990. &lt;/em&gt;/&lt;/p&gt;&lt;p&gt;/&lt;em&gt; POSIX header. &lt;/em&gt;/&lt;/p&gt;&lt;p&gt;struct posix_header{ /&lt;em&gt; byte offset &lt;/em&gt;/ char name[100]; /&lt;em&gt; 0 &lt;/em&gt;/ char mode[8]; /&lt;em&gt; 100 &lt;/em&gt;/ char uid[8]; /&lt;em&gt; 108 &lt;/em&gt;/ char gid[8]; /&lt;em&gt; 116 &lt;/em&gt;/ char size[12]; /&lt;em&gt; 124 &lt;/em&gt;/ char mtime[12]; /&lt;em&gt; 136 &lt;/em&gt;/ char chksum[8]; /&lt;em&gt; 148 &lt;/em&gt;/ char typeflag; /&lt;em&gt; 156 &lt;/em&gt;/ char linkname[100]; /&lt;em&gt; 157 &lt;/em&gt;/ char magic[6]; /&lt;em&gt; 257 &lt;/em&gt;/ char version[2]; /&lt;em&gt; 263 &lt;/em&gt;/ char uname[32]; /&lt;em&gt; 265 &lt;/em&gt;/ char gname[32]; /&lt;em&gt; 297 &lt;/em&gt;/ char devmajor[8]; /&lt;em&gt; 329 &lt;/em&gt;/ char devminor[8]; /&lt;em&gt; 337 &lt;/em&gt;/ char prefix[155]; /&lt;em&gt; 345 &lt;/em&gt;/ /&lt;em&gt; 500 &lt;/em&gt;/};```&lt;/p&gt;&lt;p&gt;来源：&lt;a href=&#34;https://www.gnu.org/software/tar/manual/html_node/Standard.html&#34;&gt;Basic Tar Format&lt;/a&gt;&lt;/p&gt;&lt;p&gt;可以看到，就是一系列的 char 数组，里面的很多数字字段，例如 mode，uid 和 gid 等，都是用 ASCII 码写的。由于头部需要对齐到 512 字节，所以实际上后面还有 12 字节的 padding。&lt;/p&gt;&lt;p&gt;头部的 512 字节结束后，紧接着就是文件的内容，内容的大小在头部的 size 字段已经保存，把字符串当成 8 进制数转换，就可以得到文件长度。文件也要对齐到 512 字节，所以文件后面还有若干个 0 作为 padding。&lt;/p&gt;&lt;p&gt;总结一下，Tar 文件的格式就是：&lt;code&gt;(头部，数据)*结尾&lt;/code&gt;。每一个部分都对齐到 512 字节。&lt;/p&gt;&lt;h2&gt;PAX 扩展&lt;/h2&gt;&lt;p&gt;如果仔细观察，会发现上面的 &lt;code&gt;posix_header&lt;/code&gt; 里面，&lt;code&gt;name&lt;/code&gt; 字段只有 100 个字节，意味着如果文件路径特别长，那就放不下，只能截断了。为了解决这个问题，Tar 引入了 PAX 扩展。&lt;/p&gt;&lt;p&gt;具体来说，PAX 扩展以特殊的文件形式存在。例如要记录一个名字很长的文件 &lt;code&gt;&#39;X&#39;*101&lt;/code&gt;，实际上 Tar 中记录了两个文件：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;PaxHeader：特殊的 PAX 文件，不对应实际的文件&lt;/li&gt;&lt;li&gt;&lt;code&gt;&#39;X&#39;*100&lt;/code&gt;：文件名被截断，其他不变&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个 PaxHeader 在解压的时候，不会生成实际的文件。它的内容是一些键值对，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;123 path=XXXXXXXXXXXXXXXXX...&lt;/code&gt;&lt;/p&gt;&lt;p&gt;格式是：&lt;code&gt;length key=value\n&lt;/code&gt;，然后可以有多个这样的键值对。这样就可以解决 &lt;code&gt;posix_header&lt;/code&gt; 里名字长度限制的问题：只要在 PaxHeader 文件里，保存一个 key 为 path，value 为实际名字的信息。那么 tar 在看到 PaxHeader 的时候，记录下来，再遇到下一个文件的时候，就知道要用 PaxHeader 中的 path，而不是保存在 &lt;code&gt;posix_header&lt;/code&gt; 中的 &lt;code&gt;name[100]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;类似地，PaxHeader 还可以存很多其他 &lt;code&gt;posix_header&lt;/code&gt; 中没有的信息，例如 &lt;code&gt;atime&lt;/code&gt;、&lt;code&gt;ctime&lt;/code&gt; 和 &lt;code&gt;uid&lt;/code&gt; 等等。完整列表可以参考 &lt;a href=&#34;https://www.ibm.com/docs/en/zos/2.4.0?topic=descriptions-pax-interchange-portable-archives#r4paxsh__pxchk&#34;&gt;Extended header keywords&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;Bard&lt;/h2&gt;&lt;p&gt;Bard 讲解 Tar 格式：&lt;/p&gt;&lt;p&gt;A tar file is an archive file format that is used to store a collection of files in a single file. The tar format is a standard format on Unix-like operating systems and is also supported by many other operating systems.&lt;/p&gt;&lt;p&gt;A tar file consists of a series of blocks, each of which contains 512 bytes of data. Each block contains a header and a body. The header contains information about the file, such as the file name, the file size, and the file permissions. The body contains the actual contents of the file.&lt;/p&gt;&lt;p&gt;The tar format is a simple and efficient format for storing files. It is also a portable format, which means that tar files can be moved from one computer to another without any problems.&lt;/p&gt;&lt;p&gt;Here is a more detailed description of the tar file format:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The header of a tar file is 512 bytes long. It contains the following information:&lt;ul&gt;&lt;li&gt;The name of the file&lt;/li&gt;&lt;li&gt;The size of the file&lt;/li&gt;&lt;li&gt;The permissions of the file&lt;/li&gt;&lt;li&gt;The modification time of the file&lt;/li&gt;&lt;li&gt;The owner of the file&lt;/li&gt;&lt;li&gt;The group of the file&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;The body of a tar file contains the actual contents of the file. The body is padded to a multiple of 512 bytes.&lt;/li&gt;&lt;li&gt;Tar files can be compressed using a variety of compression algorithms, such as gzip, bzip2, and xz.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Tar files are a versatile format that can be used for a variety of purposes. They are commonly used for backing up files, distributing software, and archiving files.&lt;/p&gt;&lt;p&gt;Here are some of the benefits of using tar files:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Tar files are a standard format that is supported by many operating systems.&lt;/li&gt;&lt;li&gt;Tar files are a portable format, which means that they can be moved from one computer to another without any problems.&lt;/li&gt;&lt;li&gt;Tar files can be compressed using a variety of compression algorithms, which can significantly reduce the size of the archive.&lt;/li&gt;&lt;li&gt;Tar files can be easily created and managed using the tar command-line tool.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If you need to store a collection of files in a single file, then a tar file is a good option to consider.&lt;/p&gt;&lt;p&gt;Bard 讲解 PAX 扩展：&lt;/p&gt;&lt;p&gt;The POSIX 1003.1-2001 (pax) format for tar archives supports file names longer than 256 characters by using a different format for storing file names and metadata than the traditional ustar format. In the pax format, file names are stored as null-terminated strings, which means that they can be any length up to the maximum file size supported by the underlying file system. The metadata for each file is also stored in a separate record, which allows for more flexibility in the types of metadata that can be stored.&lt;/p&gt;&lt;p&gt;To create a tar archive in the pax format, you can use the following command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;tar cf - --format=pax /path/to/files&lt;/code&gt;&lt;/p&gt;&lt;p&gt;To extract a tar archive in the pax format, you can use the following command:&lt;/p&gt;&lt;p&gt;&lt;code&gt;tar xvf - --format=pax archive.tar&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The pax format is a more flexible and powerful format than the ustar format, and it is recommended for use when creating or extracting tar archives that may contain file names longer than 256 characters.&lt;/p&gt;&lt;p&gt;Here are some additional details about the pax format:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;File names are stored as null-terminated strings, which means that they can be any length up to the maximum file size supported by the underlying file system.&lt;/li&gt;&lt;li&gt;The metadata for each file is stored in a separate record, which allows for more flexibility in the types of metadata that can be stored.&lt;/li&gt;&lt;li&gt;The pax format is supported by most modern tar implementations.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Here are some examples of file names that can be stored in the pax format:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&#34;This is a file name with more than 256 characters.&#34;&lt;/li&gt;&lt;li&gt;&#34;/path/to/a/file/with/a/long/name.&#34;&lt;/li&gt;&lt;li&gt;&#34;file.with.spaces.in.its.name&#34;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The pax format is a good choice for storing file names that may be long, contain special characters, or be stored in a directory hierarchy with a long path.&lt;/p&gt;</description><link>https://jia.je/software/2023/05/23/tar-format/</link> <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/23/tar-format/</guid> </item> <item> <title>使用 Docker 部署 OpenLDAP</title> <category>docker</category> <category>ldap</category> <category>openldap</category> <category>software</category> <description>&lt;h1&gt;使用 Docker 部署 OpenLDAP&lt;/h1&gt;&lt;h2&gt;Docker-Compose&lt;/h2&gt;&lt;p&gt;OpenLDAP 可以用现成的 Docker 镜像：&lt;a href=&#34;https://hub.docker.com/r/bitnami/openldap/&#34;&gt;bitnami/openldap&lt;/a&gt;，配合 Docker-Compose 进行部署：&lt;/p&gt;&lt;p&gt;```ymlversion: &#39;2&#39;&lt;/p&gt;&lt;p&gt;services: openldap: image: bitnami/openldap:2.6 ports: - &#39;1389:1389&#39; # LDAP environment: - LDAP_ROOT=dc=example,dc=com # example.com env_file: .env # admin password volumes: - &#39;./data:/bitnami/openldap&#39; # data storage```&lt;/p&gt;&lt;p&gt;admin 密码建议单独保存，例如写在 &lt;code&gt;.env&lt;/code&gt; 中：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellLDAP_ADMIN_PASSWORD=12345678REDACTED&lt;/code&gt;&lt;/p&gt;&lt;p&gt;启动服务：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;prepare data folder&lt;/h1&gt;&lt;p&gt;sudo rm -rf datasudo mkdir datasudo chown 1001:root data&lt;/p&gt;&lt;h1&gt;launch docker compose&lt;/h1&gt;&lt;p&gt;sudo docker-compose up -d```&lt;/p&gt;&lt;p&gt;然后就可以通过 ldapsearch 列出所有对象，默认情况下不需要登录（Bind DN），可以只读访问：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;search elements under dc=example,dc=com&lt;/h1&gt;&lt;h1&gt;-x: Simple authentication without user and password&lt;/h1&gt;&lt;h1&gt;-b dc=example,dc=com: base dn for search&lt;/h1&gt;&lt;h1&gt;-H: ldap server&lt;/h1&gt;&lt;p&gt;$ ldapsearch -x -b dc=example,dc=com -H ldap://localhost:1389/&lt;/p&gt;&lt;h1&gt;user01, users, example.com&lt;/h1&gt;&lt;p&gt;dn: cn=user01,ou=users,dc=example,dc=comcn: User1cn: user01sn: Bar1objectClass: inetOrgPersonobjectClass: posixAccountobjectClass: shadowAccountuserPassword:: Yml0bmFtaTE=uid: user01uidNumber: 1000gidNumber: 1000homeDirectory: /home/user01&lt;/p&gt;&lt;h1&gt;user02, users, example.com&lt;/h1&gt;&lt;p&gt;dn: cn=user02,ou=users,dc=example,dc=comcn: User2cn: user02sn: Bar2objectClass: inetOrgPersonobjectClass: posixAccountobjectClass: shadowAccountuserPassword:: Yml0bmFtaTI=uid: user02uidNumber: 1001gidNumber: 1001homeDirectory: /home/user02```&lt;/p&gt;&lt;p&gt;可以看到 Docker 镜像初始化了两个用户，仅供测试用，它用的密码比较弱。&lt;/p&gt;&lt;h2&gt;TLS&lt;/h2&gt;&lt;p&gt;接着，给 OpenLDAP 配置 TLS。首先用 OpenSSL 生成 CA 和证书：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;https://arminreiter.com/2022/01/create-your-own-certificate-authority-ca-using-openssl/&lt;/h1&gt;&lt;h1&gt;setup CA&lt;/h1&gt;&lt;p&gt;rm -rf certsmkdir -p certs&lt;/p&gt;&lt;p&gt;openssl genrsa -out certs/ldap_ca.key 4096openssl req -x509 -new -nodes -key certs/ldap_ca.key -sha256 -days 1826 -out certs/ldap_ca.crt -subj &#34;/CN=Example Com CA/ST=Somewhere/L=Earth/O=ExampleOrg&#34;&lt;/p&gt;&lt;h1&gt;setup cert&lt;/h1&gt;&lt;h1&gt;CN must match hostname&lt;/h1&gt;&lt;p&gt;openssl req -new -nodes -out certs/ldap_server.csr -newkey rsa:4096 -keyout certs/ldap_server.key -subj &#34;/CN=$(hostname)/ST=Somewhere/L=Earth/O=ExampleOrg&#34;openssl x509 -req -in certs/ldap_server.csr -CA certs/ldap_ca.crt -CAkey certs/ldap_ca.key -CAcreateserial -out certs/ldap_server.crt -days 730 -sha256&lt;/p&gt;&lt;p&gt;chown -R 1001:root certs```&lt;/p&gt;&lt;p&gt;然后修改 docker-compose.yml：&lt;/p&gt;&lt;p&gt;```ymlversion: &#39;2&#39;&lt;/p&gt;&lt;p&gt;services: openldap: image: bitnami/openldap:2.6 ports: - &#39;1389:1389&#39; # LDAP - &#39;1636:1636&#39; # LDAPS environment: - LDAP_ROOT=dc=example,dc=com # example.com - LDAP_ENABLE_TLS=yes - LDAP_TLS_CERT_FILE=/opt/bitnami/openldap/certs/ldap_server.crt - LDAP_TLS_KEY_FILE=/opt/bitnami/openldap/certs/ldap_server.key - LDAP_TLS_CA_FILE=/opt/bitnami/openldap/certs/ldap_ca.crt env_file: .env # admin password volumes: - &#39;./data:/bitnami/openldap&#39; # data storage - &#39;./certs:/opt/bitnami/openldap/certs&#39;```&lt;/p&gt;&lt;p&gt;再重新启动，就可以用 LDAPS 来访问 LDAP Server：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;LDAP&lt;/h1&gt;&lt;p&gt;$ ldapsearch -x -b dc=example,dc=com -H ldap://localhost:1389/&lt;/p&gt;&lt;h1&gt;LDAPS&lt;/h1&gt;&lt;p&gt;$ LDAPTLS_CACERT=$PWD/certs/ldap_ca.crt ldapsearch -x -b dc=example,dc=com -H ldaps://localhost:1636/```&lt;/p&gt;&lt;h2&gt;修改密码&lt;/h2&gt;&lt;p&gt;管理员修改用户的密码，使用 ldappasswd 修改：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;h1&gt;Generate a new password for cn=user01,ou=users,dc=example,dc=com&lt;/h1&gt;&lt;h1&gt;-W: prompt for bind(login) password&lt;/h1&gt;&lt;h1&gt;-D cn=admin,dc=example,dc=com: bind(login) to admin user&lt;/h1&gt;&lt;p&gt;$ ldappasswd -x -W -D cn=admin,dc=example,dc=com -H ldap://localhost:1389/ cn=user01,ou=users,dc=example,dc=comEnter LDAP Password:New password: REDACTED&lt;/p&gt;&lt;h1&gt;Set password for for cn=user01,ou=users,dc=example,dc=com&lt;/h1&gt;&lt;h1&gt;-S: prompt for new password&lt;/h1&gt;&lt;p&gt;$ ldappasswd -x -W -S -D cn=admin,dc=example,dc=com -H ldap://localhost:1389/ cn=user01,ou=users,dc=example,dc=comNew password:Re-enter new password:Enter LDAP Password:```&lt;/p&gt;&lt;p&gt;默认情况下，用户没有权限修改自己的密码。可以进入 Docker 容器，修改数据库的权限：&lt;/p&gt;&lt;p&gt;```shell$ sudo docker-compose exec openldap bash&lt;/p&gt;&lt;h1&gt;Authenticate using local user&lt;/h1&gt;&lt;p&gt;openldap$ ldapmodify -Y EXTERNAL -H &#34;ldapi:///&#34;SASL/EXTERNAL authentication startedSASL username: gidNumber=0+uidNumber=1001,cn=peercred,cn=external,cn=authSASL SSF: 0&lt;/p&gt;&lt;h1&gt;Paste the following lines&lt;/h1&gt;&lt;h1&gt;Allow user to change its own password&lt;/h1&gt;&lt;p&gt;dn: olcDatabase={2}mdb,cn=configchangetype: modifyreplace: olcAccessolcAccess: {0}to attrs=userPassword by anonymous auth by self write by * noneolcAccess: {1}to * by * read```&lt;/p&gt;&lt;p&gt;此时用户就可以自己修改密码了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ ldappasswd -x -W -S -D cn=user01,ou=users,dc=example,dc=com -H ldap://localhost:1389/New password:Re-enter new password:Enter LDAP Password:&lt;/code&gt;&lt;/p&gt;&lt;p&gt;并且 userPassword 也对非 admin 用户被隐藏了：&lt;/p&gt;&lt;p&gt;```shell$ ldapsearch -x -b dc=example,dc=com -H ldap://localhost:1389/&lt;/p&gt;&lt;h1&gt;user01, users, craft.cn&lt;/h1&gt;&lt;p&gt;dn: cn=user01,ou=users,dc=craft,dc=cncn: User1cn: user01sn: Bar1objectClass: inetOrgPersonobjectClass: posixAccountobjectClass: shadowAccountuid: user01uidNumber: 1000gidNumber: 1000homeDirectory: /home/user01```&lt;/p&gt;&lt;h2&gt;ldap-ui&lt;/h2&gt;&lt;p&gt;如果想要 Web 管理界面，可以用 ldap-ui，在 docker-compose 添加：&lt;/p&gt;&lt;p&gt;&lt;code&gt;yaml ldap-ui: image: dnknth/ldap-ui ports: - &#39;5000:5000&#39; links: - openldap environment: - LDAP_URL=ldap://openldap:1389/ - BASE_DN=dc=example,dc=com - BIND_PATTERN=cn=%s,dc=example,dc=com&lt;/code&gt;&lt;/p&gt;&lt;p&gt;访问 localhost:5000，就可以用 admin 用户登录了。如果想用其他用户登录，由于 BIND 路径多了一级 ou=users，所以要么修改 BIND_PATTERN，要么用户名要写成 user01,ou=users&lt;/p&gt;&lt;h2&gt;权限管理&lt;/h2&gt;&lt;p&gt;前面修改了权限，从而允许用户修改自己的密码：&lt;/p&gt;&lt;p&gt;```shell$ sudo docker-compose exec openldap bash&lt;/p&gt;&lt;h1&gt;Authenticate using local user&lt;/h1&gt;&lt;p&gt;openldap$ ldapmodify -Y EXTERNAL -H &#34;ldapi:///&#34;SASL/EXTERNAL authentication startedSASL username: gidNumber=0+uidNumber=1001,cn=peercred,cn=external,cn=authSASL SSF: 0&lt;/p&gt;&lt;h1&gt;Paste the following lines&lt;/h1&gt;&lt;h1&gt;Allow user to change its own password&lt;/h1&gt;&lt;p&gt;dn: olcDatabase={2}mdb,cn=configchangetype: modifyreplace: olcAccessolcAccess: {0}to attrs=userPassword by anonymous auth by self write by * noneolcAccess: {1}to * by * read```&lt;/p&gt;&lt;p&gt;核心部分的含义如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;to attrs=userPassword：针对 userPassword 这个字段，任何人都可以认证，用户自己可以写，其他人没有权限&lt;/li&gt;&lt;li&gt;to *：任何人可以读&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果想要进一步收缩权限，例如：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不登录看不到任何信息&lt;/li&gt;&lt;li&gt;普通用户登录后，只能读取自己的信息&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;那么，可以写出如下的配置：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ldifdn: olcDatabase={2}mdb,cn=configchangetype: modifyreplace: olcAccessolcAccess: {0}to attrs=userPassword by anonymous auth by self write by * noneolcAccess: {1}to * by self read by * none&lt;/code&gt;&lt;/p&gt;&lt;p&gt;由于从前往后匹配，找到第一个匹配就不看后面的规则的原因，更精确的过滤要放在前面。&lt;/p&gt;&lt;h2&gt;LDAP 用于其他软件的认证&lt;/h2&gt;&lt;p&gt;LDAP 很重要的一个用途是用于其他软件的认证，一般来说有两种用法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;LDAP 自身带了认证的功能（Simple Auth），那么就需要把用户名（user01）映射到 LDAP 的 Bind DN 上（cn=user01,ou=users,cn=example,cn=com），Bind DN 和密码会传输到 LDAP Server；在 LDAP Server 上密码会与用户的 userPassword 进行匹配，如果 Bind 成功，就认为用户登录成功&lt;/li&gt;&lt;li&gt;LDAP 附带了列用户的功能（Search），那么这个时候，一般是要创建一个用于搜索的 DN 来控制权限；然后其他软件 Bind 到用于搜索的 DN 上，搜索用户，把用户信息同步到本地&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一种使用方法要求用户和 DN 有直接映射关系，例如上面的 &lt;code&gt;cn=%s,ou=users,cn=example=com&lt;/code&gt;，好处是比较简单，缺点是要把所有用户放在同一个 DN 下面，不适合比较复杂的组织结构。&lt;/p&gt;&lt;p&gt;第二种使用方法，则是其他软件先进行搜索（搜索本身可能需要 Bind 到用于搜索的 DN 上），找到匹配用户名或者邮箱的用户，再进行 Simple Auth。这样的好处是灵活性更好，用户不需要放在同一个 DN 下面，可以有更多层级。&lt;/p&gt;&lt;p&gt;由于使用了 Simple Auth，密码会明文发送给 LDAP Server，因此为了安全性，建议配置 TLS。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/13/openldap-in-docker/</link> <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/13/openldap-in-docker/</guid> </item> <item> <title>使用 JLink 操作 SPI NOR Flash</title> <category>flash</category> <category>hardware</category> <category>jflash</category> <category>jlink</category> <category>nor</category> <category>spi</category> <description>&lt;h1&gt;使用 JLink 操作 SPI NOR Flash&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近设计了一款 &lt;a href=&#34;https://github.com/jiegec/PMOD-SPI-NOR-FLASH&#34;&gt;PMOD SPI NOR Flash&lt;/a&gt; 扩展板，搭载了 W25Q128 SPI NOR Flash 芯片。在 jlc 生产回来以后，通过 JLink 连接到电脑上进行测试。&lt;/p&gt;&lt;h2&gt;连接到 JLink&lt;/h2&gt;&lt;p&gt;JLink 提供了 20 pin 的引脚，如果要连接 SPI，那么引脚定义如下：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;https://c.a.segger.com/fileadmin/images/products/J-Link/Software/pinout-spi-20-pin.gif.webp&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://www.segger.com/products/debug-probes/j-link/tools/j-flash-spi/&#34;&gt;JFlash SPI 文档&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;连接的时候，至少需要连接以下的引脚：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;JLink GND(pin 4/6/8/10) - SPI NOR Flash GND&lt;/li&gt;&lt;li&gt;JLink VTref(pin 1) - 3.3V - SPI NOR Flash VCC&lt;/li&gt;&lt;li&gt;JLink CLK(pin 9) - SPI NOR Flash CLK&lt;/li&gt;&lt;li&gt;JLink DI(pin 5) - SPI NOR Flash D0/DI/MOSI&lt;/li&gt;&lt;li&gt;JLink DO(pin 13) - SPI NOR Flash D1/DO/MISO&lt;/li&gt;&lt;li&gt;JLink nCS(pin 7) - SPI NOR Flash CS#&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于 SPI NOR Flash 无法接受 5V 的电压，所以要用额外的 3.3V 作为电源，同时接到 JLink 的 VTref 引脚上。&lt;/p&gt;&lt;p&gt;JFlash SPI 还支持 Quad SPI 模式，可以在它的文档里找到连接方式。&lt;/p&gt;&lt;h2&gt;JFlash SPI&lt;/h2&gt;&lt;p&gt;连接了以后，就可以在 JFlash SPI 软件中识别出 SPI Flash 了：Flash ID 0xEF 40 18。有意思的是，JFlash SPI 软件会认为这个芯片是 Infineon 的 S25FL128K，而不是 Winbond 的 W25Q128。发邮件问了一下 SEGGER，得到的回复是这两个芯片的 Flash ID 都是 0xEF4018，所以无法区分。&lt;/p&gt;&lt;h2&gt;flashrom&lt;/h2&gt;&lt;p&gt;如果想用开源软件，可以用 flashrom，编译的时候打开 jlink 支持，就可以用 flashrom 来通过 JLink 读写 SPI NOR Flash。&lt;/p&gt;&lt;p&gt;但是 flashrom 的 cs 信号并不是上面的 nCS(pin 7)，而是 nRESET(pin 15，默认) 或者 nTRST(pin 3，可以添加参数 &lt;code&gt;cs=trst&lt;/code&gt;)。这就导致如果想用 flashrom 的话，就要修改引脚连接方式，把 pin 15 连接到 SPI NOR Flash 的 CS# 上。修改连接以后，就可以检测到芯片了：&lt;/p&gt;&lt;p&gt;```shell$ flashrom --programmer jlink_spiflashrom v1.3.0 on Darwin 22.4.0 (arm64)flashrom is free software, get the source code at https://flashrom.org&lt;/p&gt;&lt;p&gt;Calibrating delay loop... OK.Found Winbond flash chip &#34;W25Q128.V&#34; (16384 kB, SPI) on jlink_spi.===This flash part has status UNTESTED for operations: WPThe test status of this chip may have been updated in the latest developmentversion of flashrom. If you are running the latest development version,please email a report to flashrom@flashrom.org if any of the above operationswork correctly for you with this flash chip. Please include the flashrom logfile for all operations you tested (see the man page for details), and mentionwhich mainboard or programmer you tested in the subject line.Thanks for your help!No operations were specified.```&lt;/p&gt;&lt;p&gt;为了解决这个问题，我给 &lt;a href=&#34;https://review.coreboot.org/c/flashrom/+/75011&#34;&gt;flashrom&lt;/a&gt; 提交了 patch，如果合并了，就可以支持 &lt;code&gt;--programmer jlink_spi:cs=tms&lt;/code&gt; 选项，此时就不需要修改连接方式了。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/05/08/jlink-spi-nor-flash/</link> <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/05/08/jlink-spi-nor-flash/</guid> </item> <item> <title>链接器的工作原理</title> <category>ld</category> <category>linker</category> <category>software</category> <description>&lt;h1&gt;链接器的工作原理&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近和同学讨论一些比较复杂的链接问题，遇到一些比较复杂的情况，因此复习一遍链接器的工作原理。&lt;/p&gt;&lt;h2&gt;编译&lt;/h2&gt;&lt;p&gt;编译器会把源文件编译成 obj，obj 里面有符号表，定义了不同的符号类型。常见的代码与符号的对应关系：&lt;/p&gt;&lt;p&gt;&lt;code&gt;c// global in .bss section if -fno-common// common symbol if -fcommonint uninitialized;// global in .bss sectionint initialized = 0;// global in .data sectionint initialized_one = 1;// global in .rodata sectionconst int const_initialized = 0;// global in .rodata sectionconst int const_initialized_one = 1;// global undefined symbolextern int external;// local in .bss sectionstatic int static_uninitialized;// local in .bss sectionstatic int static_initialized = 0;// local in .data sectionstatic int static_initialized_one = 1;// local in .rodata sectionconst static int const_static_initialized = 0;// local in .rodata sectionconst static int const_static_initialized_one = 1;// global in .text sectionint simple_function() { // local in .bss section static int static_in_function = 0;}// global in .text sectionvoid access_external() { external = 1; }// global undefined symbolextern double external_function();// global in .text sectionlong call_external() { external_function(); }// local in .text sectionstatic int static_function() {}// weak in .text section__attribute__ ((weak)) float weak_function() {}// global in .text section marked .hidden__attribute__ ((visibility (&#34;hidden&#34;))) int hidden_function() {}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;readelf -s&lt;/code&gt; 查看符号表：&lt;/p&gt;&lt;p&gt;&lt;code&gt;Num: Value Size Type Bind Vis Ndx Name 6: 0000000000000008 4 OBJECT LOCAL DEFAULT 4 static_uninitialized 7: 000000000000000c 4 OBJECT LOCAL DEFAULT 4 static_initialized 8: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_initializ[...] 9: 0000000000000008 4 OBJECT LOCAL DEFAULT 5 const_static_ini[...] 10: 000000000000000c 4 OBJECT LOCAL DEFAULT 5 const_static_ini[...] 11: 0000000000000029 7 FUNC LOCAL DEFAULT 1 static_function 12: 0000000000000010 4 OBJECT LOCAL DEFAULT 4 static_in_function.0 16: 0000000000000000 4 OBJECT GLOBAL DEFAULT 4 uninitialized 17: 0000000000000004 4 OBJECT GLOBAL DEFAULT 4 initialized 18: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 initialized_one 19: 0000000000000000 4 OBJECT GLOBAL DEFAULT 5 const_initialized 20: 0000000000000004 4 OBJECT GLOBAL DEFAULT 5 const_initialized_one 21: 0000000000000000 7 FUNC GLOBAL DEFAULT 1 simple_function 22: 0000000000000007 17 FUNC GLOBAL DEFAULT 1 access_external 23: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND external 24: 0000000000000018 17 FUNC GLOBAL DEFAULT 1 call_external 25: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 26: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND external_function 27: 0000000000000030 11 FUNC WEAK DEFAULT 1 weak_function 28: 000000000000003b 7 FUNC GLOBAL HIDDEN 1 hidden_function&lt;/code&gt;&lt;/p&gt;&lt;p&gt;总结一下，每个符号有如下属性：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Bind：Local（static）、Global（extern 或者非 static）、Weak（标记 &lt;code&gt;__attribute__ ((weak))&lt;/code&gt;）&lt;/li&gt;&lt;li&gt;Vis(Visibility): Default、Hidden（标记 &lt;code&gt;__attribute__ ((visibility (&#34;hidden&#34;)))&lt;/code&gt;）&lt;/li&gt;&lt;li&gt;Ndx：&lt;ol&gt;&lt;li&gt;COMMON：如果打开了 -fcommon，那么没有初始化的全局变量（上面的 &lt;code&gt;uninitialized&lt;/code&gt;）会生成 COMMON 符号；如果打开了 -fno-common，则不会有 COMMON 符号&lt;/li&gt;&lt;li&gt;UNDEFINED：extern 符号&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Section:&lt;ol&gt;&lt;li&gt;const 变量放在 .rodata section&lt;/li&gt;&lt;li&gt;非 const 变量，如果没有初始化，如果开了 -fcommon，则生成 COMMON 符号；如果开了 -fno-common，则放在 .bss section&lt;/li&gt;&lt;li&gt;非 const 变量，如果初始化了，放在 .data section&lt;/li&gt;&lt;li&gt;函数放在 .text section&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;关于 COMMON 符号的详细内容，建议阅读 &lt;a href=&#34;https://maskray.me/blog/2022-02-06-all-about-common-symbols&#34;&gt;All about COMMON symbols - MaskRay&lt;/a&gt; 和 &lt;a href=&#34;/software/2022/07/11/archive-common-linking/&#34;&gt;COMMON 符号&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;链接&lt;/h2&gt;&lt;p&gt;链接要做的是把多个 obj 合并成一个可执行文件或者动态库，主要目的是将一个 obj 中定义的符号与另一个 obj 中 undefined 的符号对应起来。&lt;/p&gt;&lt;p&gt;链接器运行时，传入若干个 obj 文件，然后按照下面的流程进行：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;维护一个全局的符号表&lt;/li&gt;&lt;li&gt;循环每个 obj 文件，循环其中的符号，找到其中的 GLOBAL/WEAK 符号&lt;/li&gt;&lt;li&gt;把 GLOBAL/WEAK 符号插入到符号表中，处理各种情况，例如：&lt;ol&gt;&lt;li&gt;如果出现两个 defined 符号冲突，报告 multiple definition 错误&lt;/li&gt;&lt;li&gt;如果出现重名的 weak 符号和 strong 符号，选择保留 strong 的符号&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;如果存在没有找到匹配的 defined 符号的 undefined 符号，报告 undefined reference 错误&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;符号表是在解析 obj 文件的同时动态更新的，因此，如果 A 使用了 B 的符号，那么应该把 A 放在前面，这样链接器解析 A 的时候会在符号表中创建 undefined 符号，然后 B 在后面，当链接器解析 B 的时候，就可以把 B 的 defined 符号与 A 的 undefined 符号进行匹配。&lt;/p&gt;&lt;h2&gt;静态库&lt;/h2&gt;&lt;p&gt;静态库将多个 .o 合并为一个 .a，并且创建了索引。具体来说，创建一个静态库的时候：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ ar rcs libxxx.a obj1.o obj2.o obj3.o ...&lt;/code&gt;&lt;/p&gt;&lt;p&gt;生成的 .a 会包括所有的 .o，然后创建索引（&lt;code&gt;ar rcs&lt;/code&gt; 中的 &lt;code&gt;s&lt;/code&gt;，会运行 &lt;code&gt;ranlib&lt;/code&gt; 命令），索引的内容是一个符号到 .o 文件的映射：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ nm -s /lib/x86_64-linux-gnu/libc.aArchive index:__printf in printf.o_IO_printf in printf.oprintf in printf.o__scanf in scanf.oscanf in scanf.o&lt;/code&gt;&lt;/p&gt;&lt;p&gt;因此，链接器在遇到参数是 .a 的静态库的时候，不会查看里面的每个 .o 文件，而是从 Archive index 入手，如果当前的符号表依赖了 Archive index 中的符号，那就加载相应的 .o 文件。&lt;/p&gt;&lt;h2&gt;动态库&lt;/h2&gt;&lt;p&gt;生成动态库的方法是，编译的时候添加 &lt;code&gt;-fPIC&lt;/code&gt; 选项，链接的时候添加 &lt;code&gt;-shared&lt;/code&gt; 编译参数：&lt;/p&gt;&lt;p&gt;```shellgcc -fPIC -c source1.c -o source1.ogcc -shared source1.o -o libtest.so.0.0.0&lt;/p&gt;&lt;h1&gt;oneliner:&lt;/h1&gt;&lt;p&gt;gcc -fPIC -shared source1.c -o libtest.so.0.0.0```&lt;/p&gt;&lt;p&gt;此时代码中定义的函数会出现在 Dynamic Symbol Table 中，可以用 &lt;code&gt;objdump -T&lt;/code&gt; 命令查看：&lt;/p&gt;&lt;p&gt;```shell$ cat source1.cint simple_function() {}$ objdump -T libtest.so.0.0.0&lt;/p&gt;&lt;p&gt;libtest.so.0.0.0: file format elf64-x86-64&lt;/p&gt;&lt;p&gt;DYNAMIC SYMBOL TABLE:0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 &lt;strong&gt;cxa_finalize0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 _ITM_registerTMCloneTable0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 _ITM_deregisterTMCloneTable0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 __gmon_start&lt;/strong&gt;00000000000010f9 g DF .text 0000000000000007 simple_function```&lt;/p&gt;&lt;p&gt;如果代码中用了 libc 的一些函数，那么这些函数则会以 undefined symbol 的形式出现在 Dynamic Symbol Table 中：&lt;/p&gt;&lt;p&gt;```shell$ cat source1.c&lt;/p&gt;&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;&lt;p&gt;int simple_function() { printf(&#34;Simple function&#34;); return 0;}$ objdump -T libtest.so.0.0.0&lt;/p&gt;&lt;p&gt;libtest.so.0.0.0: file format elf64-x86-64&lt;/p&gt;&lt;p&gt;DYNAMIC SYMBOL TABLE:0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 Base _ITM_deregisterTMCloneTable0000000000000000 DF &lt;em&gt;UND&lt;/em&gt; 0000000000000000 (GLIBC_2.2.5) printf0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 Base &lt;strong&gt;gmon_start&lt;/strong&gt;0000000000000000 w D &lt;em&gt;UND&lt;/em&gt; 0000000000000000 Base _ITM_registerTMCloneTable0000000000000000 w DF &lt;em&gt;UND&lt;/em&gt; 0000000000000000 (GLIBC_2.2.5) __cxa_finalize0000000000001109 g DF .text 000000000000001b Base simple_function```&lt;/p&gt;&lt;h3&gt;符号版本&lt;/h3&gt;&lt;p&gt;中间出现的 Base 或者 GLIBC_2.2.5 是符号的版本号，这样做的目的是为了兼容性：假如某天 glibc 想要给一个函数添加一个新的参数，但是现有的程序编译的时候动态链接了旧版本的 glibc，新旧两个版本的函数名字一样，但是功能却不一样，如果直接让旧程序用新 glibc 的函数，就会出现问题。即使参数不变，如果函数的语义变了，也可能带来不兼容的问题。&lt;/p&gt;&lt;p&gt;解决办法是给符号添加版本号，这样旧版本的程序会继续找到旧版本的符号，解决了兼容性的问题。例如 memcpy 在 glibc 中就有两个版本：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep memcpy00000000000a2b70 g DF .text 0000000000000028 (GLIBC_2.2.5) memcpy000000000009bc50 g iD .text 0000000000000109 GLIBC_2.14 memcpy&lt;/code&gt;&lt;/p&gt;&lt;p&gt;在 &lt;a href=&#34;https://github.com/bminor/glibc/blob/a363f7075125fa654342c69331e6c075518ec28c/sysdeps/x86_64/multiarch/memcpy.c#LL38C11-L38C11&#34;&gt;glibc 代码&lt;/a&gt;中，通过 &lt;code&gt;versioned_symbol&lt;/code&gt; 宏来实现：&lt;/p&gt;&lt;p&gt;&lt;code&gt;cversioned_symbol (libc, __new_memcpy, memcpy, GLIBC_2_14);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;更多关于符号版本的内容，可以阅读 &lt;a href=&#34;https://maskray.me/blog/2020-11-26-all-about-symbol-versioning&#34;&gt;All about symbol versioning&lt;/a&gt;。&lt;/p&gt;&lt;h3&gt;动态链接&lt;/h3&gt;&lt;p&gt;编译好动态链接库以后，可以在链接的时候，作为参数引入：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ cat main.cextern void simple_function();int main() { simple_function(); }$ gcc main.c libtest.so.0.0.0 -o main$ LD_LIRBARY_PATH=$PWD ./mainSimple function&lt;/code&gt;&lt;/p&gt;&lt;p&gt;可以观察一下发生了什么事情：首先，链接的时候，会找到 &lt;code&gt;libtest.so.0.0.0&lt;/code&gt; 导出的符号表，发现它定义了 &lt;code&gt;main.c&lt;/code&gt; 缺少的 &lt;code&gt;simple_function&lt;/code&gt; 函数，因此链接不会出错。但是，函数本身没有被链接到 &lt;code&gt;main&lt;/code&gt; 里面，需要在运行时去加载动态库，这样 &lt;code&gt;main&lt;/code&gt; 才可以调用函数：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -t main0000000000000000 F *UND* 0000000000000000 simple_function$ objdump -T main0000000000000000 DF *UND* 0000000000000000 Base simple_function$ readelf -d ./mainDynamic section at offset 0x2dd0 contains 27 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libtest.so.0.0.0] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6]$ ./main./main: error while loading shared libraries: libtest.so.0.0.0: cannot open shared object file: No such file or directory$ ldd ./main linux-vdso.so.1 (0x00007ffe07dbc000) libtest.so.0.0.0 =&amp;gt; not found libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f83ee3fb000) /lib64/ld-linux-x86-64.so.2 (0x00007f83ee602000)$ LD_LIBRARY_PATH=$PWD ldd ./main linux-vdso.so.1 (0x00007fffb0bd5000) libtest.so.0.0.0 =&amp;gt; /tmp/libtest.so.0.0.0 (0x00007f985b3db000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f985b1db000) /lib64/ld-linux-x86-64.so.2 (0x00007f985b3e7000)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;首先可以看到，二进制里面 &lt;code&gt;simple_function&lt;/code&gt; 依然属于 undefined 状态。但 &lt;code&gt;main&lt;/code&gt; 也指定了 NEEDED libtest.so.0.0.0，那么在运行的时候，ld.so 就会去寻找这个动态库。由于当前路径不在系统默认路径中，直接运行是找不到的（&lt;code&gt;not found&lt;/code&gt;），这里的解决办法是添加动态库的路径到 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 中。&lt;/p&gt;&lt;h3&gt;soname&lt;/h3&gt;&lt;p&gt;上述例子中，编译出来的动态库名称带有完整的版本号：&lt;code&gt;major.minor.patch=0.0.0&lt;/code&gt;，但一般认为，如果 &lt;code&gt;major&lt;/code&gt; 版本号没有变，可以认为是 ABI 兼容的，可以更新动态库的版本，而不用重新编译程序。但是，上面的例子里，&lt;code&gt;readelf -d main&lt;/code&gt; 显示 NEEDED 的动态库名字里也包括了完整的版本号，那就没有办法寻找到同 major 的不同版本了。&lt;/p&gt;&lt;p&gt;解决办法是让同 major 的不同版本共享同一个 soname，常见的做法就是只保留 major 版本号：&lt;code&gt;libtest.so.0&lt;/code&gt;，而不是 &lt;code&gt;libtest.so.0.0.0&lt;/code&gt;。在编译动态库的时候，通过 &lt;code&gt;-Wl,-soname,libtest.so.0&lt;/code&gt; 参数来指定 soname：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ gcc -fPIC -shared source1.c -Wl,-soname,libtest.so.0 -o libtest.so.0.0.0$ gcc main.c libtest.so.0.0.0 -o main$ readelf -d main Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libtest.so.0] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6]&lt;/code&gt;&lt;/p&gt;&lt;p&gt;此时可以看到 NEEDED 的动态库名字已经是预期的 &lt;code&gt;libtest.so.0&lt;/code&gt;，这意味着 &lt;code&gt;main&lt;/code&gt; 函数在动态加载的时候，不考虑小版本，只指定了 &lt;code&gt;major&lt;/code&gt; 版本为 0 的 libtest 动态库。但单是这样还不能运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ LD_LIBRARY_PATH=$PWD ./main./main: error while loading shared libraries: libtest.so.0: cannot open shared object file: No such file or directory&lt;/code&gt;&lt;/p&gt;&lt;p&gt;毕竟 ld.so 要找的是 &lt;code&gt;libtest.so.0&lt;/code&gt;，但是文件系统里只有 &lt;code&gt;libtest.so.0.0.0&lt;/code&gt;，最后的这一步用符号链接来实现：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ ln -s libtest.so.0.0.0 libtest.so.0$ LD_LIBRARY_PATH=$PWD ./mainSimple function&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样，如果哪天发布了 libtest.so 的 0.0.1 版本，只需要修改符号链接 &lt;code&gt;libtest.so.0 -&amp;gt; libtest.so.0.0.1&lt;/code&gt; 即可，不需要重新编译 &lt;code&gt;main&lt;/code&gt; 程序。&lt;/p&gt;&lt;p&gt;想要查看动态库的 soname，可以用 &lt;code&gt;readelf -d&lt;/code&gt; 查看：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ readelf -d libtest.so.0.0.0 Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000e (SONAME) Library soname: [libtest.so.0]&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;cuda&lt;/h3&gt;&lt;p&gt;在 CUDA 中，如果程序需要访问 NVML 或者一些底层的 CUDA 函数，会链接到 libcuda（而不是 libcudart），但是如果在 CUDA 目录下寻找 libcuda，只会找到一个 &lt;code&gt;targets/x86_64-linux/lib/stubs/libcuda.so&lt;/code&gt;，里面的函数都是空的，只有一个 &lt;code&gt;retq&lt;/code&gt; 指令：&lt;/p&gt;&lt;p&gt;```shell$ objdump -S ./targets/x86_64-linux/lib/stubs/libcuda.so./targets/x86_64-linux/lib/stubs/libcuda.so: file format elf64-x86-64&lt;/p&gt;&lt;p&gt;Disassembly of section .text:&lt;/p&gt;&lt;p&gt;0000000000007370 &lt;cuGetErrorString&gt;: 7370: b8 22 00 00 00 mov $0x22,%eax 7375: c3 retq 7376: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 737d: 00 00 00&lt;/p&gt;&lt;p&gt;0000000000007380 &lt;cuGetErrorName&gt;: 7380: b8 22 00 00 00 mov $0x22,%eax 7385: c3 retq 7386: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 738d: 00 00 00```&lt;/p&gt;&lt;p&gt;这个 &lt;code&gt;libcuda.so&lt;/code&gt; 用途就是导出了所有可能会用到的符号，并且设置 &lt;code&gt;soname&lt;/code&gt; 为 &lt;code&gt;libcuda.so.1&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;```shell$ readelf -d ./targets/x86_64-linux/lib/stubs/libcuda.so&lt;/p&gt;&lt;p&gt;Dynamic section at offset 0xdf30 contains 8 entries: Tag Type Name/Value 0x000000000000000e (SONAME) Library soname: [libcuda.so.1]```&lt;/p&gt;&lt;p&gt;这就意味着，&lt;code&gt;ld.so&lt;/code&gt; 会去寻找 &lt;code&gt;libcuda.so.1&lt;/code&gt;，而不是 &lt;code&gt;libcuda&lt;/code&gt;。前者才是真正实现了 CUDA Driver 的动态库：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ dpkg -S libcuda.so.1libnvidia-compute-470:amd64: /usr/lib/x86_64-linux-gnu/libcuda.so.1$ ls -alh /usr/lib/x86_64-linux-gnu/libcuda.so.1lrwxrwxrwx 1 root root 21 May 13 2022 /usr/lib/x86_64-linux-gnu/libcuda.so.1 -&amp;gt; libcuda.so.470.129.06&lt;/code&gt;&lt;/p&gt;&lt;p&gt;而 CUDA Driver 的实现和 NVIDIA Driver 的版本是绑定的，因此 &lt;code&gt;libcuda.so.1&lt;/code&gt; 是软链接，软链接到对应驱动版本的 &lt;code&gt;libcuda.so&lt;/code&gt;。这样做的好处就是，编译 CUDA 的机器，不需要安装 NVIDIA Driver，CUDA 也不需要自己带一份 CUDA Driver 进来，节省了空间。&lt;/p&gt;&lt;p&gt;像 pytorch 这种支持 CUDA 的程序，不会在链接的时候链接到 &lt;code&gt;libcuda&lt;/code&gt; 上，而是在用户需要的时候，去 &lt;code&gt;dlopen&lt;/code&gt;。这样即使用户的电脑上没有装 NVIDIA Driver，也可以运行支持 CUDA 的 pytorch。&lt;/p&gt;&lt;h3&gt;dynamic linker/loader&lt;/h3&gt;&lt;p&gt;前文讲到，动态链接库参与链接的时候，实际上函数本身没有链接进可执行程序，最后的加载是由 dynamic linker/loader 完成的，在 linux 上是 ld.so，在 macOS 上是 dyld。它在程序启动的时候，负责根据 NEEDED 信息，知道程序要加载哪些动态库，然后去文件系统里找，如果找到了，就把相应的动态库加载到内存中，然后把可执行程序中对动态链接库的函数调用，变成真实的地址。相当于把原来静态链接的时候，链接器做的事情，挪到了程序运行开始时，即 linking at run time。&lt;/p&gt;&lt;p&gt;那么这里就涉及到一个问题了：NEEDED 只记录了文件名，但是却没有路径。这意味着动态库也需要用类似 PATH 的机制，在一些路径里去寻找一个想要的动态库。例如前文修改 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;，实际上就是告诉 ld.so，可以在这个环境变量指向的路径中寻找动态库的文件。&lt;/p&gt;&lt;p&gt;而用系统包管理器安装的动态库，一般不需要修改 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 也可以用。这是靠 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; 文件实现的。在动态库相关的问题里，经常会看到运行 &lt;code&gt;ldconfig&lt;/code&gt; 命令。这个命令的用途是，收集系统目录里的动态库，建立一个索引，保存在 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; 文件中。然后 ld.so 直接去 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; 中寻找 NEEDED 的动态库对应的文件系统中的路径，不需要再重新扫描一遍目录了。所以 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; 就是一个文件系统中动态库的缓存，这也就是为啥叫做 &lt;code&gt;ld.so.cache&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;既然是缓存，就要考虑缓存和实际对不上的情况，这就是为啥要运行 &lt;code&gt;ldconfig&lt;/code&gt; 命令更新缓存。当然了，包管理器会自动运行 &lt;code&gt;ldconfig&lt;/code&gt;，只有自己 &lt;code&gt;make install&lt;/code&gt; 一些库的时候，才需要手动进行 &lt;code&gt;ldconfig&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ldconfig&lt;/code&gt; 会从 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 中配置的路径中扫描动态链接库，常见的路径包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;/lib/x86_64-linux-gnu&lt;/li&gt;&lt;li&gt;/usr/lib/x86_64-linux-gnu&lt;/li&gt;&lt;li&gt;/usr/local/lib&lt;/li&gt;&lt;li&gt;/usr/local/lib/x86_64-linux-gnu&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;包管理器安装的动态库基本都在这些目录中。可以用 &lt;code&gt;ldconfig -p&lt;/code&gt; 来查看缓存 &lt;code&gt;ld.so.cache&lt;/code&gt; 的内容：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ /sbin/ldconfig -p1967 libs found in cache `/etc/ld.so.cache&#39; libz3.so.4 (libc6,x86-64) =&amp;gt; /lib/x86_64-linux-gnu/libz3.so.4 libz3.so (libc6,x86-64) =&amp;gt; /lib/x86_64-linux-gnu/libz3.so ld-linux.so.2 (ELF) =&amp;gt; /lib/i386-linux-gnu/ld-linux.so.2 ld-linux.so.2 (ELF) =&amp;gt; /lib32/ld-linux.so.2 ld-linux.so.2 (ELF) =&amp;gt; /lib/ld-linux.so.2 ld-linux-x86-64.so.2 (libc6,x86-64) =&amp;gt; /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 ld-linux-x32.so.2 (libc6,x32) =&amp;gt; /libx32/ld-linux-x32.so.2&lt;/code&gt;&lt;/p&gt;&lt;p&gt;维护了 soname 到文件系统中动态库文件的映射。并且添加了一些属性来帮助 ld.so 进行过滤和选择。&lt;/p&gt;&lt;h3&gt;rpath&lt;/h3&gt;&lt;p&gt;除了 LD_LIBRARY_PATH 和 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt;，ld.so 还可以通过 rpath 来寻找动态库。设想要打包一个 Qt 程序，希望在别人的机器上可以直接跑，但是别人的机器上不一定有 Qt，因此需要把程序和 Qt 的各种动态库打包在一起。但是，这时候 Qt 的动态库不会在系统路径中，不会被 &lt;code&gt;ldconfig&lt;/code&gt; 索引。一种办法就是写一个脚本，设置一下 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;，再启动 Qt 程序。另一种办法，就是利用 rpath：在程序中就告诉 ld.so 去哪里找它依赖（NEEDED）的动态库。这个路径可以是相对于可执行文件的路径。&lt;/p&gt;&lt;p&gt;设置 &lt;code&gt;rpath&lt;/code&gt; 的方法是，编译的时候添加 &lt;code&gt;-Wl,-rpath,RPATH&lt;/code&gt; 选项，例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ gcc main.c libtest.so.0.0.0 -o main$ ./main./main: error while loading shared libraries: libtest.so.0: cannot open shared object file: No such file or directory$ gcc main.c libtest.so.0.0.0 -Wl,-rpath,$PWD -o main$ ./mainSimple function$ readelf -d main Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libtest.so.0] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000001d (RUNPATH) Library runpath: [/tmp]$ gcc main.c libtest.so.0.0.0 -Wl,-rpath,&#39;$ORIGIN&#39; -o main$ ./mainSimple function$ readelf -d main Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libtest.so.0] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN]&lt;/code&gt;&lt;/p&gt;&lt;p&gt;第一个编译命令不带 &lt;code&gt;rpath&lt;/code&gt;，因此 ld.so 会找不到动态库，可以添加 LD_LIBRARY_PATH 的办法来解决。第二个和第三个编译命令带 &lt;code&gt;rpath&lt;/code&gt;，其中第二个使用了绝对路径，第三个使用了相对路径（&lt;code&gt;$ORIGIN&lt;/code&gt; 表示可执行文件所在的目录）。那么，ld.so 在寻找 libtest.so.0 的时候，会在 RUNPATH 中进行寻找。&lt;/p&gt;&lt;h3&gt;调试&lt;/h3&gt;&lt;p&gt;动态链接经常会遇到各种找不到动态库的问题，需要使用一些工具来帮助找到问题。最常用的就是 &lt;code&gt;ldd&lt;/code&gt; 命令，显示一个程序依赖的动态库以及路径：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ ldd $(which vim) linux-vdso.so.1 (0x00007fff599a4000) libm.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f0504dfc000) libtinfo.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f0504dc9000) libselinux.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f0504d9b000) libsodium.so.23 =&amp;gt; /lib/x86_64-linux-gnu/libsodium.so.23 (0x00007f05049a6000) libacl.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libacl.so.1 (0x00007f0504d90000) libgpm.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libgpm.so.2 (0x00007f050499e000) libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f05047bd000) /lib64/ld-linux-x86-64.so.2 (0x00007f0504f07000) libpcre2-8.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f0504723000) libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f0504d89000)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;当然了，&lt;code&gt;ldd&lt;/code&gt; 有一定的风险，不建议在不信任的程序上运行 &lt;code&gt;ldd&lt;/code&gt;，详情见 &lt;a href=&#34;https://man7.org/linux/man-pages/man1/ldd.1.html&#34;&gt;ldd.1&lt;/a&gt;。更稳妥的方法是用 &lt;code&gt;objdump -p&lt;/code&gt; 或者 &lt;code&gt;readelf -d&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -p $(which vim) | grep NEEDED$ readelf -d $(which vim) | grep NEEDED&lt;/code&gt;&lt;/p&gt;&lt;p&gt;但是 ldd 可以打印出动态库依赖的动态库，而 objdump 和 readelf 只会打印直接依赖。也可以设置环境变量，让 ld.so 打印出加载的动态库：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ export LD_DEBUG=files$ ./main 2243766: file=libtest.so.0 [0]; needed by ./main [0] 2243766: file=libtest.so.0 [0]; generating link map 2243766: dynamic: 0x00007fcd57c23df8 base: 0x00007fcd57c20000 size: 0x0000000000004018 2243766: entry: 0x00007fcd57c20000 phdr: 0x00007fcd57c20040 phnum: 9 2243766: 2243766: file=libc.so.6 [0]; needed by ./main [0] 2243766: file=libc.so.6 [0]; generating link map 2243766: dynamic: 0x00007fcd57bf1b60 base: 0x00007fcd57a20000 size: 0x00000000001e0f50 2243766: entry: 0x00007fcd57a47350 phdr: 0x00007fcd57a20040 phnum: 14 2243766: 2243766: calling init: /lib64/ld-linux-x86-64.so.2 2243766: calling init: /lib/x86_64-linux-gnu/libc.so.6 2243766: calling init: /tmp/libtest.so.0 2243766: initialize program: ./main 2243766: transferring control: ./main 2243766: calling fini: ./main [0] 2243766: calling fini: /tmp/libtest.so.0 [0]Simple function&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;macOS&lt;/h3&gt;&lt;p&gt;macOS 与 Linux 下动态库的使用方法基本类似，但有一些细微的差别。首先是 macOS 上的动态库的后缀用的是 dylib 而不是 so：&lt;/p&gt;&lt;p&gt;```shell$ gcc -fPIC -shared source1.c -o libtest.dylib$ gcc main.c libtest.dylib -o main$ objdump -t libtest.dyliblibtest.dylib: file format mach-o arm64&lt;/p&gt;&lt;p&gt;SYMBOL TABLE:0000000000003f7c g F __TEXT,__text _simple_function0000000000000000 &lt;em&gt;UND&lt;/em&gt; _printf$ objdump -t mainmain: file format mach-o arm64&lt;/p&gt;&lt;p&gt;SYMBOL TABLE:0000000100000000 g F __TEXT,__text __mh_execute_header0000000100003f94 g F __TEXT,__text _main0000000000000000 &lt;em&gt;UND&lt;/em&gt; _simple_function```&lt;/p&gt;&lt;p&gt;虽然这里用的是 gcc 命令，但实际上 macOS 上的 gcc 命令是 clang。这里直接用 clang 命令也是一样的。可以看到，这里的可执行文件中 &lt;code&gt;simple_function&lt;/code&gt; 函数也是处于 undefined 状态，需要在运行时由 &lt;code&gt;libtest.dylib&lt;/code&gt; 提供。&lt;/p&gt;&lt;p&gt;macOS 下的动态链接器是 dyld，它会解析 MachO 的 Load command 去加载动态库：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -p mainLoad command 13 cmd LC_LOAD_DYLIB cmdsize 40 name libtest.dylib (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 0.0.0compatibility version 0.0.0Load command 14 cmd LC_LOAD_DYLIB cmdsize 56 name /usr/lib/libSystem.B.dylib (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 1319.100.3compatibility version 1.0.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这就相当于 Linux 中的 NEEDED，告诉动态链接器要加载哪些动态库。可以用 &lt;code&gt;otool -L&lt;/code&gt; 或者 &lt;code&gt;dyld_info&lt;/code&gt; 命令列出可执行文件所有依赖的动态库：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ otool -L mainmain: libtest.dylib (compatibility version 0.0.0, current version 0.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1319.100.3)$ dyld_info -dependents mainmain [arm64]: -dependents: attributes load path libtest.dylib /usr/lib/libSystem.B.dylib&lt;/code&gt;&lt;/p&gt;&lt;p&gt;macOS 也提供了 rpath 的机制，在 &lt;code&gt;LC_LOAD_DYLIB&lt;/code&gt; 中指定 &lt;code&gt;@rpath&lt;/code&gt;，然后通过 &lt;code&gt;LC_RPATH&lt;/code&gt; 指定有哪些 rpath，那么动态链接器就可以根据可执行文件的相对路径去寻找动态库：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ objdump -p /Applications/Visual\ Studio\ Code.app/Contents/MacOS/ElectronLoad command 8 cmd LC_RPATH cmdsize 48 path @executable_path/../Frameworks (offset 12)Load command 13 cmd LC_LOAD_DYLIB cmdsize 80 name @rpath/Electron Framework.framework/Electron Framework (offset 24) time stamp 0 Thu Jan 1 08:00:00 1970 current version 22.5.2compatibility version 0.0.0Load command 14 cmd LC_LOAD_DYLIB cmdsize 56 name /usr/lib/libSystem.B.dylib (offset 24) time stamp 0 Thu Jan 1 08:00:00 1970 current version 1311.100.3$ otool -L /Applications/Visual\ Studio\ Code.app/Contents/MacOS/Electron/Applications/Visual Studio Code.app/Contents/MacOS/Electron: @rpath/Electron Framework.framework/Electron Framework (compatibility version 0.0.0, current version 22.5.2) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1311.100.3)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;也可以让 dyld 动态打印日志：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ export DYLD_PRINT_LIBRARIES=1$ ./maindyld[17486]: &amp;lt;F4E9A9E0-E958-3D0C-8D5A-7DC3ABA8E8C4&amp;gt; /Volumes/Data/temp/maindyld[17486]: &amp;lt;DD5E30FB-753D-3746-8034-50C56971C47B&amp;gt; /Volumes/Data/temp/libtest.dylibdyld[17486]: &amp;lt;4BEBCD61-9E62-39BE-BFD2-C7D0689A826D&amp;gt; /usr/lib/libSystem.B.dylibdyld[17486]: &amp;lt;FEA038BA-CC59-3085-93B0-AB8437AA6CE2&amp;gt; /usr/lib/system/libcache.dylibdyld[17486]: &amp;lt;34AC4B05-E145-3C58-8C24-1190770EAB31&amp;gt; /usr/lib/system/libcommonCrypto.dylibdyld[17486]: &amp;lt;1D6552C4-49C4-374F-8371-198BCFC4174D&amp;gt; /usr/lib/system/libcompiler_rt.dylibdyld[17486]: &amp;lt;E61C2838-9EA2-33CE-B96B-85FF38DB7744&amp;gt; /usr/lib/system/libcopyfile.dylibdyld[17486]: &amp;lt;4A9F9101-A1B1-3FB7-89EA-746CFCE95099&amp;gt; /usr/lib/system/libcorecrypto.dylibdyld[17486]: &amp;lt;C2FD3094-B465-39A4-B774-16583FF53C4B&amp;gt; /usr/lib/system/libdispatch.dylibdyld[17486]: &amp;lt;A2947B47-B494-36D4-96C6-95977FFB51FB&amp;gt; /usr/lib/system/libdyld.dylibdyld[17486]: &amp;lt;C4512BA5-7CA3-30AE-9793-5CC5417F0FC3&amp;gt; /usr/lib/system/libkeymgr.dylibdyld[17486]: &amp;lt;91A88FDF-FD27-32AF-A2CE-70F7E4065C3B&amp;gt; /usr/lib/system/libmacho.dylibdyld[17486]: &amp;lt;A2D17FF6-CBC6-3D19-89E1-F5E57191E8A3&amp;gt; /usr/lib/system/libquarantine.dylibdyld[17486]: &amp;lt;2213EE66-253B-3234-AA4D-B46F07C3540E&amp;gt; /usr/lib/system/libremovefile.dylibdyld[17486]: &amp;lt;68D76774-F8B4-36EA-AA35-0AB4044D56C7&amp;gt; /usr/lib/system/libsystem_asl.dylibdyld[17486]: &amp;lt;5541DF62-A795-3F57-A54C-1AEC4DD3E44C&amp;gt; /usr/lib/system/libsystem_blocks.dylibdyld[17486]: &amp;lt;95A70E20-1DF3-3DDF-900C-315ED0B2C067&amp;gt; /usr/lib/system/libsystem_c.dylibdyld[17486]: &amp;lt;BEB9DE52-6F49-370A-B45B-CBE6780E7083&amp;gt; /usr/lib/system/libsystem_collections.dylibdyld[17486]: &amp;lt;121F8B4D-3939-300D-BE22-979D6B476361&amp;gt; /usr/lib/system/libsystem_configuration.dylibdyld[17486]: &amp;lt;7CE9526A-B673-363A-8905-71D080974C0E&amp;gt; /usr/lib/system/libsystem_containermanager.dylibdyld[17486]: &amp;lt;54BF691A-0908-3548-95F2-34CFD58E5617&amp;gt; /usr/lib/system/libsystem_coreservices.dylibdyld[17486]: &amp;lt;579733C7-851D-3B3E-83B5-FD203BA50D02&amp;gt; /usr/lib/system/libsystem_darwin.dylibdyld[17486]: &amp;lt;4EFF0147-928F-3321-8268-655FE71DC209&amp;gt; /usr/lib/system/libsystem_dnssd.dylibdyld[17486]: &amp;lt;5068382F-DC0F-3824-8ED5-18A24B35FEF9&amp;gt; /usr/lib/system/libsystem_featureflags.dylibdyld[17486]: &amp;lt;4448FB99-7B1D-3E15-B7EE-3340FF0DA88D&amp;gt; /usr/lib/system/libsystem_info.dylibdyld[17486]: &amp;lt;82E529F5-C4DF-3D42-9113-3A4F87FEF1A0&amp;gt; /usr/lib/system/libsystem_m.dylibdyld[17486]: &amp;lt;0AC99C6E-CB01-30E5-AB10-65AB990652A5&amp;gt; /usr/lib/system/libsystem_malloc.dylibdyld[17486]: &amp;lt;3B2CC4A9-A5EE-3627-8293-4AF4D891074E&amp;gt; /usr/lib/system/libsystem_networkextension.dylibdyld[17486]: &amp;lt;E4AA6E5F-2501-3382-BFB3-64464E6D8254&amp;gt; /usr/lib/system/libsystem_notify.dylibdyld[17486]: &amp;lt;99FDEFF2-36F1-3436-B8B2-DE0003B5A4BF&amp;gt; /usr/lib/system/libsystem_sandbox.dylibdyld[17486]: &amp;lt;E529D1AC-D20A-3308-9033-E1712A9C655E&amp;gt; /usr/lib/system/libsystem_secinit.dylibdyld[17486]: &amp;lt;42F503E2-9273-360A-A086-C1B19BBD3962&amp;gt; /usr/lib/system/libsystem_kernel.dylibdyld[17486]: &amp;lt;F80C6971-C080-31F5-AB6E-BE01311154AF&amp;gt; /usr/lib/system/libsystem_platform.dylibdyld[17486]: &amp;lt;46D35233-A051-3F4F-BBA4-BA56DDDC4D1A&amp;gt; /usr/lib/system/libsystem_pthread.dylibdyld[17486]: &amp;lt;F9F1F4BE-D97F-37A7-8382-552C22DF1BB4&amp;gt; /usr/lib/system/libsystem_symptoms.dylibdyld[17486]: &amp;lt;3F3E75B7-F0A7-30BB-9FD7-FD1307FE6055&amp;gt; /usr/lib/system/libsystem_trace.dylibdyld[17486]: &amp;lt;E3BF7A76-2CBE-3DB9-8496-8BB6DBBE0CFC&amp;gt; /usr/lib/system/libunwind.dylibdyld[17486]: &amp;lt;F3F19227-FF8F-389C-A094-6F4C16E458AF&amp;gt; /usr/lib/system/libxpc.dylibdyld[17486]: &amp;lt;52AA13E2-567C-36C2-9494-7B892FDBF245&amp;gt; /usr/lib/libc++abi.dylibdyld[17486]: &amp;lt;5BEAFA2B-3AF4-3ED2-B054-1F58A7C851EF&amp;gt; /usr/lib/libobjc.A.dylibdyld[17486]: &amp;lt;FB664621-26AE-3F46-8F5A-DD5D890A5CE7&amp;gt; /usr/lib/liboah.dylibdyld[17486]: &amp;lt;54E8FBE1-DF0D-33A2-B8FA-356565C12929&amp;gt; /usr/lib/libc++.1.dylibSimple function&lt;/code&gt;&lt;/p&gt;&lt;p&gt;与 Linux 上的 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; 类似，macOS 也针对动态库的加载做了优化，但是 macOS 做的更彻底：由于 macOS 的系统库是只读的，于是直接把所有系统库打包成一个文件，这个文件就是 dyld shared cache。可以用 &lt;a href=&#34;https://github.com/keith/dyld-shared-cache-extractor&#34;&gt;keith/dyld-shared-cache-extractor&lt;/a&gt; 来还原出内部的 dylib。在 macOS Ventura 13.4 中，可以解出 2499 个动态库。&lt;/p&gt;&lt;h2&gt;relocation&lt;/h2&gt;&lt;p&gt;链接器找到符号以后，就需要进行 relocation。在编译的时候，为了准备未来链接时的需要，提前做了一些准备：因为符号的地址还不知道，所以生成一条指令，指令的立即数内包括了符号的地址的信息，但此时还不知道立即数应该是多少，所以编译器把指令的立即数填充为 0，同时生成一个 relocation。当链接器看到 relocation 的时候，在已经排好所有符号的地址的时候，就可以按照 relocation 更新代码。&lt;/p&gt;&lt;p&gt;由于动态链接库可能会被加载到不同的基地址上，所以为了解决动态链接库内部的符号链接问题，采用 PIC 的方法，即通过指令本身的地址进行相对运算，计算出另一个符号的地址。这样动态链接库加载到不同地址的时候，内部的符号之间都可以正常引用，不需要修改指令，使得动态库可以在不同的进程间共享。&lt;/p&gt;&lt;p&gt;但是还需要考虑动态链接库使用了其他动态链接库的符号（全局变量）。这个时候，PIC 的方法失效了，因为无法确定其他动态链接库会加载到什么地址。此时的解决办法是用 GOT，程序在引用符号的时候，去 GOT 里查找实际的地址。动态链接器负责填 GOT 表的内容，这样动态库本身还是不会修改，只会修改 GOT。&lt;/p&gt;&lt;p&gt;如果动态链接库调用了其他动态链接库的函数，也可以用类似的方法，但是实践起来稍有不同。函数也在 GOT 表的 PLT 表里有实际的地址，但动态链接库不会自动替换，而是让编译器生成一个 PLT stub。PLT stub 做的事情是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;如果初始化过，那么直接跳转到实际的函数&lt;/li&gt;&lt;li&gt;如果没有初始化过，调用 ld.so 提供的函数，函数会找到实际的函数，并且对 PLT 进行初始化&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这一系列的做法都是为了让动态库的大部分内容保持不变，只修改少部分数据使得 relocation 可以工作。完整的内容建议阅读&lt;a href=&#34;https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html&#34;&gt;PLT and GOT - the key to code sharing and dynamic libraries&lt;/a&gt;。&lt;/p&gt;&lt;h3&gt;relocation truncated to fit&lt;/h3&gt;&lt;p&gt;常见的 &lt;code&gt;relocation truncated to fit&lt;/code&gt; 错误的意思是，链接器在进行 relocation 的时候，无法把想要的值填入到编译器预留的立即数里面。这是因为，编译器在编译的时候，其实不知道偏移具体是多少，那么这时候就可以选择用不同的指令序列，有的指令序列比较短，但是立即数位数也比较少；有的指令序列比较长，但是可以访问更大范围的偏移。如果编译器选择了比较小的范围，但是链接器链接的时候，发现放不下，就会出现 &lt;code&gt;relocation truncated to fit&lt;/code&gt; 的错误。&lt;/p&gt;&lt;p&gt;解决方法，一是查看是否真的有那么大的偏移，例如是否不小心分配了一个超级大的全局数组，是的话是否砍掉一些大小；二是修改 Code Model，也就是让编译器选择更大的 Code Model，以更长的指令的代价，支持更大范围的 relocation。完整内容推荐阅读 &lt;a href=&#34;https://maskray.me/blog/2023-05-14-relocation-overflow-and-code-models&#34;&gt;Relocation overflow and code models by MaskRay&lt;/a&gt;。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linker/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linker/</guid> </item> <item> <title>How a Linux 6.2.13 BUG stops Vivado from recognizing FPGA</title> <category>linux</category> <category>software</category> <category>vivado</category> <description>&lt;h1&gt;How a Linux 6.2.13 BUG stops Vivado from recognizing FPGA&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;/software/2023/05/06/linux-regression-vivado/&#34;&gt;中文版本&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TLDR&lt;/h2&gt;&lt;p&gt;In short, the commit introduced by Linux 6.2.13:&lt;/p&gt;&lt;p&gt;```commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;While fixing a BUG, a new BUG is introduced, causing MAP_32BIT to fail to work sometimes, and Xilinx&#39;s Digilent driver uses this parameter, causing mmap to fail and unable to recognize the FPGA.&lt;/p&gt;&lt;h2&gt;Background&lt;/h2&gt;&lt;p&gt;The background is that after @vowstar upgraded the kernel to 6.2.14, he found that Vivado could not find the FPGA. But restarting and switching to 6.2.12, it works.&lt;/p&gt;&lt;h2&gt;Troubleshooting&lt;/h2&gt;&lt;p&gt;Because the kernel has been upgraded, the first reaction is whether it is a problem with the ftdi_sio driver. Comparing the dmesg logs of the two kernel versions, We found that Linux 6.2.12 will display &lt;code&gt;ftdi_sio: device disconnected&lt;/code&gt; message: this is because the FPGA programmer has a built-in FTDI chip, which supports multiple modes. By default, after the kernel detects the usb device, the ftdi_sio driver will initialize the FTDI chip to the serial port mode to create a &lt;code&gt;/dev/ttyUSB*&lt;/code&gt; device; and Vivado needs to use the MPSSE mode to communicate with the FPGA using the JTAG protocol. MPSSE mode conflicts with the serial port mode, so Vivado has to detach the kernel module so that it no longer occupies the USB device, and then let the FTDI chip enter MPSSE mode.&lt;/p&gt;&lt;p&gt;Following this line of thought, the first thing that comes to mind is the permission issue: by default, the USB device permissions are strict, so when Vivado is installed, it will install udev rules, to change the permissions of the usb device file of the Digilent programmer to 666, so that all users are allowed to access USB devices. But after checking, the device file permissions under /dev/bus/usb are correct:&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellkernel 6.2.12: crw-rw-rw- 1 root usb 189, 271 May 6 15:31 /dev/bus/usb/003/016kernel 6.2.14: crw-rw-rw- 1 root usb 189, 262 May 6 15:32 /dev/bus/usb/003/016&lt;/code&gt;&lt;/p&gt;&lt;p&gt;At this time, we feel very strange. Only the kernel has been updated, and nothing else has changed. Why is the behavior different? So we looked through the ChangeLog of the Linux kernel, because 6.2.12 is good, while 6.2.14 is not working, so you only need to look at the changelog between the two:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.13&#34;&gt;6.2.13&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.14&#34;&gt;6.2.14&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Searching for keywords such as ftdi or usb, only one commit seems to be related: &lt;code&gt;USB: serial: option: add UNISOC vendor and TOZED LT70C product&lt;/code&gt;, but after a closer look, it only adds a new VID/PID, and it has no conflict with Digilent programmer.&lt;/p&gt;&lt;p&gt;At this time, we feel that it is not a Linux problem. We continue to control the variables, by seeing if there is something wrong with the FTDI chip. At this time, OpenOCD was used to see if OpenOCD can configure the FTDI chip to enter MPSSE mode and find the FPGA. We tried it, it worked, ftdi_sio detached normally, and OpenOCD also found FPGA.&lt;/p&gt;&lt;p&gt;But at this time, when Vivado is opened again, the FPGA is still not found, indicating that it is not a problem in MPSSE mode. Considering that the process that Vivado accesses the hardware is hw_server, we wonder if we can look at the log of hw_server.&lt;/p&gt;&lt;p&gt;Run hw_server, printing all log types:&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ hw_server -L- -l alloc,eventcore,waitpid,events,protocol,context,children,discovery,asyncreq,proxy,tcflog,elf,stack,plugin,shutdown,disasm,jtag2,jtag,pcie,slave,dpc&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Here &lt;code&gt;-L-&lt;/code&gt; means to output the log to stderr, and the following &lt;code&gt;-l&lt;/code&gt; string of parameters are various log switches. It is ran on both kernels, and the difference is found by comparing the logs:&lt;/p&gt;&lt;p&gt;```shellSuccess (6.2.12):TCF 08:39:37.247: jtagpoll: add node 0xxxxxxxx(jsn-JTAG-SMT2NC-XXXXXXXXXXXX)TCF 08:39:37.247: Node 000000FF, added jsn-JTAG-SMT2NC-XXXXXXXXXXXX&lt;/p&gt;&lt;p&gt;Failed (6.2.14):TCF 08:45:12.385: jtagpoll: cannot get port description list: ftdidb_lock failed: FTDMGR wasn&#39;t properly initializedTCF 08:45:12.391: jtagpoll: cannot get port description list: JTAG device enumeration failed: Initialization of the DPCOMM library failed.```&lt;/p&gt;&lt;p&gt;Finally saw the error message: &lt;code&gt;jtagpoll: cannot get port description list: ftdidb_lock failed: FTDMGR wasn&#39;t properly initialized&lt;/code&gt;. Use it as a keyword to search, and sure enough, someone else has encountered the same problem:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://support.xilinx.com/s/article/000033531?language=en_US&#34;&gt;XSDB fails with &#34;ftdidb_lock failed: FTDMGR wasn&#39;t properly initialized&#34;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://blog.t123yh.xyz:2/index.php/archives/1013&#34;&gt;Linux 多用户环境下 Vivado 无法连接 Digilent JTAG 适配器的解决方法 (Solution to Vivado unable to connect to Digilent JTAG adapter in Linux multi-user environment)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We tried the solution from the first post, it didn&#39;t work. The problem pointed out in the second article is that in a multi-user environment, multiple users use the same file, and then there is a permission problem, so the file must be deleted. We tried the method in the second document, but it didn&#39;t solve the problem.&lt;/p&gt;&lt;p&gt;But the second article gives a debugging method: run the dadutil program provided by Digilent to see if it can recognize the programmer, and the problem reappears:&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ dadutil enumERROR: DmgrSetNetworkEnumTimeout failed, erc = 3090$ dadutil enumFound 1 device(s)$ dadutil enumFound 1 device(s)$ dadutil enumERROR: DmgrSetNetworkEnumTimeout failed, erc = 3090&lt;/code&gt;&lt;/p&gt;&lt;p&gt;We have tried many times here and found that there is a one-third probability of failure, but it is enough to explain why hw_server does not work: there is a high probability that it also calls the code provided by Digilent and gets the same result, so it fails.&lt;/p&gt;&lt;p&gt;The second article above used strace to find the problem, so we use strace to locate the error:&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ strace dadutil enumopenat(AT_FDCWD, &#34;/dev/shm/digilent-adept2-mtx-ftdmgr&#34;, O_RDWR|O_NOFOLLOW|O_CLOEXEC) = 7ftruncate(7, 4) = 0mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_32BIT, 7, 0) = -1 ENOMEM (Cannot allocate memory)close(7) = 0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The problem is that ENOMEM is returned, which is very strange, because &lt;code&gt;/dev/shm&lt;/code&gt; is a tmpfs, and there is still a lot of space, how can it return ENOMEM?&lt;/p&gt;&lt;h2&gt;Found the culprit&lt;/h2&gt;&lt;p&gt;Continue to research according to new clues: mmap returns an error that should not be returned, is that 6.2.13 or 6.2.14 introduced related changes? After checking, there are really:&lt;/p&gt;&lt;p&gt;```diff&lt;/p&gt;&lt;h1&gt;https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.13&lt;/h1&gt;&lt;p&gt;commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;It is related to mmap, click on the &lt;a href=&#34;https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.com&#34;&gt;email link&lt;/a&gt; to have a look, and found that this commit was proposed to fix a BUG, but introduced a new BUG:&lt;/p&gt;&lt;p&gt;&lt;code&gt;``* Re: [PATCH v2] mm/mmap: Regression fix for unmapped_area{_topdown} 2023-04-14 18:59&lt;/code&gt; [PATCH v2] &#34; Liam R. Howlett 2023-04-14 19:09 &lt;code&gt;Andrew Morton@ 2023-04-29 14:32&lt;/code&gt; Tad 2023-04-30 22:41 ` Michael Keyes 1 sibling, 1 reply; 18+ messages in threadFrom: Tad @ 2023-04-29 14:32 UTC (permalink / raw) To: liam.howlett; +Cc: akpm, linux-kernel, linux-mm, rick.p.edgecombe&lt;/p&gt;&lt;p&gt;This reintroduces the issue described inhttps://lore.kernel.org/linux-mm/cb8dc31a-fef2-1d09-f133-e9f7b9f9e77a@sony.com/&lt;/p&gt;&lt;p&gt;Linux 6.2.13 can no longer successfully run the mmap-test reproducer linkedthere.&lt;/p&gt;&lt;p&gt;Linux 6.2.12 passes.&lt;/p&gt;&lt;p&gt;Regards,Tad.```&lt;/p&gt;&lt;p&gt;Continue to follow the above &lt;a href=&#34;https://lore.kernel.org/linux-mm/cb8dc31a-fef2-1d09-f133-e9f7b9f9e77a@sony.com/&#34;&gt;link&lt;/a&gt;, and you can see that in the error log inside, there is also a similar mmap call:&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0) = 0x40720000mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0) = 0x4124e000mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0) = -1 ENOMEM (Cannot allocate memory)dex2oatd F 03-01 10:32:33 74063 74063 mem_map_arena_pool.cc:65] Check failed: map.IsValid() Failed anonymous mmap((nil), 131072, 0x3, 0x22, -1, 0): Cannot allocate memory. See process maps in the log.```&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Look at the mmap log reported above by &lt;code&gt;dadutil enum&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellmmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_32BIT, 7, 0) = -1 ENOMEM (Cannot allocate memory)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;The parameter also contains MAP_32BIT, and the result is also ENOMEM. Combined with other discussions on the mailing list, it can be basically confirmed that the author ignored the situation of MAP_32BIT, and the BUG is introduced by the commit.&lt;/p&gt;&lt;p&gt;After reverting the commit from Linux 6.2.14, the problem is gone.&lt;/p&gt;&lt;h2&gt;Summary&lt;/h2&gt;&lt;p&gt;This is the whole debugging process. From the fact that Vivado can&#39;t find the FPGA, to the internal Linux kernel BUG, they seem irrelevant, but we can find the connection behind the scene.&lt;/p&gt;&lt;p&gt;I went through the whole debugging process with @vowstar and learned a lot, hence the blog post.&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linux-regression-vivado-en/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linux-regression-vivado-en/</guid> </item> <item> <title>Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA</title> <category>linux</category> <category>software</category> <category>vivado</category> <description>&lt;h1&gt;Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;/software/2023/05/06/linux-regression-vivado-en/&#34;&gt;English version&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TLDR&lt;/h2&gt;&lt;p&gt;简单来说，Linux 6.2.13 引入的 commit：&lt;/p&gt;&lt;p&gt;```commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;修复了 BUG 的同时，引入了新的 BUG，导致 MAP_32BIT 有时无法工作，而 Xilinx 的 Digilent 下载器代码使用了这个参数，导致 mmap 失败，无法识别 FPGA。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;事情的背景是，@vowstar 升级内核到 6.2.14 以后，发现 Vivado 找不到 FPGA 了，重启回到 6.2.12 就好了。&lt;/p&gt;&lt;h2&gt;排查&lt;/h2&gt;&lt;p&gt;因为升级了内核，第一反应是不是 ftdi_sio 驱动的问题。比对了一下二者的 dmesg 日志，发现 Linux 6.2.12 会显示 &lt;code&gt;ftdi_sio: device disconnected&lt;/code&gt; 消息：这是因为 FPGA 下载器内置的是 FTDI 芯片，它支持多种模式，默认情况下，内核检测到设备以后，会由 ftdi_sio 驱动初始化为串口模式，创建 &lt;code&gt;/dev/ttyUSB*&lt;/code&gt; 设备；而 Vivado 需要用的是 MPSSE 模式，从而使用 JTAG 协议与 FPGA 通讯。这与串口模式冲突，因此 Vivado 要做的事情，首先是把内核模块 detach，也就是不再占用 USB 设备，然后再让 FTDI 芯片进入 MPSSE 模式。&lt;/p&gt;&lt;p&gt;沿着这个思路，首先想到的是权限问题：默认情况下，USB 设备权限比较严格，所以 Vivado 在安装的时候，会安装 udev rule，把 Digilent 下载器的 usb 设备文件的权限改为 666，这样就允许所有用户访问 USB 设备。但是检查了一下，/dev/bus/usb 下的设备文件权限是正确的：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellkernel 6.2.12: crw-rw-rw- 1 root usb 189, 271 May 6 15:31 /dev/bus/usb/003/016kernel 6.2.14: crw-rw-rw- 1 root usb 189, 262 May 6 15:32 /dev/bus/usb/003/016&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这时候就觉得很蹊跷，只更新了内核，其他都没有变，为什么行为就会不同。于是翻了翻 Linux 内核的 ChangeLog，因为 6.2.12 是好的，6.2.14 是不工作的，所以只需要看两者之间的 changelog：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.13&#34;&gt;6.2.13&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.14&#34;&gt;6.2.14&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以 ftdi 或 usb 为关键词搜索，只有一个看起来有一些相关的 commit：&lt;code&gt;USB: serial: option: add UNISOC vendor and TOZED LT70C product&lt;/code&gt;，但是仔细一看，只是添加了新的 VID/PID，也没有和 Digilent 下载器冲突。&lt;/p&gt;&lt;p&gt;这时候，就觉得不是 Linux 的问题了。按照这个思路，继续控制变量法，看看是不是 FTDI 芯片出了问题。这时候就祭出了 OpenOCD，看看 OpenOCD 能否配置 FTDI 芯片进入 MPSSE 模式，并且找到 FPGA。试了一下，还真可以，ftdi_sio 正常 detach，然后 OpenOCD 也找到 FPGA 了。&lt;/p&gt;&lt;p&gt;但此时再打开 Vivado，还是找不到设备，说明不是 MPSSE 模式的问题。考虑到 Vivado 访问硬件的进程是 hw_server，想到能不能看看 hw_server 的日志。&lt;/p&gt;&lt;p&gt;运行 hw_server，打印所有日志类型：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ hw_server -L- -l alloc,eventcore,waitpid,events,protocol,context,children,discovery,asyncreq,proxy,tcflog,elf,stack,plugin,shutdown,disasm,jtag2,jtag,pcie,slave,dpc&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这里 &lt;code&gt;-L-&lt;/code&gt; 表示输出日志到 stderr，后面的 &lt;code&gt;-l&lt;/code&gt; 一串参数就是各种日志开关。在两个内核里都运行一次，比对日志，发现了不同：&lt;/p&gt;&lt;p&gt;```shellSuccess (6.2.12):TCF 08:39:37.247: jtagpoll: add node 0xxxxxxxx(jsn-JTAG-SMT2NC-XXXXXXXXXXXX)TCF 08:39:37.247: Node 000000FF, added jsn-JTAG-SMT2NC-XXXXXXXXXXXX&lt;/p&gt;&lt;p&gt;Failed (6.2.14):TCF 08:45:12.385: jtagpoll: cannot get port description list: ftdidb_lock failed: FTDMGR wasn&#39;t properly initializedTCF 08:45:12.391: jtagpoll: cannot get port description list: JTAG device enumeration failed: Initialization of the DPCOMM library failed.```&lt;/p&gt;&lt;p&gt;终于看到了错误信息：&lt;code&gt;jtagpoll: cannot get port description list: ftdidb_lock failed: FTDMGR wasn&#39;t properly initialized&lt;/code&gt;。把这个作为关键词一搜索，果然有别人也遇到了同样的问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://support.xilinx.com/s/article/000033531?language=en_US&#34;&gt;XSDB fails with &#34;ftdidb_lock failed: FTDMGR wasn&#39;t properly initialized&#34;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://blog.t123yh.xyz:2/index.php/archives/1013&#34;&gt;Linux 多用户环境下 Vivado 无法连接 Digilent JTAG 适配器的解决方法&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;尝试了第一篇文章的解决方案，没有效果。第二篇文章指出的问题是，多用户环境下，多个用户抢同一个文件，然后出现权限问题，所以要删掉文件再启动。按照第二篇文档的方法尝试了一下，也没有解决问题。&lt;/p&gt;&lt;p&gt;但是第二篇文章给出了一个调试方法：运行 Digilent 提供的 dadutil 程序，看看它是否可以识别下载器，果然复现出问题了：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ dadutil enumERROR: DmgrSetNetworkEnumTimeout failed, erc = 3090$ dadutil enumFound 1 device(s)$ dadutil enumFound 1 device(s)$ dadutil enumERROR: DmgrSetNetworkEnumTimeout failed, erc = 3090&lt;/code&gt;&lt;/p&gt;&lt;p&gt;到这里多次尝试，发现有三分之一的概率会失败，但已经足够解释为什么 hw_server 不工作了：大概率它也调用了 Digilent 提供的代码，得到了同样的结果，所以失败了。&lt;/p&gt;&lt;p&gt;上面第二篇文章用 strace 的方法找到了问题，照葫芦画瓢，用 strace 找到出错的日志：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ strace dadutil enumopenat(AT_FDCWD, &#34;/dev/shm/digilent-adept2-mtx-ftdmgr&#34;, O_RDWR|O_NOFOLLOW|O_CLOEXEC) = 7ftruncate(7, 4) = 0mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_32BIT, 7, 0) = -1 ENOMEM (Cannot allocate memory)close(7) = 0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;可以发现问题是返回了 ENOMEM，这就很奇怪了，&lt;code&gt;/dev/shm&lt;/code&gt; 是个 tmpfs，还有很多空间，怎么会返回 ENOMEM 呢？&lt;/p&gt;&lt;h2&gt;柳暗花明又一村&lt;/h2&gt;&lt;p&gt;按照新线索继续研究：mmap 返回了不应该返回的错误，那是不是 6.2.13 或 6.2.14 引入了相关改动呢？一查，还真有：&lt;/p&gt;&lt;p&gt;```diff&lt;/p&gt;&lt;h1&gt;https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.13&lt;/h1&gt;&lt;p&gt;commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;和 mmap 相关，点进&lt;a href=&#34;https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.com&#34;&gt;邮件链接&lt;/a&gt;看看，发现有人提出这个 commit 虽然修复了一个 BUG，但是引入了新的 BUG：&lt;/p&gt;&lt;p&gt;&lt;code&gt;``* Re: [PATCH v2] mm/mmap: Regression fix for unmapped_area{_topdown} 2023-04-14 18:59&lt;/code&gt; [PATCH v2] &#34; Liam R. Howlett 2023-04-14 19:09 &lt;code&gt;Andrew Morton@ 2023-04-29 14:32&lt;/code&gt; Tad 2023-04-30 22:41 ` Michael Keyes 1 sibling, 1 reply; 18+ messages in threadFrom: Tad @ 2023-04-29 14:32 UTC (permalink / raw) To: liam.howlett; +Cc: akpm, linux-kernel, linux-mm, rick.p.edgecombe&lt;/p&gt;&lt;p&gt;This reintroduces the issue described inhttps://lore.kernel.org/linux-mm/cb8dc31a-fef2-1d09-f133-e9f7b9f9e77a@sony.com/&lt;/p&gt;&lt;p&gt;Linux 6.2.13 can no longer successfully run the mmap-test reproducer linkedthere.&lt;/p&gt;&lt;p&gt;Linux 6.2.12 passes.&lt;/p&gt;&lt;p&gt;Regards,Tad.```&lt;/p&gt;&lt;p&gt;再继续跟踪上面的&lt;a href=&#34;https://lore.kernel.org/linux-mm/cb8dc31a-fef2-1d09-f133-e9f7b9f9e77a@sony.com/&#34;&gt;链接&lt;/a&gt;，赫然看到里面的错误日志里，也出现了类似的 mmap 调用：&lt;/p&gt;&lt;p&gt;```shell&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0) = 0x40720000mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0) = 0x4124e000mmap(NULL, 131072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_32BIT, -1, 0) = -1 ENOMEM (Cannot allocate memory)dex2oatd F 03-01 10:32:33 74063 74063 mem_map_arena_pool.cc:65] Check failed: map.IsValid() Failed anonymous mmap((nil), 131072, 0x3, 0x22, -1, 0): Cannot allocate memory. See process maps in the log.```&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;再看看上面 &lt;code&gt;dadutil enum&lt;/code&gt; 报错的 mmap 日志：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellmmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_32BIT, 7, 0) = -1 ENOMEM (Cannot allocate memory)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;赫然也是 MAP_32BIT，结果也是 ENOMEM，那说明就是这个问题了。结合邮件列表的其他讨论，基本可以确认是作者忽略了 MAP_32BIT 的情况，所以出现了问题。&lt;/p&gt;&lt;p&gt;从 Linux 6.2.14 回滚出问题的 commit 以后，问题解决了。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;这就是整个 Debug 流程，从 Vivado 找不到 FPGA 的表象，到内在的 Linux 内核 BUG，看起来毫不相关，但却能发现背后的逻辑。&lt;/p&gt;&lt;p&gt;我和 @vowstar 一起完成了整个调试的流程，学到了许多，因此写了这篇博客。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linux-regression-vivado/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linux-regression-vivado/</guid> </item> <item> <title>I2C 协议</title> <category>hardware</category> <category>i2c</category> <description>&lt;h1&gt;I2C 协议&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/hardware/i2c.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近数设课上，同学们开始购买外设，其中就涉及到 I2C 协议，因此顺带写一下 I2C 协议的教程，帮助同学们进行理解。&lt;/p&gt;&lt;h2&gt;接口&lt;/h2&gt;&lt;p&gt;I2C 协议涉及到两个信号：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SCL: 时钟信号，Master -&amp;gt; Slave&lt;/li&gt;&lt;li&gt;SDA：数据信号，Master &amp;lt;-&amp;gt; Slave&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于只有一个数据信号，所以 SDA 由 Master 和 Slave 轮流输出。一次请求的开始条件是，SDA 从 1 变成 0，之后 SCL 从 1 变成 0。开始请求以后，每次 SCL 上升沿采样一位的数据。请求结束时，SCL 从 0 变成 1，然后 SDA 从 0 变成 1。一次请求的波形如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;scl&#34;, wave: &#34;1.0101010|.101...&#34;}, { name: &#34;sda&#34;, wave: &#34;10....1..|0....1.&#34;}, { name: &#34;i2c&#34;, wave: &#34;34.5.....|6.7....&#34;, data: [&#34;idle&#34;, &#34;start&#34;, &#34;data&#34;, &#34;ack&#34;, &#34;stop&#34;]}, ]}&lt;/code&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;idle 阶段，scl 和 sda 都是 1&lt;/li&gt;&lt;li&gt;start 阶段，首先是 sda 变成 0，之后是 scl 变成 0&lt;/li&gt;&lt;li&gt;data/ack 阶段，在 scl 上升沿采样数据，在 scl 下降沿（准确来说，负半周期）修改数据&lt;/li&gt;&lt;li&gt;stop 阶段，首先是 scl 变成 1，之后是 sda 变成 1&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;传输数据的时候，需要保证 sda 在 scl 正半周期的时候保持不变。如果变了，那就是 start 或者 stop。因此，在 data/ack 阶段，建议 sda 的变化相比 scl 下降沿有一个延迟（Hold Time，一般的要求是 Min 0us）。实现方法可能是在分频的时候，延迟一个周期。&lt;/p&gt;&lt;p&gt;这里的 data/ack 指的则是传输的具体内容：例如 master 要传输 7 位的地址和 1 位的读使能，响应地址的 slave 要返回 ack；之后，无论是 master 还是 slave 发送数据，接收的一方都要返回 ack。ack 是低有效，意味着 0 表示成功，1 表示失败。&lt;/p&gt;&lt;p&gt;由于 sda 带有上拉电阻，所以如果没有 slave 响应，ack 阶段的 sda 就会变成 1，意味着失败。&lt;/p&gt;&lt;h2&gt;I2C 控制器实现&lt;/h2&gt;&lt;p&gt;结合上面的 I2C 波形，可以设计一个状态机：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;INIT 状态：初始情况下，SCL 和 SDA 都为 1，要发送数据的时候，转移到 START1 状态&lt;/li&gt;&lt;li&gt;START1 状态：设置 SDA=0，当达到分频条件时，转移到 START2 状态&lt;/li&gt;&lt;li&gt;START2 状态：设置 SCL=0，当达到分频条件时，START 发送完成，转移到 SEND 状态&lt;/li&gt;&lt;li&gt;SEND 状态：当达到分频条件时，SCL 取反，如果 SCL 要从 1 变成 0，延迟一个周期，再输出 1 位的数据到 SDA 上，保证 SDA 的变化在 SCL 的负半周期；同时统计传输位数，每传输 8 位，就要等待一个周期让 Slave 响应 ACK，此时要设置 inout 输出为高阻态；如果要转换传输方向，即 Master 要读取数据，那么转移到 RECV 状态；如果传输结束，转移到 STOP1 状态&lt;/li&gt;&lt;li&gt;RECV 状态：当达到分频条件时，SCL 取反，如果 SCL 从 0 变成 1，对 SDA 进行采样并且保存下来；同时统计传输位数，每传输 8 位，就要在 SDA 输出一次 ACK；如果传输结束，转移到 STOP1 状态&lt;/li&gt;&lt;li&gt;STOP1 状态：设置 SCL=1，当达到分频条件时，转移到 STOP2 状态&lt;/li&gt;&lt;li&gt;STOP2 状态：设置 SDA=1，当达到分频条件时，转移到 INIT 状态&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;分频是因为一般 I2C 的频率比较低，是 kHz 的量级。需要按照控制逻辑的主频，结合外设能接受的 I2C 频率范围，计算出分频的倍数。&lt;/p&gt;&lt;h2&gt;上层协议&lt;/h2&gt;&lt;p&gt;在此基础上，可以设计上层协议，例如 &lt;a href=&#34;http://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/WolfsonWM8731.pdf&#34;&gt;WM8731&lt;/a&gt;，支持通过 I2C 写入内部寄存器，一次写操作分为以下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;start&lt;/li&gt;&lt;li&gt;master 发送 7 位的设备地址和 0（表示写），slave 发送 ack&lt;/li&gt;&lt;li&gt;master 发送 7 位的寄存器地址 和 1 位的寄存器数据，slave 发送 ack&lt;/li&gt;&lt;li&gt;master 发送 8 位的寄存器数据，slave 发送 ack&lt;/li&gt;&lt;li&gt;stop&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里的第二步发送的 7 位地址 + 读/写位是标准的，I2C Slave 都会根据 7 位地址来决定是否由自己来响应。此后的数据的定义，则是各个芯片按照各自的协议来进行。&lt;/p&gt;&lt;p&gt;为了让多个同型号 I2C 芯片可以同时使用，通常芯片提供了一些引脚来配置它的地址，那么在设计的时候，给不同的芯片设置不同的地址，就解决了地址冲突的问题。&lt;/p&gt;&lt;h2&gt;I2C EEPROM&lt;/h2&gt;&lt;p&gt;以 &lt;a href=&#34;https://ww1.microchip.com/downloads/en/devicedoc/doc0336.pdf&#34;&gt;AT24C32/AT24C64&lt;/a&gt; 为例，它提供了一个 I2C 接口的 EEPROM，支持如下操作：&lt;/p&gt;&lt;p&gt;写入数据：start，7 位设备地址，W，ACK；写入地址的高 8 位，ack；写入地址的低 8 位，ack；数据的每个字节，ack；最终 stop。&lt;/p&gt;&lt;p&gt;读取数据：start，7 位设备地址，W，ack；读取地址的高 8 位，ack；读取地址的低 8 位，ack；start，7 位设备地址，R，ack；数据的每个字节，ack；最终不想读的时候 nack，stop。&lt;/p&gt;&lt;p&gt;可以看到，这里设计成写操作的时候，只有 Master 到 Slave 的数据传输，反过来读操作的时候，只有 Slave 到 Master 的数据传输。因此，为了传输读取的地址，要首先“写入”读取的地址，再进行一次读操作，把数据读出来。&lt;/p&gt;&lt;h2&gt;I2C Audio Codec&lt;/h2&gt;&lt;p&gt;上面的例子中的 &lt;a href=&#34;http://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/WolfsonWM8731.pdf&#34;&gt;WM8731&lt;/a&gt; 实际上就是一个 Audio Codec，可以通过 I2C 对其寄存器进行写入。WM8731 的寄存器地址有 9 位，每个寄存器有 8 位的数据，因此写入流程是：start，7 位设备地址，W，ack；7 位寄存器地址，1 位寄存器数据，ack；8 位寄存器数据，ack；stop。&lt;/p&gt;&lt;h2&gt;I2C Sensor&lt;/h2&gt;&lt;p&gt;举一个传感器的例子：&lt;a href=&#34;https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/docs/datasheet/unit/gesture/paj7620u2_datasheet.pdf&#34;&gt;PAJ7620U2: Integrated Gesture Recognition Sensor &lt;/a&gt;，它也提供了一个寄存器读写的接口，支持如下操作：&lt;/p&gt;&lt;p&gt;单次写入：start，7 位设备地址，W，ack；8 位地址，ack；8 位数据，ack；stop。&lt;/p&gt;&lt;p&gt;单次读取：start，7 位设备地址，W，ack；8 位地址，ack；stop；start，7 位设备地址，R，ack；8 位数据，nack；stop。这里的读取也拆成了两步：第一步“写入”读取的地址，第二步读取出数据。最后的 nack 表示 master 不需要读取更多的数据。&lt;/p&gt;&lt;p&gt;如果要批量读取的话，只要在单次读取的基础上，读取数据的时候发 ack，等到不需要继续读的时候再发 nack，就可以连续读取多个寄存器的数据。&lt;/p&gt;&lt;p&gt;这些命令格式和上面的 I2C EEPROM 基本是一样的。&lt;/p&gt;&lt;p&gt;颜色传感器 &lt;a href=&#34;https://cdn-shop.adafruit.com/datasheets/TCS34725.pdf&#34;&gt;TCS3472&lt;/a&gt; 的命令格式也是类似的。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/05/03/i2c/</link> <pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/05/03/i2c/</guid> </item> <item> <title>SPI 协议</title> <category>hardware</category> <category>spi</category> <description>&lt;h1&gt;SPI 协议&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/hardware/spi.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近数设课上，同学们开始购买外设，其中就涉及到 SPI 协议，因此顺带写一下 SPI 协议的教程，帮助同学们进行理解。&lt;/p&gt;&lt;h2&gt;接口&lt;/h2&gt;&lt;p&gt;SPI 协议涉及到四个信号：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SCLK: 时钟信号，Master -&amp;gt; Slave&lt;/li&gt;&lt;li&gt;MOSI：数据信号，Master -&amp;gt; Slave&lt;/li&gt;&lt;li&gt;MISO：数据信号，Slave -&amp;gt; Master&lt;/li&gt;&lt;li&gt;CS：芯片使能，一般是低有效&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;要通过 SPI 协议发送命令的时候，通常需要先拉低 CS，然后启动 SCLK 时钟，同时收发数据。注意 SPI 是全双工的，也就是发送的同时也在接收，只不过通常来说，外设等到主机发送了命令本身，才知道要回复什么，所以很多时候命令设计成了事实上的半双工：前半部分主机在发命令，外设发送无用的数据；后半部分外设在发送响应，主机发送无用的数据。&lt;/p&gt;&lt;h2&gt;波形&lt;/h2&gt;&lt;p&gt;SPI 有不同的类型，下面讲一种比较常见的配置（即 CPOL=0，CPHA=0），在这种模式下，Master 和 Slave 都是在时钟的下降沿修改输出的数据，然后在时钟（&lt;code&gt;sclk&lt;/code&gt;）的上升沿对接收到的数据进行采样：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;clk&#34;, wave: &#34;p........&#34;}, { name: &#34;sclk&#34;, wave: &#34;0.101010.&#34;}, { name: &#34;mosi&#34;, wave: &#34;03.4.5.x.&#34;}, { name: &#34;miso&#34;, wave: &#34;06.7.8.x.&#34;}, { name: &#34;cs_n&#34;, wave: &#34;10......1&#34;}, ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;波形图中，时钟（&lt;code&gt;sclk&lt;/code&gt;）上升沿时，数据处于稳定的状态，所以此时 Master 对 MISO 采样，Slave 对 MOSI 采样，可以得到稳定的数据；时钟下降沿时，Master 和 Slave 修改输出的数据。&lt;/p&gt;&lt;p&gt;实际在 RTL 中实现的时候，Master 可以不写 negedge 逻辑，而是写一个分频器，在分频出来的负半周期里，实现数据的修改，如上图中的 &lt;code&gt;clk&lt;/code&gt; 分频到 &lt;code&gt;sclk&lt;/code&gt;。一般使用一个状态机来实现 SPI Master，记录当前传输到哪一个 bit，以及记录当前是 &lt;code&gt;sclk&lt;/code&gt; 的正半周期还是负半周期。&lt;/p&gt;&lt;p&gt;SPI 本身很简单，所以核心不在 SPI，而是在 SPI 之上定义的各种协议。&lt;/p&gt;&lt;h2&gt;SPI Flash&lt;/h2&gt;&lt;p&gt;SPI Flash 是一种很常见的 SPI 外设，可以用来访问 NAND/NOR Flash。&lt;/p&gt;&lt;p&gt;为了提升性能，很多 SPI Flash 还会提供 Dual SPI 和 Quad SPI 模式。标准的 SPI 中，Master 到 Slave 和 Slave 到 Master 分别是一根信号线，如果要继续提高性能，那就要引入更多的信号线来进行数据传输，所以 Dual SPI 就是让原来的 MISO 和 MOSI 都可以同时发送数据；Quad SPI 则是又额外添加了两个信号线来进行数据传输。&lt;/p&gt;&lt;p&gt;常见的 SPI Flash 厂家：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Spansion -&amp;gt; Cypress -&amp;gt; Infineon&lt;/li&gt;&lt;li&gt;Numonyx -&amp;gt; Micron&lt;/li&gt;&lt;li&gt;Winbond&lt;/li&gt;&lt;li&gt;GigaDevice&lt;/li&gt;&lt;li&gt;Macronix&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;SPI NAND Flash&lt;/h3&gt;&lt;p&gt;下面以 &lt;a href=&#34;https://www.alliancememory.com/wp-content/uploads/pdf/flash/AllianceMemory_SPI_NAND_Flash_July2020_Rev1.0.pdf&#34;&gt;Alliance Memory SPI NAND Flash Datasheet&lt;/a&gt; 为例子，看看通常 SPI Flash 都支持哪些命令，都是如何传输数据的。&lt;/p&gt;&lt;p&gt;这款 SPI NAND Flash 的内部存储分为三层：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Block：数量不定&lt;/li&gt;&lt;li&gt;Page：每个 Block 包括 64 个 Page&lt;/li&gt;&lt;li&gt;Byte：每个 Page 包括一定数量的 Byte，常见的有 2112(2048+64)、2176(2048+128)、4352(4096+256)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;NAND Flash 的读取粒度是 Page，这就是为什么 NAND Flash 更像块设备。一次读取过程分为三个步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;发送 13H(Page Read to Cache) 命令，把一个 Page 的数据读取到 NAND Flash 内部的 Cache 中&lt;/li&gt;&lt;li&gt;不断发送 0FH(Get Feature) 命令，直到 NAND Flash 表示 Page Read to Cache 命令完成&lt;/li&gt;&lt;li&gt;发送 Read from Cache 命令，考虑到传输的方式不同，有以下几种：&lt;ol&gt;&lt;li&gt;Read from Cache x1 IO(03H/0BH): Master 给出 1 字节命令，2 字节地址和 1 字节 dummy 数据，共 8(COMMAND)+16(ADDR)+8(DUMMY) 个周期，之后 Slave 从 MISO 给出数据&lt;/li&gt;&lt;li&gt;Read from Cache x2 IO(3BH): Slave 同时通过 MISO 和 MOSI 给出数据&lt;/li&gt;&lt;li&gt;Read from Cache x4 IO(6BH): Slave 同时通过 MISO、MOSI、WP# 和 HOLD# 给出数据&lt;/li&gt;&lt;li&gt;Read from Cache Dual IO(BBH): 在 3BH 的基础上，Master 也同时通过 MISO 和 MOSI 给出地址和 dummy 字节，所以 Master 只占用 8(COMMAND)+8(ADDR)+4(DUMMY) 个周期的时间发送&lt;/li&gt;&lt;li&gt;Read from Cache Quad IO(EBH): 在 6BH 的基础上，Master 也同时通过四个数据信号给出地址和 dummy 字节，所以 Master 只占用 8(COMMAND)+4(ADDR)+2(DUMMY) 个周期的时间发送&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;写入的时候，由于 NAND Flash 的特性，首先需要擦除，把一个 Block 的内容全部擦除，需要注意每个 Block 包括多个 Page，所以擦除的粒度是很粗的。擦除过的 Page 才可以进行写入，具体步骤是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;发送 06H(Write Enable) 允许写入&lt;/li&gt;&lt;li&gt;发送 02H(Program Load) 或 32H(Program Load x4) 把要写入的数据传输给 NAND Flash 中的 Cache；02H 和 32H 的区别就是后者同时在四个信号线上传输数据&lt;/li&gt;&lt;li&gt;发送 10H(Program Execute) 进行实际的写入操作，从 Cache 到 Flash 存储&lt;/li&gt;&lt;li&gt;不断发送 0FH(Get Feature) 命令，直到 Program Execute 操作完成&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;SPI NOR Flash&lt;/h3&gt;&lt;p&gt;NOR Flash 和 NAND Flash 的区别在于，NOR Flash 可以随机访问，可以提供 XIP 支持。下面以 &lt;a href=&#34;https://www.micron.com/-/media/client/global/documents/products/data-sheet/nor-flash/serial-nor/n25q/n25q_128mb_3v_65nm.pdf&#34;&gt;128Mb, 3V, Multiple I/O Serial Flash Memory&lt;/a&gt; 为例子看看它是如何读写的。&lt;/p&gt;&lt;p&gt;SPI NOR Flash 读取的时候，只需要一条命令就可以了：READ/FAST READ。其中 READ 命令比较简单：发送 Command，发送地址，然后 Slave 紧接着就会发送数据；FAST READ 可以达到更高的频率，但是为了让 NOR Flash 有时间读取数据，在 Master 发送 Command 和地址后，还需要发送 Dummy cycles，然后 Slave 才会发送数据。和前面一样，FAST READ 也支持不同的 IO 类型，例如 Dual Output，Dual Input/Output，Quad Output，Quad Input/Output。一些比较高端的 SPI NOR Flash 还支持 DTR（Double Transfer Rate），实际上就是 DDR，在时钟上升沿和下降沿都采样数据。&lt;/p&gt;&lt;p&gt;写入的时候，和 NAND Flash 一样，也需要先擦除，再写入。SPI Flash 的存储层级是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Sector&lt;/li&gt;&lt;li&gt;Subsector&lt;/li&gt;&lt;li&gt;Page&lt;/li&gt;&lt;li&gt;Byte&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;擦除的粒度是 Sector 或者 Subsector，写入的粒度是 Page。写入的时候，也需要首先发送 WRITE ENABLE 命令，再发送 PAGE PROGRAM 命令。NOR Flash 在 Program 上也比较简化，直接 Program 即可，不需要先写入到 Cache，再进行 Program。&lt;/p&gt;&lt;p&gt;NOR Flash 还提供了 XIP Mode 来加快随机访问：启用 XIP 模式后，给出一个地址，等待 Dummy cycles 后，就可以读出数据，不需要像前面那样发送 COMMAND，减少了延迟。当然了，即使不打开 NOR Flash 的 XIP Mode，也可以在 SPI 控制器里实现 XIP，只不过每次读取都要发一次 READ 命令。&lt;/p&gt;&lt;h2&gt;SPI EEPROM&lt;/h2&gt;&lt;p&gt;SPI EEPROM 和 SPI NOR Flash 比较类似，但是 EEPROM 更小，也更加简单，例如写入的时候，不需要擦除。感兴趣的可以在 &lt;a href=&#34;http://ww1.microchip.com/downloads/en/DeviceDoc/22040c_cn.pdf&#34;&gt;SPI 串行 EEPROM 系列数据手册&lt;/a&gt; 中查看命令列表，这里就不赘述了。&lt;/p&gt;&lt;h2&gt;SD 卡&lt;/h2&gt;&lt;p&gt;SD 卡除了 SD Bus 以外，还支持 SPI 模式（最新的 SDUC 不支持 SPI 模式），所以也可以用 SPI 来读写 SD 卡。&lt;/p&gt;&lt;p&gt;SD 卡比较特别的一点是，它需要比较复杂的初始化流程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;首先要发送 CMD0 命令，同时 CS 拉低，使得 SD 卡进入 SPI 模式&lt;/li&gt;&lt;li&gt;对于 SDHC SD 卡，需要发送 CMD8 来协商工作电压范围&lt;/li&gt;&lt;li&gt;重复发送 ACMD41 命令（CMD55 + CMD41 = ACMD41）进行初始化，直到 SD 卡回复初始化完成&lt;/li&gt;&lt;li&gt;发送 CMD58 命令以读取 OCR 寄存器的值&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;比较有意思的是命令的传输方式。每个命令有一个 6 位的命令编号，例如 CMD0 的编号就是 0，CMD55 的编号就是 55；还带有四字节的参数。每个命令会组装成一个 48 位的分组：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;bit[47]=0: Start Bit&lt;/li&gt;&lt;li&gt;bit[46]=1: Transmission Bit&lt;/li&gt;&lt;li&gt;bit[45:40]: Command Index&lt;/li&gt;&lt;li&gt;bit[39:8]: Argument&lt;/li&gt;&lt;li&gt;bit[7:1]: CRC7&lt;/li&gt;&lt;li&gt;bit[0]=1: End Bit&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;可见额外多了一个 CRC7 的校验和。&lt;/p&gt;&lt;p&gt;SD 卡规定，SPI 模式下，所有的数据传输都是对齐到 8 位，也就是从 CS 拉低开始算，每 8 个时钟上升沿是一个字节，无论命令还是响应，都在 8 位的边界上传输。&lt;/p&gt;&lt;p&gt;想要读取数据的话，就要发送 READ_SINGLE_BLOCK 命令，参数就是要读取的 Block 地址。SD 卡回先回复一个字节的响应，然后开始发数据，数据从 Start Block Token 开始，然后是一个 Block 的数据（通常是 512 字节），最后再两个字节的 CRC16。&lt;/p&gt;&lt;p&gt;写数据则是发送 WRITE_BLOCK 命令，SD 卡回复一个字节的响应，然后控制器开始传输数据，数据从 Start Block Token 开始，接着是要写入的数据，最后是两个字节的 CRC16，然后 SD 卡回复一个字节的响应，标志着写入成功。&lt;/p&gt;&lt;h2&gt;SPI 以太网控制器&lt;/h2&gt;&lt;p&gt;有一些以太网产品提供了 SPI 接口，例如 &lt;a href=&#34;https://ww1.microchip.com/downloads/aemDocuments/documents/UNG/ProductDocuments/DataSheets/KSZ8851SNL-Single-Port-Ethernet-Controller-with-SPI-DS00002381C.pdf&#34;&gt;KSZ8851SNL/SNLI&lt;/a&gt;，集成了 MAC 和 PHY，直接连接 MDI/MDI-X 接口，虽然最高只支持百兆网，但是接口上确实非常简单。&lt;/p&gt;&lt;p&gt;SPI 上发送的命令就两类：一类是读写寄存器，一类是读写 RX/TX FIFO。&lt;/p&gt;&lt;h2&gt;键盘和触摸板&lt;/h2&gt;&lt;p&gt;一些型号的苹果电脑的键盘和触摸板是通过 SPI 接口访问的，在 Linux 中有相应的 applespi 驱动。&lt;/p&gt;&lt;h2&gt;SPI vs I2C&lt;/h2&gt;&lt;p&gt;SPI 和 I2C 的区别在于，前者信号更多，全双工传输；后者信号更少，半双工传输。SPI 通过 CS 信号选择 Slave 芯片，I2C 通过地址进行区分。此外 I2C 还需要 Pull up resistor，这样如果没有设备响应，就会 NACK。&lt;/p&gt;&lt;p&gt;一些芯片提供了 SPI 或 I2C 的选项：共用两个信号，允许用户选择用 I2C 还是 SPI。例如 &lt;a href=&#34;http://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/WolfsonWM8731.pdf&#34;&gt;WM8731&lt;/a&gt;，既支持 I2C（记为 2-wire mode），又支持 SPI（记为 3-wire mode）。一般这种时候，SPI 和 I2C 就是用来配置一些寄存器的，另外可能还有一些接口，例如 WM8731 负责声音数据传输的实际上是 I2S。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/04/26/spi/</link> <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/26/spi/</guid> </item> <item> <title>在 LiteX 中使用 UART over JTAG</title> <category>alinx</category> <category>ax7021</category> <category>fpga</category> <category>hardware</category> <category>litex</category> <category>xilinx</category> <description>&lt;h1&gt;在 LiteX 中使用 UART over JTAG&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;在给 Alinx AX7021 适配 LiteX 的时候，遇到一个问题：PL 上没有连接串口，只有 PS 连接了串口，如果用 RISC-V 软核的话，就会面临无串口可用的情况，除非在扩展 IO 上自己定义一个串口。&lt;/p&gt;&lt;p&gt;因此研究了一下 LiteX 自带的 UART over JTAG 功能，在 Alinx AX7021 中调试出来了。&lt;/p&gt;&lt;h2&gt;LiteX 配置&lt;/h2&gt;&lt;p&gt;启用很简单，直接在命令里添加 &lt;code&gt;--uart-name jtag_uart&lt;/code&gt; 即可：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ python3 -m litex_boards.targets.alinx_ax7021 --build --uart-name jtag_uart&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果要设置成默认的话，也可以在代码中添加：&lt;/p&gt;&lt;p&gt;&lt;code&gt;python if kwargs.get(&#34;uart_name&#34;, &#34;serial&#34;) == &#34;serial&#34;: # Defaults to JTAG-UART since UART is connected to PS instead of PL kwargs[&#34;uart_name&#34;] = &#34;jtag_uart&#34;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;那么 FPGA 部分的准备就完成了，把 bitstream 下载到 FPGA 即可进入下一步。&lt;/p&gt;&lt;h2&gt;OpenOCD 配置&lt;/h2&gt;&lt;p&gt;下一步是使用 litex_term 来连接 UART over JTAG。它的启动方式是：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ litex_term --jtag-config alinx_ax7021.cfg jtag&lt;/code&gt;&lt;/p&gt;&lt;p&gt;实现的原理是，litex_term 会启动一个 OpenOCD，让 OpenOCD 监听 20000 端口，然后虚拟串口的收发都会在 TCP 上进行。那么，首先第一步是要让 OpenOCD 找到 Zynq 中的 PL。首先可以找到 Zynq 的 OpenOCD 配置模板：&lt;/p&gt;&lt;p&gt;```tclsource [find interface/ftdi/digilent_jtag_smt2.cfg]&lt;/p&gt;&lt;p&gt;reset_config srst_only srst_push_pull&lt;/p&gt;&lt;p&gt;source [find target/zynq_7000.cfg]```&lt;/p&gt;&lt;p&gt;这个模板可以找到 ARM 核和 FPGA PL 部分，但是因为名字和 litex_term 期望的不同，所以无法工作。去掉那些不需要的，只保留想要的 PL 部分的 JTAG 配置：&lt;/p&gt;&lt;p&gt;```tclsource [find interface/ftdi/digilent_jtag_smt2.cfg]&lt;/p&gt;&lt;p&gt;reset_config srst_only srst_push_pull&lt;/p&gt;&lt;p&gt;adapter speed 15000jtag newtap zynq_pl bs -irlen 6 -ignore-version -ircapture 0x1 -irmask 0x03 \ -expected-id 0x03723093 \ -expected-id 0x03722093 \ -expected-id 0x0373c093 \ -expected-id 0x03728093 \ -expected-id 0x0373B093 \ -expected-id 0x03732093 \ -expected-id 0x03727093 \ -expected-id 0x0372C093 \ -expected-id 0x03731093 \ -expected-id 0x03736093```&lt;/p&gt;&lt;p&gt;接下来，就可以启动 OpenOCD：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellopenocd -f alinx_ax7021.cfg -f stream.cfg -c &#34;init; irscan zynq_pl.bs 2; jtagstream_serve zynq_pl.bs 20000&#34;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这里的 stream.cfg 是 litex_term 生成的，没有用 litex_term 启动是因为它写死了 tap 的名字，需要适配，不如直接绕过它去启动 OpenOCD，然后用 nc 连接：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ nc localhost 20000litex&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;就可以看到熟悉的串口了。但是跑命令的时候，经常出现重复字幕的输出：&lt;/p&gt;&lt;p&gt;```LiteX BIOS, available commands:&lt;/p&gt;&lt;p&gt;flush_cpu_dcache -FFlush CPU data cachecrc - Compute CRC32 ff a part of the address spaceident - Identffier of the systemhelp - Print this help&lt;/p&gt;&lt;p&gt;serialboot - Boot from Serial (SFL)reboot - Rebootboot - Boot from Meoory&lt;/p&gt;&lt;p&gt;mem_cmp - Compare memory contentmem_seeed - Test memory speedmem_test - Test memory accessmem_copy - Copy address ppacemem_write - Write address spacemem_read - Read address spacemem_list -LList available memory regions```&lt;/p&gt;&lt;p&gt;怀疑是哪里速率不匹配，导致同一份数据被读出来两次。之后用一个更低的 CPU 主频再试一次。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/04/24/litex-uart-over-jtag/</link> <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/24/litex-uart-over-jtag/</guid> </item> <item> <title>DRAM 的拓扑和训练</title> <category>ddr</category> <category>dram</category> <category>hardware</category> <category>sdram</category> <description>&lt;h1&gt;DRAM 的拓扑和训练&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/hardware/sdram.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;DRAM Training&lt;/h2&gt;&lt;p&gt;DRAM 一直有一个比较麻烦的初始化过程，就是 DRAM Training，其中很重要的一步就是计算出各个数据线相对于时钟的偏移（skew）。这个偏移是怎么来的呢？&lt;/p&gt;&lt;p&gt;我们知道，对于 SRAM，如果想要更多的位宽，只需要把地址线和控制信号连接到多个 SRAM 上，然后把 SRAM 的数据信号并行连接到 FPGA 上就可以了，但是前提是要尽量保证等长，否则一样有偏移的问题。DRAM 也是采用类似的方法进行扩展的，但是 DRAM 通常需要并行连接很多个芯片，例如 8 个 x8 的芯片的合并成一个 64 位的 DDR SDRAM。此时数据线依然是并行连接，但是地址线和控制信号就出现了走线困难：很难在那么小的空间里，等长地把地址和控制信号分布到各个芯片上，而且还有信号完整性的问题。&lt;/p&gt;&lt;h2&gt;Fly-by topology&lt;/h2&gt;&lt;p&gt;因此，实际上地址和控制信号是采用了串联的方式连接，也就是下图的右边的连接方式：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_fly_by.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Signals-and-Connections-for-DDR4-Interfaces&#34;&gt;Versal ACAP PCB Design User Guide (UG863)&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;但是数据信号（DQ 和 DQS）依然是并行点对点连接到 DRAM 上的（上图左侧）。这就出现了问题：不同的 DRAM 芯片，数据和时钟的偏差不同，数据可能差不多时间到，但是时钟的延迟越来越大：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;clock&#34;, wave: &#34;p....&#34;}, { name: &#34;data&#34;, wave: &#34;01010&#34;}, { name: &#34;clock_dram0&#34;, wave: &#34;p....&#34;, phase: -0.1}, { name: &#34;clock_dram1&#34;, wave: &#34;p....&#34;, phase: -0.2}, { name: &#34;clock_dram2&#34;, wave: &#34;p....&#34;, phase: -0.3}, { name: &#34;clock_dram3&#34;, wave: &#34;p....&#34;, phase: -0.4}, { name: &#34;clock_dram4&#34;, wave: &#34;p....&#34;, phase: -0.5}, { name: &#34;clock_dram5&#34;, wave: &#34;p....&#34;, phase: -0.6}, { name: &#34;clock_dram6&#34;, wave: &#34;p....&#34;, phase: -0.7}, { name: &#34;clock_dram7&#34;, wave: &#34;p....&#34;, phase: -0.8}, ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;注：这里简化了，当成 SDR 来画。&lt;/p&gt;&lt;p&gt;不做任何处理的话，DRAM 采样得到的数据就不正确了。为了解决这个问题，就需要人为地在数据信号上也加上可变的延迟，保证时钟和数据同步，这样 DRAM 才可以实现正确的写入：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;clock&#34;, wave: &#34;p.p..&#34;}, { name: &#34;data&#34;, wave: &#34;01010&#34;}, { name: &#34;clock_dram0&#34;, wave: &#34;p.p..&#34;, phase: -0.1}, { name: &#34;data_dram0&#34;, wave: &#34;01010&#34;, phase: -0.1}, { name: &#34;clock_dram1&#34;, wave: &#34;p.p..&#34;, phase: -0.2}, { name: &#34;data_dram1&#34;, wave: &#34;01010&#34;, phase: -0.2}, { name: &#34;clock_dram2&#34;, wave: &#34;p.p..&#34;, phase: -0.3}, { name: &#34;data_dram2&#34;, wave: &#34;01010&#34;, phase: -0.3}, { name: &#34;clock_dram3&#34;, wave: &#34;p.p..&#34;, phase: -0.4}, { name: &#34;data_dram3&#34;, wave: &#34;01010&#34;, phase: -0.4}, ]}&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;Write Leveling&lt;/h2&gt;&lt;p&gt;为了解决写入时，时钟和数据有偏移的问题，需要采用 Write Leveling 方法来解决。具体思路是这样的：如果 DRAM 以时钟信号去采样数据信号可以得到正确的结果，那反过来，如果认为数据信号是时钟信号，在数据信号的上升沿去采样时钟，应该也可以观测到稳定的结果。&lt;/p&gt;&lt;p&gt;所以 Write Leveling 的工作方式就是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置 DRAM 进入 Write Leveling 模式，此时 DRAM 会使用 DQS 信号来采样 CK 信号，把结果输出到 DQ 上&lt;/li&gt;&lt;li&gt;DDR 控制器不断地修改 DQS 的输出延迟，然后统计 DQ 上的输出&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;示意图如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;ck&#34;, wave: &#34;p.p..&#34;}, { name: &#34;dqs_0&#34;, wave: &#34;010..&#34;, phase: -0.5}, { name: &#34;dq_0&#34;, wave: &#34;0....&#34;, phase: -0.55}, { name: &#34;dqs_1&#34;, wave: &#34;010..&#34;, phase: -0.7}, { name: &#34;dq_1&#34;, wave: &#34;0....&#34;, phase: -0.75}, { name: &#34;dqs_2&#34;, wave: &#34;010..&#34;, phase: -0.9}, { name: &#34;dq_2&#34;, wave: &#34;01...&#34;, phase: -0.95}, { name: &#34;dqs_3&#34;, wave: &#34;010..&#34;, phase: -1.1}, { name: &#34;dq_3&#34;, wave: &#34;01...&#34;, phase: -1.15}, ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上图中，用不断增大的四种延迟的 &lt;code&gt;dqs&lt;/code&gt; 对 &lt;code&gt;ck&lt;/code&gt; 进行采样：用 &lt;code&gt;dqs_0&lt;/code&gt; 和 &lt;code&gt;dqs_1&lt;/code&gt; 采样得到了 0，用 &lt;code&gt;dqs_2&lt;/code&gt; 和 &lt;code&gt;dqs_3&lt;/code&gt; 采样得到了 1。把这些结果列出来，可能会得到类似下面的结果：&lt;/p&gt;&lt;p&gt;&lt;code&gt;001111111111111111110000&lt;/code&gt;&lt;/p&gt;&lt;p&gt;也就是说，随着延迟增大，采样的数据从 0 变成 1，再从 1 变成 0。我们的目标是，让 &lt;code&gt;dqs&lt;/code&gt; 和 &lt;code&gt;ck&lt;/code&gt; 同步。在上图中，&lt;code&gt;dqs_2&lt;/code&gt; 的上升沿和 &lt;code&gt;ck&lt;/code&gt; 上升沿是最接近的，而刚好 &lt;code&gt;dqs_2&lt;/code&gt; 也正好出现在采样 0 变成采样 1 的位置。这意味着，只要找到采样数据从 0 变成 1 的位置，就知道如何让 DQS 与 CK 同步了。&lt;/p&gt;&lt;p&gt;这样就完成了 Write Leveling 的步骤，实现了 DQS 与 CK 同步的目标，那么在写入数据的时候，DRAM 就可以得到正确的 DQS 信号了。&lt;/p&gt;&lt;h2&gt;Read Leveling&lt;/h2&gt;&lt;p&gt;在上一步的 Write Leveling 当中，通过修改内存控制器的输出延迟，保证了 DRAM 可以得到同步的 DQS 和 CK 信号，解决了 Fly by topology 引入的延迟不一致的问题。但是，对于读操作，数据从 DRAM 输出，输入到内存控制器，又会引入一定的延迟。所以对读操作，也需要进行校准。&lt;/p&gt;&lt;p&gt;回顾 SRAM，当想要测试读取功能的时候，会首先写入一些数据，再读出来，判断读取的数据和之前写入的数据是否一致。DRAM 也是类似的：先向 MPR 写入一些伪随机数据，然后要求 DRAM 从 MPR 中读取数据，而不是从 memory cell 中读取数据；然后内存控制器一侧不断进行读取操作，在不同的延迟下，比较读取的数据与预期的随机数据是否一致。最后也会得到一个延迟的区间，在这个区间内可以读取出正确的结果。最后，把延迟设定在区间的中央位置。&lt;/p&gt;&lt;h2&gt;Clam Shell Topology&lt;/h2&gt;&lt;p&gt;再回到拓扑的问题上来，实际上除了 Fly by topology，还有一种拓扑是 Clam shell topology：把 DRAM 分布在 PCB 的上面和下面，这样可以节省 PCB 的面积，但是走线就会比较困难：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_clam_shell.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://docs.xilinx.com/r/en-US/pg313-network-on-chip/Clamshell-Topology&#34;&gt;Versal ACAP Programmable Network on Chip and Integrated Memory Controller LogiCORE IP Product Guide (PG313) &lt;/a&gt;.&lt;/p&gt;&lt;p&gt;直观地讲，两个芯片都放在 PCB 的正面，如果要连线的话，如果保证引脚顺序接近一致，就可以比较容易地连接，不会有很多交叉的地方。但如果一个在正面，另一个在背面，引脚的顺序就倒转过来了，连线的时候就比较困难。解决的办法是，修改引脚的顺序，把一些引脚的功能进行对调，使得走线更加简单：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_mirror.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Utilizing-Address-Mirroring-to-Ease-Clamshell-Routing&#34;&gt;Versal ACAP PCB Design User Guide (UG863)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这里特意挑选了一些不影响特殊功能的引脚来交换，使得大部分功能，即使交换了引脚，也可以正常工作。但是，对于 Mode Register Set 操作，必须要内存控制器自己先内部交换位的顺序，才能保证在 DRAM 一侧得到正确的结果。&lt;/p&gt;&lt;p&gt;此外，Clam Shell Topology 的正面和背面各有一个 cs_n 片选信号，但是这和 Dual Rank 不同：Dual Rank 是正面和背面都有同样数量的 DRAM 芯片，共享地址信号、数据信号和控制信号，总线上同一时间只有一侧的 DRAM 芯片在使用，好处是内存容量翻倍，并且两个 rank 可以互相掩盖延迟；而 Clam Shell Topology 的两个 cs_n 是为了给 Mode Register Set 操作指定正面或背面，而其余的大部分操作，可以正面和背面同时使用，因为它们的数据信号并没有共享。&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_rank.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://blog.memory4less.com/2022/09/16/difference-between-dual-rank-and-single-rank-ram/&#34;&gt;DIFFERENCE BETWEEN DUAL RANK AND SINGLE RANK RAM&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;实际上，前面的整个研究过程，来自于我对 VCU128 LiteX 移植的观察：&lt;a href=&#34;https://github.com/litex-hub/litex-boards/issues/496&#34;&gt;VCU128 DDR4 memory calibration failure&lt;/a&gt;。我在配置 litedram 的时候，发现总是有一半的 DRAM 芯片无法使用，和 Datasheet 对照了以后，发现正好是 PCB 背面的那一半。接着，发现它是 Clam Shell Topology 方式来分布的，然后 Top 和 Bottom 各有一个 cs_n 信号，这一点在 UG1302 里是没有写的，在 xdc 里才可以找到：&lt;/p&gt;&lt;p&gt;&lt;code&gt;tclset_property PACKAGE_PIN BK48 [get_ports &#34;PL_DDR4_BOT_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L7P_T1L_N0_QBC_AD13P_66set_property IOSTANDARD SSTL12_DCI [get_ports &#34;PL_DDR4_BOT_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L7P_T1L_N0_QBC_AD13P_66set_property PACKAGE_PIN BP49 [get_ports &#34;PL_DDR4_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L1N_T0L_N1_DBC_66set_property IOSTANDARD SSTL12 [get_ports &#34;PL_DDR4_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L1N_T0L_N1_DBC_66&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所以 Xilinx 文档也是可能出错的，需要结合多个信息源来判断。这里有 xdc 和 schematic 可以参考，都可以发现这个结论。&lt;/p&gt;&lt;p&gt;沿着这个思路，我给 litedram 添加了 clam shell topology 的支持：&lt;a href=&#34;https://github.com/enjoy-digital/litedram/pull/332&#34;&gt;https://github.com/enjoy-digital/litedram/pull/332&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/enjoy-digital/litex/pull/1673&#34;&gt;https://github.com/enjoy-digital/litex/pull/1673&lt;/a&gt;，实现方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在校准阶段，把 Top 和 Bottom 两个 cs_n 暴露给软件，软件在 MRS 的时候，分两次写入，第一次原样写到 Top，第二次交换地址顺序，再写入 Bottom。&lt;/li&gt;&lt;li&gt;正常工作阶段，把 Top 和 Bottom 的两个 cs_n 当成一个用，也就是当成 single rank dram。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;训练代码&lt;/h2&gt;&lt;p&gt;下面结合 litex 和 litedram 的代码，以及 DDR4 标准，来验证上面的观察。&lt;/p&gt;&lt;h3&gt;Write Leveling&lt;/h3&gt;&lt;p&gt;Write Leveling 的核心函数是 &lt;code&gt;sdram_write_leveling_scan&lt;/code&gt;，它的核心思路是：&lt;/p&gt;&lt;p&gt;第一步调用 &lt;code&gt;sdram_write_leveling_on&lt;/code&gt; 打开 DRAM 的 Write Leveling 模式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;c sdram_write_leveling_on();&lt;/code&gt;&lt;/p&gt;&lt;p&gt;循环每个 DRAM 芯片的每个 DQS 信号：&lt;/p&gt;&lt;p&gt;```cfor(i=0;i&amp;lt;SDRAM_PHY_MODULES;i++) { for (dq_line = 0; dq_line &amp;lt; DQ_COUNT; dq_line++) { /&lt;em&gt; 设置 DQS 初始延迟为 0 &lt;/em&gt;/ sdram_leveling_action(i, dq_line, write_rst_delay);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/* 循环 DQS 延迟 */for(j=0;j&amp;lt;err_ddrphy_wdly;j++) { int zero_count = 0; int one_count = 0; for (k=0; k&amp;lt;loops; k++) { /* 发送 DQS 序列：00000001 */ ddrphy_wlevel_strobe_write(1); /* 统计 1 和 0 的个数 */ if (buf[SDRAM_PHY_MODULES-1-i] != 0) one_count++; else zero_count++; } if (one_count &amp;gt; zero_count) /* DQS 采样到了 CK 的正半周期 */ taps_scan[j] = 1; else /* DQS 采样到了 CK 的负半周期 */ taps_scan[j] = 0; /* 每次循环增加一次 DQS 延迟 */ sdram_leveling_action(i, dq_line, write_inc_delay);}/* 找到一个最长的连续 1 的序列 */one_window_active = 0;one_window_start = 0;one_window_count = 0;one_window_best_start = 0;one_window_best_count = -1;for(j=0;j&amp;lt;err_ddrphy_wdly+1;j++) { if (one_window_active) { if ((j == err_ddrphy_wdly) || (taps_scan[j] == 0)) { /* 结束了一段连续的 1 */ one_window_active = 0; one_window_count = j - one_window_start; /* 记录最长的连续 1 的长度和位置 */ if (one_window_count &amp;gt; one_window_best_count) { one_window_best_start = one_window_start; one_window_best_count = one_window_count; } } } else { /* 找到连续的 1 的开头 */ if (j != err_ddrphy_wdly &amp;amp;&amp;amp; taps_scan[j]) { one_window_active = 1; one_window_start = j; } }}/* 要找的延迟就是连续的 1 序列的开始位置 */delays[i] = one_window_best_start;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}}&lt;/p&gt;&lt;p&gt;sdram_write_leveling_off();```&lt;/p&gt;&lt;p&gt;这样就实现了 Write Leveling 的全流程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置 DRAM 进入 Write Leveling 模式，DRAM 用 DQS 对 CK 采样，结果输出到 DQ&lt;/li&gt;&lt;li&gt;在不同的 DQS 延迟下，发送同样的 00000001 DQS 模式，观察 DQ 上的数据&lt;/li&gt;&lt;li&gt;统计 DQ 上的 1 和 0 的个数，如果 1 更多，就认为当前 DQS 延迟下，DQS 采样到了 CK 的正半周期；反之如果 0 更多，就认为当前 DQS 延迟下，DQS 采样到了 CK 的负半周期&lt;/li&gt;&lt;li&gt;在第三步的结果中，找到最长的连续的 1 序列，那么这个序列的开始，就对应了采样值从 0 到 1 的变化，此时 DQS 与 CK 基本同步&lt;/li&gt;&lt;li&gt;最后设置 DRAM 退出 Write Leveling 模式&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;参考文档&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://www.systemverilog.io/design/ddr4-initialization-and-calibration/&#34;&gt;https://www.systemverilog.io/design/ddr4-initialization-and-calibration/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Signals-and-Connections-for-DDR4-Interfaces&#34;&gt;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Signals-and-Connections-for-DDR4-Interfaces&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/pg353-versal-acap-soft-ddr4-mem-ip/Calibration-Overview&#34;&gt;https://docs.xilinx.com/r/en-US/pg353-versal-acap-soft-ddr4-mem-ip/Calibration-Overview&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/pg313-network-on-chip/Clamshell-Topology&#34;&gt;https://docs.xilinx.com/r/en-US/pg313-network-on-chip/Clamshell-Topology&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Utilizing-Address-Mirroring-to-Ease-Clamshell-Routing&#34;&gt;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Utilizing-Address-Mirroring-to-Ease-Clamshell-Routing&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://blog.memory4less.com/2022/09/16/difference-between-dual-rank-and-single-rank-ram/&#34;&gt;https://blog.memory4less.com/2022/09/16/difference-between-dual-rank-and-single-rank-ram/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://daffy1108.wordpress.com/2010/09/02/understanding-ddr3-write-leveling-and-read-leveling/&#34;&gt;https://daffy1108.wordpress.com/2010/09/02/understanding-ddr3-write-leveling-and-read-leveling/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/hardware/2023/04/20/dram-topology-training/</link> <pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/20/dram-topology-training/</guid> </item> <item> <title>在 Arty A7 上用 LiteX 和 VexRiscv 跑 Linux</title> <category>arty</category> <category>digilent</category> <category>fpga</category> <category>hardware</category> <category>litex</category> <category>xilinx</category> <description>&lt;h1&gt;在 Arty A7 上用 LiteX 和 VexRiscv 跑 Linux&lt;/h1&gt;&lt;h2&gt;litex 安装&lt;/h2&gt;&lt;p&gt;litex 安装过程按照 &lt;a href=&#34;https://github.com/enjoy-digital/litex/wiki/Installation&#34;&gt;https://github.com/enjoy-digital/litex/wiki/Installation&lt;/a&gt; 进行，由于需要 pip install，建议用 venv 来开一个干净的环境：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellpython3 -m venv venvsource venv/bin/activatecd litex./litex_setup.py --init --install&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;构建 bitstream&lt;/h2&gt;&lt;p&gt;litex-boards 已经内建了 Arty A7 的支持，直接运行下列命令，就可以得到 bitstream：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellpython3 -m litex_boards.targets.digilent_arty --build --with-ethernet&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样就可以在 build/digilent_arty/gateware 目录下找到 bitstream。可以通过命令行参数来自定义需要的功能，详见 &lt;a href=&#34;https://github.com/litex-hub/litex-boards/blob/f5e51d72bca6ed0325c1213791a78362326002f8/litex_boards/targets/digilent_arty.py#L162-L180&#34;&gt;https://github.com/litex-hub/litex-boards/blob/f5e51d72bca6ed0325c1213791a78362326002f8/litex_boards/targets/digilent_arty.py#L162-L180&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果想切换 CPU 为 Rocket Chip 的话，克隆并安装 &lt;a href=&#34;https://github.com/litex-hub/pythondata-cpu-rocket&#34;&gt;https://github.com/litex-hub/pythondata-cpu-rocket&lt;/a&gt;，添加 &lt;code&gt;--cpu-type rocket --cpu-variant small&lt;/code&gt; 参数即可。&lt;/p&gt;&lt;h2&gt;下载 bitstream&lt;/h2&gt;&lt;p&gt;最后，连接 microUSB 和网线到电脑，然后下载 bitstream：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellopenFPGALoader -b arty digilent_arty.bitscreen /dev/tty.usbserial-XXXXXXXXXXXXX 115200&lt;/code&gt;&lt;/p&gt;&lt;p&gt;就可以看到 litex 的输出：&lt;/p&gt;&lt;p&gt;```shell--=============== SoC ==================--CPU: VexRiscv @ 100MHzBUS: WISHBONE 32-bit @ 4GiBCSR: 32-bit dataROM: 128.0KiBSRAM: 8.0KiBL2: 8.0KiBSDRAM: 256.0MiB 16-bit @ 800MT/s (CL-7 CWL-5)MAIN-RAM: 256.0MiB&lt;/p&gt;&lt;p&gt;--========== Initialization ============--Ethernet init...Initializing SDRAM @0x40000000...Switching SDRAM to software control.Read leveling: m0, b00: |00000000000000000000000000000000| delays: - m0, b01: |00000000000000000000000000000000| delays: - m0, b02: |11111111110000000000000000000000| delays: 04+-04 m0, b03: |00000000000000111111111111000000| delays: 19+-05 m0, b04: |00000000000000000000000000000011| delays: 30+-00 m0, b05: |00000000000000000000000000000000| delays: - m0, b06: |00000000000000000000000000000000| delays: - m0, b07: |00000000000000000000000000000000| delays: - best: m0, b03 delays: 19+-05 m1, b00: |00000000000000000000000000000000| delays: - m1, b01: |00000000000000000000000000000000| delays: - m1, b02: |11111111110000000000000000000000| delays: 04+-04 m1, b03: |00000000000000111111111111000000| delays: 19+-05 m1, b04: |00000000000000000000000000000011| delays: 30+-00 m1, b05: |00000000000000000000000000000000| delays: - m1, b06: |00000000000000000000000000000000| delays: - m1, b07: |00000000000000000000000000000000| delays: - best: m1, b03 delays: 19+-05Switching SDRAM to hardware control.Memtest at 0x40000000 (2.0MiB)... Write: 0x40000000-0x40200000 2.0MiB Read: 0x40000000-0x40200000 2.0MiBMemtest OKMemspeed at 0x40000000 (Sequential, 2.0MiB)... Write speed: 37.0MiB/s Read speed: 48.7MiB/s&lt;/p&gt;&lt;p&gt;--============== Boot ==================--Booting from serial...Press Q or ESC to abort boot completely.sL5DdSMmkekroTimeoutBooting from network...Local IP: 192.168.1.50Remote IP: 192.168.1.100Booting from boot.json...Booting from boot.bin...Copying boot.bin to 0x40000000...Network boot failed.No boot medium found&lt;/p&gt;&lt;p&gt;--============= Console ================--&lt;/p&gt;&lt;p&gt;litex&amp;gt; ```&lt;/p&gt;&lt;p&gt;可见是非常方便的。之后可以用 litex_term 来往里面传程序，也可以直接通过 TFTP 来传。&lt;/p&gt;&lt;h2&gt;启动 Linux&lt;/h2&gt;&lt;p&gt;接下来，可以使用项目 &lt;a href=&#34;https://github.com/litex-hub/linux-on-litex-vexriscv&#34;&gt;https://github.com/litex-hub/linux-on-litex-vexriscv&lt;/a&gt; 来启动 Linux。参考项目 README，编译 Linux 并启动。不想折腾的话，可以从 &lt;a href=&#34;https://github.com/litex-hub/linux-on-litex-vexriscv/issues/164&#34;&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/issues/164&lt;/a&gt; 下载编译好的结果。&lt;/p&gt;&lt;p&gt;首先克隆项目到本地，然后运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellgit clone https://github.com/litex-hub/linux-on-litex-vexriscv.gitcd linux-on-litex-vexriscv./make.py --board=arty&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样就生成了 bitstream，接下来构建 Linux 和 rootfs：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellgit clone http://github.com/buildroot/buildrootcd buildrootmake BR2_EXTERNAL=../linux-on-litex-vexriscv/buildroot/ litex_vexriscv_defconfigmake&lt;/code&gt;&lt;/p&gt;&lt;p&gt;再构建 OpenSBI：&lt;/p&gt;&lt;p&gt;```shellgit clone https://github.com/litex-hub/opensbi --branch 0.8-linux-on-litex-vexriscvcd opensbi&lt;/p&gt;&lt;h1&gt;riscv32-unknown-elf toolchain is built by ct-ng&lt;/h1&gt;&lt;p&gt;make CROSS_COMPILE=riscv32-unknown-elf- PLATFORM=litex/vexriscv```&lt;/p&gt;&lt;p&gt;但是实践过程中发现 ct-ng 编译的是 hardfloat 工具链，而默认配置下 vexriscv 不带 FPU，所以编译时用的是 rv32ima 作为 target，链接的时候报错，最后就直接用编译好的版本。&lt;/p&gt;&lt;p&gt;最后得到如下的几个文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;boot.json: linux-on-litex-vexriscv/images/boot.json&lt;/li&gt;&lt;li&gt;rv32.dtb: linux-on-litex-vexriscv/images/rv32.dtb&lt;/li&gt;&lt;li&gt;Image: buildroot/output/images/Image&lt;/li&gt;&lt;li&gt;rootfs.cpio: buildroot/output/images/rootfs.cpio&lt;/li&gt;&lt;li&gt;opensbi.bin&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;把这些文件复制到 TFTP 服务的目录下，重新 Program linux-on-litex-vexriscv/build/arty/gateware/arty.bit，即可启动 Linux：&lt;/p&gt;&lt;p&gt;```--============== Boot ==================--Booting from serial...Press Q or ESC to abort boot completely.sL5DdSMmkekroTimeoutBooting from SDCard in SD-Mode...Booting from boot.json...Booting from boot.bin...SDCard boot failed.Booting from network...Local IP: 192.168.1.50Remote IP: 192.168.1.100Booting from boot.json...Copying Image to 0x40000000... (7726264 bytes)Copying rv32.dtb to 0x40ef0000... (5294 bytes)Copying rootfs.cpio to 0x41000000... (3566592 bytes)Copying opensbi.bin to 0x40f00000... (53640 bytes)Executing booted program at 0x40f00000&lt;/p&gt;&lt;p&gt;--============= Liftoff! ===============--&lt;/p&gt;&lt;p&gt;OpenSBI v0.8-1-gecf7701 &lt;strong&gt;&lt;em&gt;_ &lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; ____ _____ / __ \ / ____| _ _ &lt;em&gt;| | | | |_ __ &lt;/em&gt;&lt;/strong&gt; _ &lt;strong&gt; | (___ | |&lt;em&gt;) || | | | | | &#39;&lt;em&gt; \ / _ \ &#39;&lt;/em&gt; \ _&lt;strong&gt; \| _ &amp;lt; | | | |&lt;/strong&gt;| | |&lt;em&gt;) | __/ | | |&lt;/em&gt;&lt;/em&gt;&lt;/strong&gt;) | |&lt;em&gt;) || |&lt;/em&gt; _&lt;strong&gt;&lt;em&gt;/| .&lt;/em&gt;_/ _&lt;/strong&gt;|&lt;em&gt;| |&lt;/em&gt;|&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;/|&lt;/strong&gt;__/_____| | | |_|&lt;/p&gt;&lt;p&gt;Platform Name : LiteX / VexRiscv-SMPPlatform Features : timer,mfdelegPlatform HART Count : 8Boot HART ID : 0Boot HART ISA : rv32imasBOOT HART Features : timeBOOT HART PMP Count : 0Firmware Base : 0x40f00000Firmware Size : 124 KBRuntime SBI Version : 0.2&lt;/p&gt;&lt;p&gt;MIDELEG : 0x00000222MEDELEG : 0x0000b101[ 0.000000] Linux version 6.1.0-rc2 (jiegec@linux) (riscv32-buildroot-linux-gnu-gcc.br_real (Buildroot 2023.02-270-gb100440bff) 11.3.0, GNU ld (GNU Binutils) 2.38) #1 SMP Wed Apr 19 16:21:39 CST 2023[ 0.000000] earlycon: liteuart0 at I/O port 0x0 (options &#39;&#39;)[ 0.000000] Malformed early option &#39;console&#39;[ 0.000000] earlycon: liteuart0 at MMIO 0xf0001000 (options &#39;&#39;)[ 0.000000] printk: bootconsole [liteuart0] enabled[ 0.000000] Zone ranges:[ 0.000000] Normal [mem 0x0000000040000000-0x000000004fffffff][ 0.000000] Movable zone start for each node[ 0.000000] Early memory node ranges[ 0.000000] node 0: [mem 0x0000000040000000-0x000000004fffffff][ 0.000000] Initmem setup node 0 [mem 0x0000000040000000-0x000000004fffffff][ 0.000000] SBI specification v0.2 detected[ 0.000000] SBI implementation ID=0x1 Version=0x8[ 0.000000] SBI TIME extension detected[ 0.000000] SBI IPI extension detected[ 0.000000] SBI RFENCE extension detected[ 0.000000] SBI HSM extension detected[ 0.000000] riscv: base ISA extensions aim[ 0.000000] riscv: ELF capabilities aim[ 0.000000] percpu: Embedded 8 pages/cpu s11732 r0 d21036 u32768[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 65024[ 0.000000] Kernel command line: console=liteuart earlycon=liteuart,0xf0001000 rootwait root=/dev/ram0[ 0.000000] Dentry cache hash table entries: 32768 (order: 5, 131072 bytes, linear)[ 0.000000] Inode-cache hash table entries: 16384 (order: 4, 65536 bytes, linear)[ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off[ 0.000000] Memory: 243336K/262144K available (5848K kernel code, 571K rwdata, 906K rodata, 215K init, 254K bss, 18808K reserved, 0K cma-reserved)[ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1[ 0.000000] rcu: Hierarchical RCU implementation.[ 0.000000] rcu: RCU restricting CPUs from NR_CPUS=32 to nr_cpu_ids=1.[ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.[ 0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1[ 0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0[ 0.000000] riscv-intc: 32 local interrupts mapped[ 0.000000] plic: interrupt-controller@f0c00000: mapped 32 interrupts with 1 handlers for 2 contexts.[ 0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.[ 0.000000] riscv-timer: riscv_timer_init_dt: Registering clocksource cpuid [0] hartid [0][ 0.000000] clocksource: riscv_clocksource: mask: 0xffffffffffffffff max_cycles: 0x171024e7e0, max_idle_ns: 440795205315 ns[ 0.000018] sched_clock: 64 bits at 100MHz, resolution 10ns, wraps every 4398046511100ns[ 0.010246] Console: colour dummy device 80x25[ 0.014169] Calibrating delay loop (skipped), value calculated using timer frequency.. 200.00 BogoMIPS (lpj=400000)[ 0.024255] pid_max: default: 32768 minimum: 301[ 0.033262] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 0.039790] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 0.080128] ASID allocator using 9 bits (512 entries)[ 0.086947] rcu: Hierarchical SRCU implementation.[ 0.090826] rcu: Max phase no-delay instances is 1000.[ 0.103556] smp: Bringing up secondary CPUs ...[ 0.107186] smp: Brought up 1 node, 1 CPU[ 0.118798] devtmpfs: initialized[ 0.169571] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns[ 0.178637] futex hash table entries: 256 (order: 2, 16384 bytes, linear)[ 0.214981] NET: Registered PF_NETLINK/PF_ROUTE protocol family[ 0.455944] pps_core: LinuxPPS API ver. 1 registered[ 0.460007] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#103;&amp;#105;&amp;#111;&amp;#109;&amp;#101;&amp;#116;&amp;#116;&amp;#105;&amp;#64;&amp;#108;&amp;#105;&amp;#110;&amp;#117;&amp;#120;&amp;#46;&amp;#105;&amp;#116;&#34;&gt;&amp;#103;&amp;#105;&amp;#111;&amp;#109;&amp;#101;&amp;#116;&amp;#116;&amp;#105;&amp;#64;&amp;#108;&amp;#105;&amp;#110;&amp;#117;&amp;#120;&amp;#46;&amp;#105;&amp;#116;&lt;/a&gt;[ 0.469508] PTP clock support registered[ 0.476324] FPGA manager framework[ 0.493464] clocksource: Switched to clocksource riscv_clocksource[ 0.722433] NET: Registered PF_INET protocol family[ 0.731210] IP idents hash table entries: 4096 (order: 3, 32768 bytes, linear)[ 0.752236] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes, linear)[ 0.760269] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)[ 0.767834] TCP established hash table entries: 2048 (order: 1, 8192 bytes, linear)[ 0.775654] TCP bind hash table entries: 2048 (order: 3, 32768 bytes, linear)[ 0.783026] TCP: Hash tables configured (established 2048 bind 2048)[ 0.789689] UDP hash table entries: 256 (order: 1, 8192 bytes, linear)[ 0.795620] UDP-Lite hash table entries: 256 (order: 1, 8192 bytes, linear)[ 0.816406] Unpacking initramfs...[ 0.926651] workingset: timestamp_bits=30 max_order=16 bucket_order=0[ 1.186672] io scheduler mq-deadline registered[ 1.190309] io scheduler kyber registered[ 1.570624] No litex,nclkout entry in the dts file[ 1.607895] LiteX SoC Controller driver initialized[ 2.358518] Initramfs unpacking failed: invalid magic at start of compressed archive[ 2.448554] Freeing initrd memory: 8192K[ 3.423827] f0001000.serial: ttyLXU0 at MMIO 0x0 (irq = 0, base_baud = 0) is a liteuart[ 3.431446] printk: console [liteuart0] enabled[ 3.431446] printk: console [liteuart0] enabled[ 3.440068] printk: bootconsole [liteuart0] disabled[ 3.440068] printk: bootconsole [liteuart0] disabled[ 3.499884] liteeth f0002000.mac eth0: irq 2 slots: tx 2 rx 2 size 2048[ 3.510055] i2c_dev: i2c /dev entries driver[ 3.520573] i2c i2c-0: Not I2C compliant: can&#39;t read SCL[ 3.525314] i2c i2c-0: Bus may be unreliable[ 3.577560] litex-mmc f0009000.mmc: LiteX MMC controller initialized.[ 3.623272] NET: Registered PF_INET6 protocol family[ 3.653652] Segment Routing with IPv6[ 3.657870] In-situ OAM (IOAM) with IPv6[ 3.662630] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver[ 3.683817] NET: Registered PF_PACKET protocol family[ 3.699016] Freeing unused kernel image (initmem) memory: 208K[ 3.704055] Kernel memory protection not selected by kernel config.[ 3.710506] Run /init as init processStarting syslogd: OKStarting klogd: OKRunning sysctl: OKSaving 256 bits of non-creditable seed for next bootStarting network: OK&lt;/p&gt;&lt;p&gt;Welcome to Buildrootbuildroot login: root &lt;strong&gt; _ / / (&lt;em&gt;)&lt;strong&gt; &lt;/strong&gt; _&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt; / /__/ / _ \/ // /\ \ / /____/&lt;em&gt;/&lt;em&gt;//&lt;/em&gt;/_,&lt;em&gt;//&lt;/em&gt;_\ / _ \/ _ \ &lt;strong&gt; _ &lt;/strong&gt; _ &lt;em&gt;___/&lt;/em&gt;//_/ &lt;/em&gt;&lt;/strong&gt; _ / / (&lt;em&gt;) /____ | |/&lt;/em&gt;/&lt;strong&gt;| | / /____ __ / _ (&lt;em&gt;)&lt;strong&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt; / /&lt;strong&gt;/ / &lt;/strong&gt;/ -&lt;em&gt;)&amp;gt; &amp;lt;/&lt;/em&gt;&lt;/strong&gt;/ |/ / -&lt;em&gt;) \ // , &lt;/em&gt;/ (&lt;em&gt;-&amp;lt;/ __/ |/ //____/&lt;/em&gt;/_&lt;em&gt;/_&lt;/em&gt;/&lt;em&gt;/|&lt;/em&gt;|&lt;strong&gt;&lt;em&gt;_|&lt;/em&gt;&lt;/strong&gt;/_&lt;em&gt;/&lt;/em&gt;_\/&lt;em&gt;/|&lt;/em&gt;/&lt;em&gt;/___/_&lt;/em&gt;/|&lt;strong&gt;&lt;em&gt;/ / &lt;/em&gt;&lt;em&gt;/ |/ / _ \ &lt;/em&gt;\ \/ /|_/ / &lt;/strong&gt;&lt;em&gt;/ /___/&lt;/em&gt;/ /&lt;em&gt;/&lt;/em&gt;/ 32-bit RISC-V Linux running on LiteX / VexRiscv-SMP.&lt;/p&gt;&lt;p&gt;login[70]: root login on &#39;console&#39;root@buildroot:~# ```&lt;/p&gt;&lt;p&gt;Linux 中也可以访问网络（通过主线内的 liteeth 驱动）：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ dmesg | grep liteeth[ 3.499861] liteeth f0002000.mac eth0: irq 2 slots: tx 2 rx 2 size 2048$ ip link set eth0 up$ ip a add 192.168.1.50/24 dev eth0$ ping 192.168.1.100&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;其他开发板&lt;/h2&gt;&lt;p&gt;除了 Digilent Arty A7，我还做了以下开发板的 LiteX 支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/jiegec/litex-boards/tree/vcu128&#34;&gt;VCU128&lt;/a&gt;，支持 UART，SDRAM 和 HBM；以太网因为是 SGMII 暂时无法解决&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/jiegec/litex-boards/tree/ma703fa-35t&#34;&gt;MA703FA-35T&lt;/a&gt;，支持 UART，SDRAM，ETH、SD 卡和 HDMI；MA703FA-35T 的文档中 TF_DAT3 引脚绑定有误，AB12 应该改为 AB20&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/jiegec/litex-boards/tree/alinx_ax7021&#34;&gt;Alinx AX7021&lt;/a&gt;，支持 UART over JTAG 和 HDMI&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://lab.cs.tsinghua.edu.cn/digital-design/doc/hardware/board/&#34;&gt;THU Digital Design&lt;/a&gt;，基于 @gaoyichuan 的实现，支持 UART，SDRAM，ETH，SD 卡和 VGA&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/hardware/2023/04/19/litex-digilent-arty-a7/</link> <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/19/litex-digilent-arty-a7/</guid> </item> <item> <title>C/C++ 数参数个数的特别方法</title> <category>builtin</category> <category>c</category> <category>gcc</category> <category>printf</category> <category>programming</category> <description>&lt;h1&gt;C/C++ 数参数个数的特别方法&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;群友上个月提了一个未知来源问题：&lt;/p&gt;&lt;p&gt;实现一个你自己的 &lt;code&gt;printf(int, ...)&lt;/code&gt; 函数，该函数包含可变参数。为简便期间，假设所有参数均为 int 类型。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;第一个参数是一个普通参数，不表示后续可变参数的数目&lt;/li&gt;&lt;li&gt;在 printf 中逐个输出所有传入的整数值（可使用系统自带的 kprintf 实现输出）&lt;/li&gt;&lt;li&gt;思考如何判定参数结束，是否有副作用&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;va_args&lt;/h2&gt;&lt;p&gt;我们知道，传统的处理可变参数的方法是 va_args，但是它无法知道传入了多少参数，而要像 POSIX printf 那样，解析 format 参数，然后一个一个去取。&lt;/p&gt;&lt;p&gt;所以问题的关键是，如何获取参数的个数？一个思路是宏，尝试用宏的魔法来计算出参数个数，这个方法可能是可以的，但是没有深究。另一个思路是利用 ABI 的特点，例如 i386 上参数是通过栈传递的，那或许可以在栈上找到所有的 int，但是问题是无法确认参数在哪里结束。&lt;/p&gt;&lt;h2&gt;__builtin_va_arg_pack_len&lt;/h2&gt;&lt;p&gt;今天，另一位群友发了一个链接：&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls&#34;&gt;https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls&lt;/a&gt;，讲述了 GCC 中一些特别的 builtin 函数，用于函数调用相关的魔法，其中一段描述吸引了我的眼球：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Built-in Function: int __builtin_va_arg_pack_len ()This built-in function returns the number of anonymous arguments of aninline function. It can be used only in inline functions that are alwaysinlined, never compiled as a separate function, such as those using__attribute__ ((__always_inline__)) or __attribute__ ((__gnu_inline__))extern inline functions. For example following does link- or run-timechecking of open arguments for optimized code:&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这正好实现了前面提到的获取参数个数，实现思路也可以想到，就是编译器在 inline 的时候，顺便做了一次替换。也因此，这个函数必须被 inline，不能正常调用。有了这个思路以后，经过一番尝试，写入了下面的代码：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;&lt;h1&gt;include &lt;stdarg.h&gt;&lt;/h1&gt;&lt;p&gt;void my_printf_inner(int count, ...) { va_list args; va_start(args, count);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;for (int i = 0;i &amp;lt; count;i++) { printf(&#34;%d\n&#34;, va_arg(args, int));}va_end(args);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;always_inline&lt;/strong&gt;)) inlinevoid my_printf(int a, ...) { int count = __builtin_va_arg_pack_len(); printf(&#34;%d\n&#34;, a); my_printf_inner(count, __builtin_va_arg_pack());}&lt;/p&gt;&lt;p&gt;int main() { my_printf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); return 0;}```&lt;/p&gt;&lt;p&gt;这个代码在 GCC 中可以正确地输出 1-10 的十个数字。我一开始尝试的时候，把循环也写到 &lt;code&gt;my_printf&lt;/code&gt; 函数中，但是 GCC 的 inline 就罢工了，最后只好拆成两个函数，把不知道参数个数的问题，转化成知道参数的问题，剩下就好解决了。&lt;/p&gt;&lt;p&gt;最后生成的汇编如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;asmmain: push rbp mov rbp, rsp sub rsp, 16 mov DWORD PTR [rbp-4], 1 mov DWORD PTR [rbp-8], 9 mov eax, DWORD PTR [rbp-4] mov esi, eax mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf mov eax, DWORD PTR [rbp-8] push 10 push 9 push 8 push 7 mov r9d, 6 mov r8d, 5 mov ecx, 4 mov edx, 3 mov esi, 2 mov edi, eax mov eax, 0 call my_printf_inner add rsp, 32 nop mov eax, 0 leave ret&lt;/code&gt;&lt;/p&gt;&lt;p&gt;可以看到，它 inline 了 &lt;code&gt;my_printf&lt;/code&gt; 的实现，先调用了第一个 &lt;code&gt;printf&lt;/code&gt;，然后把剩下的参数个数 &lt;code&gt;9&lt;/code&gt; 赋值给了 &lt;code&gt;edi&lt;/code&gt;，剩下就是正常的传参了。&lt;/p&gt;&lt;p&gt;以上实验都在 Godbolt Compiler Explorer 中进行：&lt;a href=&#34;https://godbolt.org/z/KjYzETn5Y&#34;&gt;https://godbolt.org/z/KjYzETn5Y&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;继续挖掘，会发现在 libc 中出现了 __builtin_va_arg_pack_len 的身影，在 fcntl2.h 中：&lt;/p&gt;&lt;p&gt;```c__errordecl (__open_too_many_args, &#34;open can be called either with 2 or 3 arguments, not more&#34;);__errordecl (__open_missing_mode, &#34;open with O_CREAT or O_TMPFILE in second argument needs 3 arguments&#34;);&lt;/p&gt;&lt;p&gt;__fortify_function intopen (const char *__path, int __oflag, ...){ if (__va_arg_pack_len () &amp;gt; 1) __open_too_many_args ();&lt;/p&gt;&lt;p&gt;if (__builtin_constant_p (__oflag)) { if (__OPEN_NEEDS_MODE (__oflag) &amp;amp;&amp;amp; __va_arg_pack_len () &amp;lt; 1) { __open_missing_mode (); return __open_2 (__path, __oflag); } return __open_alias (__path, __oflag, __va_arg_pack ()); }&lt;/p&gt;&lt;p&gt;if (__va_arg_pack_len () &amp;lt; 1) return __open_2 (__path, __oflag);&lt;/p&gt;&lt;p&gt;return __open_alias (__path, __oflag, __va_arg_pack ());}```&lt;/p&gt;&lt;p&gt;可以看到，它核心的思想就是根据 open 第三个参数的有无，调用相应的 &lt;code&gt;__open_2&lt;/code&gt; 或者 &lt;code&gt;__open_alias&lt;/code&gt; 函数，这样就不用再用 &lt;code&gt;va_args&lt;/code&gt; 方法了，并且如果传入了过多的参数，可以直接在编译期指出错误。例子：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;include &lt;fcntl.h&gt;&lt;/h1&gt;&lt;p&gt;int main() { open(&#34;123&#34;, 0, 0, 0, 0); return 0;}```&lt;/p&gt;&lt;p&gt;报错：&lt;/p&gt;&lt;p&gt;&lt;code&gt;cIn file included from /usr/include/fcntl.h:301, from &amp;lt;source&amp;gt;:2:In function &#39;open&#39;, inlined from &#39;main&#39; at &amp;lt;source&amp;gt;:5:5:/usr/include/x86_64-linux-gnu/bits/fcntl2.h:44:5: error: call to &#39;__open_too_many_args&#39; declared with attribute error: open can be called either with 2 or 3 arguments, not more 44 | __open_too_many_args (); | ^~~~~~~~~~~~~~~~~~~~~~~ASM generation compiler returned: 1In file included from /usr/include/fcntl.h:301, from &amp;lt;source&amp;gt;:2:In function &#39;open&#39;, inlined from &#39;main&#39; at &amp;lt;source&amp;gt;:5:5:/usr/include/x86_64-linux-gnu/bits/fcntl2.h:44:5: error: call to &#39;__open_too_many_args&#39; declared with attribute error: open can be called either with 2 or 3 arguments, not more 44 | __open_too_many_args (); | ^~~~~~~~~~~~~~~~~~~~~~~Execution build compiler returned: 1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Compiler Explorer:&lt;a href=&#34;https://godbolt.org/z/hebshz3P5&#34;&gt;https://godbolt.org/z/hebshz3P5&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;使用 C 宏&lt;/h2&gt;&lt;p&gt;和 Claude 聊了一下，是否能够用 C 宏来实现，它的回答是：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;define PRINTF(...) printf(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;&lt;h1&gt;define NARG(...) (sizeof((int[]){&lt;strong&gt;VA_ARGS&lt;/strong&gt;})/sizeof(int))&lt;/h1&gt;&lt;p&gt;int printf(const char *format, ...) { va_list args; va_start(args, format);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Access the variable arguments using va_arg based on // the number of arguments passed, obtained using NARGva_end(args);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// Usage:PRINTF(1, 2, 3); // Prints 1 2 3 PRINTF(1, 2, 3, 4); // Prints 1 2 3 4```&lt;/p&gt;&lt;p&gt;核心思路就是把参数列表放到数组里，然后让编译器去推断数组大小。沿着这个思路，实现出代码：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;&lt;h1&gt;include &lt;stdarg.h&gt;&lt;/h1&gt;&lt;p&gt;void my_printf_inner(int count, ...) { va_list args; va_start(args, count);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;for (int i = 0;i &amp;lt; count;i++) { printf(&#34;%d\n&#34;, va_arg(args, int));}va_end(args);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;&lt;h1&gt;define MY_PRINTF(...) do {int len=(sizeof((int[]){&lt;strong&gt;VA_ARGS&lt;/strong&gt;})/sizeof(int)); my_printf_inner(len, &lt;strong&gt;VA_ARGS&lt;/strong&gt;); } while(0);&lt;/h1&gt;&lt;p&gt;int main() { MY_PRINTF(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); return 0;}```&lt;/p&gt;&lt;p&gt;也是可以工作的。Compiler Explorer 链接：&lt;a href=&#34;https://godbolt.org/z/TxKb3YEcf&#34;&gt;https://godbolt.org/z/TxKb3YEcf&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;ChatGPT&lt;/h2&gt;&lt;p&gt;尝试询问了一下 ChatGPT：&lt;a href=&#34;https://shareg.pt/IXUKjYK&#34;&gt;https://shareg.pt/IXUKjYK&lt;/a&gt;，它可以写出额外传入 int 个数的版本，可以写出哨兵（传入 &lt;code&gt;-1&lt;/code&gt; 表示结束）的版本，提示了 builtin 以后，再提示 inline 和 always_inline，最后让它拆分成两个函数，得到的代码距离正确结果已经比较接近，但还是有一些问题。&lt;/p&gt;</description><link>https://jia.je/programming/2023/04/14/counting-arguments/</link> <pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/programming/2023/04/14/counting-arguments/</guid> </item> <item> <title>SCO OpenServer 6.0.0 虚拟机安装</title> <category>sco</category> <category>system</category> <category>unix</category> <category>unixware</category> <description>&lt;h1&gt;SCO OpenServer 6.0.0 虚拟机安装&lt;/h1&gt;&lt;h2&gt;安装过程&lt;/h2&gt;&lt;p&gt;首先从 &lt;a href=&#34;https://www.sco.com/support/update/download/product.php?pfid=12&amp;amp;prid=20&#34;&gt;https://www.sco.com/support/update/download/product.php?pfid=12&amp;amp;prid=20&lt;/a&gt; 下载 SCO OpenServer 的安装 ISO。尝试过用 QEMU 启动，但是会卡在无法读取硬盘的错误上。&lt;/p&gt;&lt;p&gt;最后使用 VirtualBox 7.0.6 成功启动，注意创建虚拟机的时候不要给太多内存，例如 4GB 就起不来，2GB 可以。硬盘我也只给了 4GB 的空间。&lt;/p&gt;&lt;p&gt;安装过程中会询问 License number 和 License code，可以选择使用 Evaluation License，或者使用下面参考文档中提供的 License。按照流程一直走就可以了。如果重启出现无法 mount root 的问题，就 poweroff 再开机。&lt;/p&gt;&lt;h2&gt;参考文档&lt;/h2&gt;&lt;p&gt;本博客参考了以下文档中的命令：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://virtuallyfun.com/2020/11/21/fun-with-openserver-6-and-mergepro/&#34;&gt;https://virtuallyfun.com/2020/11/21/fun-with-openserver-6-and-mergepro/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/system/2023/04/10/sco6/</link> <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/system/2023/04/10/sco6/</guid> </item> <item> <title>UnixWare 7.1.4 虚拟机安装</title> <category>system</category> <category>unix</category> <category>unixware</category> <description>&lt;h1&gt;UnixWare 7.1.4 虚拟机安装&lt;/h1&gt;&lt;h2&gt;安装过程&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&#34;https://www.sco.com/support/update/download/product.php?pfid=1&amp;amp;prid=6&#34;&gt;https://www.sco.com/support/update/download/product.php?pfid=1&amp;amp;prid=6&lt;/a&gt; 可以看到 UnixWare 7.1.4 的相关下载，其中首先要下载 UnixWare 的安装 ISO：&lt;a href=&#34;https://www.sco.com/support/update/download/release.php?rid=346&#34;&gt;https://www.sco.com/support/update/download/release.php?rid=346&lt;/a&gt;，尝试过用 QEMU 启动，会遇到找不到 CD-ROM 的问题，虽然通过设置 &lt;code&gt;ATAPI_DMA_DISABLE=YES&lt;/code&gt; 解决了，但是又遇到了找不到硬盘的问题。&lt;/p&gt;&lt;p&gt;最后换成了 VirtualBox 7.0.6。用 VirtualBox 创建虚拟机的时候，不要给太多内存，4GB 就会无法启动，2GB 可以，硬盘也不要给太多，4GB 就足够。&lt;/p&gt;&lt;p&gt;剩下就是按照安装界面一路默认即可，License 可以选择 Defer，使用 Evaluation License。&lt;/p&gt;&lt;p&gt;关机以后，修改启动顺序，把硬盘放到 CD 前，然后启动，就可以进入系统了。如果重启出现无法 mount root 的问题，就 poweroff 再开机。&lt;/p&gt;&lt;h2&gt;参考文档&lt;/h2&gt;&lt;p&gt;本博客参考了以下文档中的命令：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://virtuallyfun.com/2018/01/31/revisiting-a-unixware-7-1-1-install-on-qemu-kvm/&#34;&gt;https://virtuallyfun.com/2018/01/31/revisiting-a-unixware-7-1-1-install-on-qemu-kvm/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/system/2023/04/10/unixware7/</link> <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/system/2023/04/10/unixware7/</guid> </item> </channel></rss>