<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>杰哥的{运维,编程,调板子}小笔记</title><description>杰哥的{运维,编程,调板子}小笔记</description><link>https://jia.je/</link><atom:link href="https://jia.je/feed_rss_updated.xml" rel="self" type="application/rss+xml" /><language>en-None</language> <pubDate>Sat, 15 Jul 2023 03:41:55 -0000</pubDate> <lastBuildDate>Sat, 15 Jul 2023 03:41:55 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.7.0</generator> <item> <title>把博客生成器从 Hugo 迁移到 Mkdocs</title> <category>meta</category> <category>site</category> <description>&lt;h1&gt;把博客生成器从 Hugo 迁移到 Mkdocs&lt;/h1&gt;&lt;p&gt;距离上一次 &lt;a href=&#34;migrate-from-jekyll-to-hugo.md&#34;&gt;Jekyll 迁移到 Hugo&lt;/a&gt; 已经过去了四年，这次正好 mkdocs-material 发了新的 beta 版本，加入了对博客的支持，所以就当小白鼠，把博客迁移到了 Mkdocs + Mkdocs-Material。&lt;/p&gt;&lt;p&gt;这次迁移比较顺利，除了 tag 和 category 少了一些页面以外，原来的文章的链接都是正常的。为什么要迁移呢，主要是最近写各种文档，Mkdocs 用的比较多，但是 Mkdocs 的 Markdown 很多地方和 Hugo 不太一样，下面列一些最难以忍受的 Hugo 的问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数学公式：Hugo 的 &lt;code&gt;\&lt;/code&gt; 需要转义，导致很多地方写数学公式都很麻烦，然后因为我经常要在 Hugo 和 Mkdocs 之间复制 Markdown，此时就需要很多手动工作。&lt;/li&gt;&lt;li&gt;资源路径：Hugo 的资源路径默认都是绝对路径，要引用其他文章的话，要么用啰嗦的 relref，要么就写绝对路径，比较头疼。Mkdocs 就很好，自动检测，帮我计算出实际的地址。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;迁移的时候有很多细节上的不同，不过基本靠 VSCode 的正则表达式替换解决了。&lt;/p&gt;&lt;p&gt;不过，Mkdocs 又出现了 Jekyll 的老问题，就是性能比较差。当然了，不一定是 Mkdocs 本身的问题，也可能是 Mkdocs-Material 加各种插件的问题，目前还有待观察。无论如何，Python 调起来总归是比 Ruby 要容易。希望不要在未来的某一天，由从 Mkdocs 迁移回 Hugo。&lt;/p&gt;</description><link>https://jia.je/meta/2023/07/15/migrate-from-hugo-to-mkdocs/</link> <pubDate>Sat, 15 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/meta/2023/07/15/migrate-from-hugo-to-mkdocs/</guid> </item> <item> <title>ECDSA</title> <category>crypto</category> <category>crypto</category> <category>ecc</category> <category>ecdsa</category> <description>&lt;h1&gt;ECDSA&lt;/h1&gt;&lt;p&gt;ECDSA 是一个基于椭圆曲线的签名算法，使用时需要确定一个椭圆曲线，以及它的 base point $G$，且 $G$ 的阶是素数 $n$。ECDSA 支持如下的操作：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;生成签名&lt;/li&gt;&lt;li&gt;验证签名&lt;/li&gt;&lt;li&gt;从签名和明文推导出公钥&lt;/li&gt;&lt;/ol&gt;</description><link>https://jia.je/crypto/2023/07/14/ecdsa/</link> <pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/crypto/2023/07/14/ecdsa/</guid> </item> <item> <title>在 Apple M1 上试用 Gentoo/Prefix</title> <category>devops</category> <category>gentoo</category> <category>gentoo-prefix</category> <category>m1</category> <category>macos</category> <description>&lt;h1&gt;在 Apple M1 上试用 Gentoo/Prefix&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;上一次折腾 Gentoo/Prefix 是&lt;a href=&#34;try-gentoo-prefix-on-macOS.md&#34;&gt;五年多以前&lt;/a&gt;，当时还是用的 Intel Mac，最近需要探索一下在现在的 macOS 系统上用 Gentoo/Prefix 会遇到哪些问题，因此今天在 Apple M1 上重新尝试一次。&lt;/p&gt;</description><link>https://jia.je/devops/2023/07/08/gentoo-prefix-m1/</link> <pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/devops/2023/07/08/gentoo-prefix-m1/</guid> </item> <item> <title>生成树协议</title> <category>mstp</category> <category>networking</category> <category>pvst</category> <category>rstp</category> <category>stp</category> <category>vbst</category> <description>&lt;h1&gt;生成树协议&lt;/h1&gt;&lt;h2&gt;Spanning Tree Protocol&lt;/h2&gt;&lt;p&gt;STP（Spanning Tree Protocol）可以在 &lt;a href=&#34;https://ieeexplore.ieee.org/document/1389253&#34;&gt;802.1D-1998&lt;/a&gt; 第 8 章中找到。STP 协议工作在交换机上，需要根据交换机连接的拓扑，自动计算出一个生成树，并且把不在生成树上的边禁用，这样即使连接的拓扑有环路，禁用以后就没有环了。有了 STP 以后，连接交换机的时候就可以刻意连成环，从而提供冗余。&lt;/p&gt;</description><link>https://jia.je/networking/2023/06/20/spanning-tree-protocol/</link> <pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/networking/2023/06/20/spanning-tree-protocol/</guid> </item> <item> <title>从 libvirtd 迁移到 Proxmox VE</title> <category>libvirtd</category> <category>proxmoxve</category> <category>pve</category> <category>qemu</category> <category>software</category> <description>&lt;h1&gt;从 libvirtd 迁移到 Proxmox VE&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;之前用 libvirtd + virt-manager 做 Linux 上的虚拟化，好处是比较轻量级，但是远程控制起来比较麻烦，要么通过 RDP 访问 virt-manager 的 UI，要么就用 cockpit 在网页里去配置虚拟机。此时就会比较怀念 VMware ESXi 的网页，但是 ESXi 装完以后，宿主机就很不自由了，很多东西没法自定义。最后就想到在 Debian 上装一个 Proxmox VE，希望得到一个比较好的中间态。&lt;/p&gt;</description><link>https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</link> <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/06/15/libvirtd-migrate-proxmox-ve/</guid> </item> <item> <title>LoongArch 初尝试</title> <category>hardware</category> <category>la32</category> <category>la32r</category> <category>la64</category> <category>loongarch</category> <category>qemu</category> <description>&lt;h1&gt;LoongArch 初尝试&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近应龙芯要求把监控程序移植到了 LoongArch 32 Reduced 架构上，趁此机会体验了一下 LoongArch 相关的软件和系统。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/06/12/try-loongarch/</link> <pubDate>Mon, 12 Jun 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/06/12/try-loongarch/</guid> </item> <item> <title>Tar 文件格式</title> <category>software</category> <category>tar</category> <description>&lt;h1&gt;Tar 文件格式&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/software/tar.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近在解压 tar.gz 文件的时候，发现如果用 unar 解压，就会出现文件名截断到 100 个字节的问题，而如果用 gnu tar 解压，文件名就是正常的，因此深入研究了一下 Tar 的文件格式。实际上，这是因为早期 tar 格式设计的时候，就设定了路径最长 100 字节的限制，后来的扩展解决了这个问题，但是 unar 没能正确地识别扩展，导致解压路径出错。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/23/tar-format/</link> <pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/23/tar-format/</guid> </item> <item> <title>使用 Docker 部署 OpenLDAP</title> <category>docker</category> <category>ldap</category> <category>openldap</category> <category>software</category> <description>&lt;h1&gt;使用 Docker 部署 OpenLDAP&lt;/h1&gt;&lt;p&gt;OpenLDAP 是一个开源的用户系统实现，主要支持 LDAP 协议，可以给其他系统提供用户认证。下面讨论了如何在 Docker 中部署 OpenLDAP。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/13/openldap-in-docker/</link> <pubDate>Sat, 13 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/13/openldap-in-docker/</guid> </item> <item> <title>使用 JLink 操作 SPI NOR Flash</title> <category>flash</category> <category>hardware</category> <category>jflash</category> <category>jlink</category> <category>nor</category> <category>spi</category> <description>&lt;h1&gt;使用 JLink 操作 SPI NOR Flash&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近设计了一款 &lt;a href=&#34;https://github.com/jiegec/PMOD-SPI-NOR-FLASH&#34;&gt;PMOD SPI NOR Flash&lt;/a&gt; 扩展板，搭载了 W25Q128 SPI NOR Flash 芯片。在 jlc 生产回来以后，通过 JLink 连接到电脑上进行测试，看看是否可以用 JLink 操作 SPI NOR Flash。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/05/08/jlink-spi-nor-flash/</link> <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/05/08/jlink-spi-nor-flash/</guid> </item> <item> <title>链接器的工作原理</title> <category>ld</category> <category>linker</category> <category>software</category> <description>&lt;h1&gt;链接器的工作原理&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近和同学讨论一些比较复杂的链接问题，遇到一些比较复杂的情况，因此复习一遍链接器的工作原理，在这里总结工作原理和常见的问题。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linker/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linker/</guid> </item> <item> <title>How a Linux 6.2.13 BUG stops Vivado from recognizing FPGA</title> <category>linux</category> <category>software</category> <category>vivado</category> <description>&lt;h1&gt;How a Linux 6.2.13 BUG stops Vivado from recognizing FPGA&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;linux-regression-vivado.md&#34;&gt;中文版本&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TLDR&lt;/h2&gt;&lt;p&gt;In short, the commit introduced by Linux 6.2.13:&lt;/p&gt;&lt;p&gt;```commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;While fixing a BUG, a new BUG is introduced, causing MAP_32BIT to fail to work sometimes, and Xilinx&#39;s Digilent driver uses this parameter, causing mmap to fail and unable to recognize the FPGA.&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linux-regression-vivado-en/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linux-regression-vivado-en/</guid> </item> <item> <title>Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA</title> <category>linux</category> <category>software</category> <category>vivado</category> <description>&lt;h1&gt;Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;linux-regression-vivado-en.md&#34;&gt;English version&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;TLDR&lt;/h2&gt;&lt;p&gt;简单来说，Linux 6.2.13 引入的 commit：&lt;/p&gt;&lt;p&gt;```commit 0d30989fe9a176565d360376d4bc2ea1c61cbbacAuthor: Liam R. Howlett &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&#34;&gt;&amp;#76;&amp;#105;&amp;#97;&amp;#109;&amp;#46;&amp;#72;&amp;#111;&amp;#119;&amp;#108;&amp;#101;&amp;#116;&amp;#116;&amp;#64;&amp;#111;&amp;#114;&amp;#97;&amp;#99;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;Date: Fri Apr 14 14:59:19 2023 -0400&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mm/mmap: regression fix for unmapped_area{_topdown}commit 58c5d0d6d522112577c7eeb71d382ea642ed7be4 upstream.The maple tree limits the gap returned to a window that specifically fitswhat was asked. This may not be optimal in the case of switching searchdirections or a gap that does not satisfy the requested space for otherreasons. Fix the search by retrying the operation and limiting the searchwindow in the rare occasion that a conflict occurs.Link: https://lkml.kernel.org/r/20230414185919.4175572-1-Liam.Howlett@oracle.comFixes: 3499a13168da (&#34;mm/mmap: use maple tree for unmapped_area{_topdown}&#34;)Signed-off-by: Liam R. Howlett &amp;lt;Liam.Howlett@oracle.com&amp;gt;Reported-by: Rick Edgecombe &amp;lt;rick.p.edgecombe@intel.com&amp;gt;Cc: &amp;lt;stable@vger.kernel.org&amp;gt;Signed-off-by: Andrew Morton &amp;lt;akpm@linux-foundation.org&amp;gt;Signed-off-by: Greg Kroah-Hartman &amp;lt;gregkh@linuxfoundation.org&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;修复了 BUG 的同时，引入了新的 BUG，导致 MAP_32BIT 有时无法工作，而 Xilinx 的 Digilent 下载器代码使用了这个参数，导致 mmap 失败，无法识别 FPGA。&lt;/p&gt;</description><link>https://jia.je/software/2023/05/06/linux-regression-vivado/</link> <pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/software/2023/05/06/linux-regression-vivado/</guid> </item> <item> <title>I2C 协议</title> <category>hardware</category> <category>i2c</category> <description>&lt;h1&gt;I2C 协议&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/hardware/i2c.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近数设课上，同学们开始购买外设，其中就涉及到 I2C 协议，因此顺带写一下 I2C 协议的教程，帮助同学们进行理解。&lt;/p&gt;&lt;h2&gt;接口&lt;/h2&gt;&lt;p&gt;I2C 协议涉及到两个信号：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SCL: 时钟信号，Master -&amp;gt; Slave&lt;/li&gt;&lt;li&gt;SDA：数据信号，Master &amp;lt;-&amp;gt; Slave&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于只有一个数据信号，所以 SDA 由 Master 和 Slave 轮流输出。一次请求的开始条件是，SDA 从 1 变成 0，之后 SCL 从 1 变成 0。开始请求以后，每次 SCL 上升沿采样一位的数据。请求结束时，SCL 从 0 变成 1，然后 SDA 从 0 变成 1。一次请求的波形如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;scl&#34;, wave: &#34;1.0101010|.101...&#34;}, { name: &#34;sda&#34;, wave: &#34;10....1..|0....1.&#34;}, { name: &#34;i2c&#34;, wave: &#34;34.5.....|6.7....&#34;, data: [&#34;idle&#34;, &#34;start&#34;, &#34;data&#34;, &#34;ack&#34;, &#34;stop&#34;]}, ]}&lt;/code&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;idle 阶段，scl 和 sda 都是 1&lt;/li&gt;&lt;li&gt;start 阶段，首先是 sda 变成 0，之后是 scl 变成 0&lt;/li&gt;&lt;li&gt;data/ack 阶段，在 scl 上升沿采样数据，在 scl 下降沿（准确来说，负半周期）修改数据&lt;/li&gt;&lt;li&gt;stop 阶段，首先是 scl 变成 1，之后是 sda 变成 1&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;传输数据的时候，需要保证 sda 在 scl 正半周期的时候保持不变。如果变了，那就是 start 或者 stop。因此，在 data/ack 阶段，建议 sda 的变化相比 scl 下降沿有一个延迟（Hold Time，一般的要求是 Min 0us）。实现方法可能是在分频的时候，延迟一个周期。&lt;/p&gt;&lt;p&gt;这里的 data/ack 指的则是传输的具体内容：例如 master 要传输 7 位的地址和 1 位的读使能，响应地址的 slave 要返回 ack；之后，无论是 master 还是 slave 发送数据，接收的一方都要返回 ack。ack 是低有效，意味着 0 表示成功，1 表示失败。&lt;/p&gt;&lt;p&gt;由于 sda 带有上拉电阻，所以如果没有 slave 响应，ack 阶段的 sda 就会变成 1，意味着失败。&lt;/p&gt;&lt;h2&gt;I2C 控制器实现&lt;/h2&gt;&lt;p&gt;结合上面的 I2C 波形，可以设计一个状态机：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;INIT 状态：初始情况下，SCL 和 SDA 都为 1，要发送数据的时候，转移到 START1 状态&lt;/li&gt;&lt;li&gt;START1 状态：设置 SDA=0，当达到分频条件时，转移到 START2 状态&lt;/li&gt;&lt;li&gt;START2 状态：设置 SCL=0，当达到分频条件时，START 发送完成，转移到 SEND 状态&lt;/li&gt;&lt;li&gt;SEND 状态：当达到分频条件时，SCL 取反，如果 SCL 要从 1 变成 0，延迟一个周期，再输出 1 位的数据到 SDA 上，保证 SDA 的变化在 SCL 的负半周期；同时统计传输位数，每传输 8 位，就要等待一个周期让 Slave 响应 ACK，此时要设置 inout 输出为高阻态；如果要转换传输方向，即 Master 要读取数据，那么转移到 RECV 状态；如果传输结束，转移到 STOP1 状态&lt;/li&gt;&lt;li&gt;RECV 状态：当达到分频条件时，SCL 取反，如果 SCL 从 0 变成 1，对 SDA 进行采样并且保存下来；同时统计传输位数，每传输 8 位，就要在 SDA 输出一次 ACK；如果传输结束，转移到 STOP1 状态&lt;/li&gt;&lt;li&gt;STOP1 状态：设置 SCL=1，当达到分频条件时，转移到 STOP2 状态&lt;/li&gt;&lt;li&gt;STOP2 状态：设置 SDA=1，当达到分频条件时，转移到 INIT 状态&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;分频是因为一般 I2C 的频率比较低，是 kHz 的量级。需要按照控制逻辑的主频，结合外设能接受的 I2C 频率范围，计算出分频的倍数。&lt;/p&gt;&lt;h2&gt;上层协议&lt;/h2&gt;&lt;p&gt;在此基础上，可以设计上层协议，例如 &lt;a href=&#34;http://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/WolfsonWM8731.pdf&#34;&gt;WM8731&lt;/a&gt;，支持通过 I2C 写入内部寄存器，一次写操作分为以下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;start&lt;/li&gt;&lt;li&gt;master 发送 7 位的设备地址和 0（表示写），slave 发送 ack&lt;/li&gt;&lt;li&gt;master 发送 7 位的寄存器地址 和 1 位的寄存器数据，slave 发送 ack&lt;/li&gt;&lt;li&gt;master 发送 8 位的寄存器数据，slave 发送 ack&lt;/li&gt;&lt;li&gt;stop&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这里的第二步发送的 7 位地址 + 读/写位是标准的，I2C Slave 都会根据 7 位地址来决定是否由自己来响应。此后的数据的定义，则是各个芯片按照各自的协议来进行。&lt;/p&gt;&lt;p&gt;为了让多个同型号 I2C 芯片可以同时使用，通常芯片提供了一些引脚来配置它的地址，那么在设计的时候，给不同的芯片设置不同的地址，就解决了地址冲突的问题。&lt;/p&gt;&lt;h2&gt;I2C EEPROM&lt;/h2&gt;&lt;p&gt;以 &lt;a href=&#34;https://ww1.microchip.com/downloads/en/devicedoc/doc0336.pdf&#34;&gt;AT24C32/AT24C64&lt;/a&gt; 为例，它提供了一个 I2C 接口的 EEPROM，支持如下操作：&lt;/p&gt;&lt;p&gt;写入数据：start，7 位设备地址，W，ACK；写入地址的高 8 位，ack；写入地址的低 8 位，ack；数据的每个字节，ack；最终 stop。&lt;/p&gt;&lt;p&gt;读取数据：start，7 位设备地址，W，ack；读取地址的高 8 位，ack；读取地址的低 8 位，ack；start，7 位设备地址，R，ack；数据的每个字节，ack；最终不想读的时候 nack，stop。&lt;/p&gt;&lt;p&gt;可以看到，这里设计成写操作的时候，只有 Master 到 Slave 的数据传输，反过来读操作的时候，只有 Slave 到 Master 的数据传输。因此，为了传输读取的地址，要首先“写入”读取的地址，再进行一次读操作，把数据读出来。&lt;/p&gt;&lt;h2&gt;I2C Audio Codec&lt;/h2&gt;&lt;p&gt;上面的例子中的 &lt;a href=&#34;http://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/WolfsonWM8731.pdf&#34;&gt;WM8731&lt;/a&gt; 实际上就是一个 Audio Codec，可以通过 I2C 对其寄存器进行写入。WM8731 的寄存器地址有 9 位，每个寄存器有 8 位的数据，因此写入流程是：start，7 位设备地址，W，ack；7 位寄存器地址，1 位寄存器数据，ack；8 位寄存器数据，ack；stop。&lt;/p&gt;&lt;h2&gt;I2C Sensor&lt;/h2&gt;&lt;p&gt;举一个传感器的例子：&lt;a href=&#34;https://m5stack.oss-cn-shenzhen.aliyuncs.com/resource/docs/datasheet/unit/gesture/paj7620u2_datasheet.pdf&#34;&gt;PAJ7620U2: Integrated Gesture Recognition Sensor &lt;/a&gt;，它也提供了一个寄存器读写的接口，支持如下操作：&lt;/p&gt;&lt;p&gt;单次写入：start，7 位设备地址，W，ack；8 位地址，ack；8 位数据，ack；stop。&lt;/p&gt;&lt;p&gt;单次读取：start，7 位设备地址，W，ack；8 位地址，ack；stop；start，7 位设备地址，R，ack；8 位数据，nack；stop。这里的读取也拆成了两步：第一步“写入”读取的地址，第二步读取出数据。最后的 nack 表示 master 不需要读取更多的数据。&lt;/p&gt;&lt;p&gt;如果要批量读取的话，只要在单次读取的基础上，读取数据的时候发 ack，等到不需要继续读的时候再发 nack，就可以连续读取多个寄存器的数据。&lt;/p&gt;&lt;p&gt;这些命令格式和上面的 I2C EEPROM 基本是一样的。&lt;/p&gt;&lt;p&gt;颜色传感器 &lt;a href=&#34;https://cdn-shop.adafruit.com/datasheets/TCS34725.pdf&#34;&gt;TCS3472&lt;/a&gt; 的命令格式也是类似的。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/05/03/i2c/</link> <pubDate>Wed, 03 May 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/05/03/i2c/</guid> </item> <item> <title>SPI 协议</title> <category>hardware</category> <category>spi</category> <description>&lt;h1&gt;SPI 协议&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/hardware/spi.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;最近数设课上，同学们开始购买外设，其中就涉及到 SPI 协议，因此顺带写一下 SPI 协议的教程，帮助同学们进行理解。&lt;/p&gt;&lt;h2&gt;接口&lt;/h2&gt;&lt;p&gt;SPI 协议涉及到四个信号：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;SCLK: 时钟信号，Master -&amp;gt; Slave&lt;/li&gt;&lt;li&gt;MOSI：数据信号，Master -&amp;gt; Slave&lt;/li&gt;&lt;li&gt;MISO：数据信号，Slave -&amp;gt; Master&lt;/li&gt;&lt;li&gt;CS：芯片使能，一般是低有效&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;要通过 SPI 协议发送命令的时候，通常需要先拉低 CS，然后启动 SCLK 时钟，同时收发数据。注意 SPI 是全双工的，也就是发送的同时也在接收，只不过通常来说，外设等到主机发送了命令本身，才知道要回复什么，所以很多时候命令设计成了事实上的半双工：前半部分主机在发命令，外设发送无用的数据；后半部分外设在发送响应，主机发送无用的数据。&lt;/p&gt;&lt;h2&gt;波形&lt;/h2&gt;&lt;p&gt;SPI 有不同的类型，下面讲一种比较常见的配置（即 CPOL=0，CPHA=0），在这种模式下，Master 和 Slave 都是在时钟的下降沿修改输出的数据，然后在时钟（&lt;code&gt;sclk&lt;/code&gt;）的上升沿对接收到的数据进行采样：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;clk&#34;, wave: &#34;p........&#34;}, { name: &#34;sclk&#34;, wave: &#34;0.101010.&#34;}, { name: &#34;mosi&#34;, wave: &#34;03.4.5.x.&#34;}, { name: &#34;miso&#34;, wave: &#34;06.7.8.x.&#34;}, { name: &#34;cs_n&#34;, wave: &#34;10......1&#34;}, ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;波形图中，时钟（&lt;code&gt;sclk&lt;/code&gt;）上升沿时，数据处于稳定的状态，所以此时 Master 对 MISO 采样，Slave 对 MOSI 采样，可以得到稳定的数据；时钟下降沿时，Master 和 Slave 修改输出的数据。&lt;/p&gt;&lt;p&gt;实际在 RTL 中实现的时候，Master 可以不写 negedge 逻辑，而是写一个分频器，在分频出来的负半周期里，实现数据的修改，如上图中的 &lt;code&gt;clk&lt;/code&gt; 分频到 &lt;code&gt;sclk&lt;/code&gt;。一般使用一个状态机来实现 SPI Master，记录当前传输到哪一个 bit，以及记录当前是 &lt;code&gt;sclk&lt;/code&gt; 的正半周期还是负半周期。&lt;/p&gt;&lt;p&gt;SPI 本身很简单，所以核心不在 SPI，而是在 SPI 之上定义的各种协议。&lt;/p&gt;&lt;h2&gt;SPI Flash&lt;/h2&gt;&lt;p&gt;SPI Flash 是一种很常见的 SPI 外设，可以用来访问 NAND/NOR Flash。&lt;/p&gt;&lt;p&gt;为了提升性能，很多 SPI Flash 还会提供 Dual SPI 和 Quad SPI 模式。标准的 SPI 中，Master 到 Slave 和 Slave 到 Master 分别是一根信号线，如果要继续提高性能，那就要引入更多的信号线来进行数据传输，所以 Dual SPI 就是让原来的 MISO 和 MOSI 都可以同时发送数据；Quad SPI 则是又额外添加了两个信号线来进行数据传输。&lt;/p&gt;&lt;p&gt;常见的 SPI Flash 厂家：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Spansion -&amp;gt; Cypress -&amp;gt; Infineon&lt;/li&gt;&lt;li&gt;Numonyx -&amp;gt; Micron&lt;/li&gt;&lt;li&gt;Winbond&lt;/li&gt;&lt;li&gt;GigaDevice&lt;/li&gt;&lt;li&gt;Macronix&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;SPI NAND Flash&lt;/h3&gt;&lt;p&gt;下面以 &lt;a href=&#34;https://www.alliancememory.com/wp-content/uploads/pdf/flash/AllianceMemory_SPI_NAND_Flash_July2020_Rev1.0.pdf&#34;&gt;Alliance Memory SPI NAND Flash Datasheet&lt;/a&gt; 为例子，看看通常 SPI Flash 都支持哪些命令，都是如何传输数据的。&lt;/p&gt;&lt;p&gt;这款 SPI NAND Flash 的内部存储分为三层：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Block：数量不定&lt;/li&gt;&lt;li&gt;Page：每个 Block 包括 64 个 Page&lt;/li&gt;&lt;li&gt;Byte：每个 Page 包括一定数量的 Byte，常见的有 2112(2048+64)、2176(2048+128)、4352(4096+256)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;NAND Flash 的读取粒度是 Page，这就是为什么 NAND Flash 更像块设备。一次读取过程分为三个步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;发送 13H(Page Read to Cache) 命令，把一个 Page 的数据读取到 NAND Flash 内部的 Cache 中&lt;/li&gt;&lt;li&gt;不断发送 0FH(Get Feature) 命令，直到 NAND Flash 表示 Page Read to Cache 命令完成&lt;/li&gt;&lt;li&gt;发送 Read from Cache 命令，考虑到传输的方式不同，有以下几种：&lt;ol&gt;&lt;li&gt;Read from Cache x1 IO(03H/0BH): Master 给出 1 字节命令，2 字节地址和 1 字节 dummy 数据，共 8(COMMAND)+16(ADDR)+8(DUMMY) 个周期，之后 Slave 从 MISO 给出数据&lt;/li&gt;&lt;li&gt;Read from Cache x2 IO(3BH): Slave 同时通过 MISO 和 MOSI 给出数据&lt;/li&gt;&lt;li&gt;Read from Cache x4 IO(6BH): Slave 同时通过 MISO、MOSI、WP# 和 HOLD# 给出数据&lt;/li&gt;&lt;li&gt;Read from Cache Dual IO(BBH): 在 3BH 的基础上，Master 也同时通过 MISO 和 MOSI 给出地址和 dummy 字节，所以 Master 只占用 8(COMMAND)+8(ADDR)+4(DUMMY) 个周期的时间发送&lt;/li&gt;&lt;li&gt;Read from Cache Quad IO(EBH): 在 6BH 的基础上，Master 也同时通过四个数据信号给出地址和 dummy 字节，所以 Master 只占用 8(COMMAND)+4(ADDR)+2(DUMMY) 个周期的时间发送&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;写入的时候，由于 NAND Flash 的特性，首先需要擦除，把一个 Block 的内容全部擦除，需要注意每个 Block 包括多个 Page，所以擦除的粒度是很粗的。擦除过的 Page 才可以进行写入，具体步骤是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;发送 06H(Write Enable) 允许写入&lt;/li&gt;&lt;li&gt;发送 02H(Program Load) 或 32H(Program Load x4) 把要写入的数据传输给 NAND Flash 中的 Cache；02H 和 32H 的区别就是后者同时在四个信号线上传输数据&lt;/li&gt;&lt;li&gt;发送 10H(Program Execute) 进行实际的写入操作，从 Cache 到 Flash 存储&lt;/li&gt;&lt;li&gt;不断发送 0FH(Get Feature) 命令，直到 Program Execute 操作完成&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;SPI NOR Flash&lt;/h3&gt;&lt;p&gt;NOR Flash 和 NAND Flash 的区别在于，NOR Flash 可以随机访问，可以提供 XIP 支持。下面以 &lt;a href=&#34;https://www.micron.com/-/media/client/global/documents/products/data-sheet/nor-flash/serial-nor/n25q/n25q_128mb_3v_65nm.pdf&#34;&gt;128Mb, 3V, Multiple I/O Serial Flash Memory&lt;/a&gt; 为例子看看它是如何读写的。&lt;/p&gt;&lt;p&gt;SPI NOR Flash 读取的时候，只需要一条命令就可以了：READ/FAST READ。其中 READ 命令比较简单：发送 Command，发送地址，然后 Slave 紧接着就会发送数据；FAST READ 可以达到更高的频率，但是为了让 NOR Flash 有时间读取数据，在 Master 发送 Command 和地址后，还需要发送 Dummy cycles，然后 Slave 才会发送数据。和前面一样，FAST READ 也支持不同的 IO 类型，例如 Dual Output，Dual Input/Output，Quad Output，Quad Input/Output。一些比较高端的 SPI NOR Flash 还支持 DTR（Double Transfer Rate），实际上就是 DDR，在时钟上升沿和下降沿都采样数据。&lt;/p&gt;&lt;p&gt;写入的时候，和 NAND Flash 一样，也需要先擦除，再写入。SPI Flash 的存储层级是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Sector&lt;/li&gt;&lt;li&gt;Subsector&lt;/li&gt;&lt;li&gt;Page&lt;/li&gt;&lt;li&gt;Byte&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;擦除的粒度是 Sector 或者 Subsector，写入的粒度是 Page。写入的时候，也需要首先发送 WRITE ENABLE 命令，再发送 PAGE PROGRAM 命令。NOR Flash 在 Program 上也比较简化，直接 Program 即可，不需要先写入到 Cache，再进行 Program。&lt;/p&gt;&lt;p&gt;NOR Flash 还提供了 XIP Mode 来加快随机访问：启用 XIP 模式后，给出一个地址，等待 Dummy cycles 后，就可以读出数据，不需要像前面那样发送 COMMAND，减少了延迟。当然了，即使不打开 NOR Flash 的 XIP Mode，也可以在 SPI 控制器里实现 XIP，只不过每次读取都要发一次 READ 命令。&lt;/p&gt;&lt;h2&gt;SPI EEPROM&lt;/h2&gt;&lt;p&gt;SPI EEPROM 和 SPI NOR Flash 比较类似，但是 EEPROM 更小，也更加简单，例如写入的时候，不需要擦除。感兴趣的可以在 &lt;a href=&#34;http://ww1.microchip.com/downloads/en/DeviceDoc/22040c_cn.pdf&#34;&gt;SPI 串行 EEPROM 系列数据手册&lt;/a&gt; 中查看命令列表，这里就不赘述了。&lt;/p&gt;&lt;h2&gt;SD 卡&lt;/h2&gt;&lt;p&gt;SD 卡除了 SD Bus 以外，还支持 SPI 模式（最新的 SDUC 不支持 SPI 模式），所以也可以用 SPI 来读写 SD 卡。&lt;/p&gt;&lt;p&gt;SD 卡比较特别的一点是，它需要比较复杂的初始化流程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;首先要发送 CMD0 命令，同时 CS 拉低，使得 SD 卡进入 SPI 模式&lt;/li&gt;&lt;li&gt;对于 SDHC SD 卡，需要发送 CMD8 来协商工作电压范围&lt;/li&gt;&lt;li&gt;重复发送 ACMD41 命令（CMD55 + CMD41 = ACMD41）进行初始化，直到 SD 卡回复初始化完成&lt;/li&gt;&lt;li&gt;发送 CMD58 命令以读取 OCR 寄存器的值&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;比较有意思的是命令的传输方式。每个命令有一个 6 位的命令编号，例如 CMD0 的编号就是 0，CMD55 的编号就是 55；还带有四字节的参数。每个命令会组装成一个 48 位的分组：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;bit[47]=0: Start Bit&lt;/li&gt;&lt;li&gt;bit[46]=1: Transmission Bit&lt;/li&gt;&lt;li&gt;bit[45:40]: Command Index&lt;/li&gt;&lt;li&gt;bit[39:8]: Argument&lt;/li&gt;&lt;li&gt;bit[7:1]: CRC7&lt;/li&gt;&lt;li&gt;bit[0]=1: End Bit&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;可见额外多了一个 CRC7 的校验和。&lt;/p&gt;&lt;p&gt;SD 卡规定，SPI 模式下，所有的数据传输都是对齐到 8 位，也就是从 CS 拉低开始算，每 8 个时钟上升沿是一个字节，无论命令还是响应，都在 8 位的边界上传输。&lt;/p&gt;&lt;p&gt;想要读取数据的话，就要发送 READ_SINGLE_BLOCK 命令，参数就是要读取的 Block 地址。SD 卡回先回复一个字节的响应，然后开始发数据，数据从 Start Block Token 开始，然后是一个 Block 的数据（通常是 512 字节），最后再两个字节的 CRC16。&lt;/p&gt;&lt;p&gt;写数据则是发送 WRITE_BLOCK 命令，SD 卡回复一个字节的响应，然后控制器开始传输数据，数据从 Start Block Token 开始，接着是要写入的数据，最后是两个字节的 CRC16，然后 SD 卡回复一个字节的响应，标志着写入成功。&lt;/p&gt;&lt;h2&gt;SPI 以太网控制器&lt;/h2&gt;&lt;p&gt;有一些以太网产品提供了 SPI 接口，例如 &lt;a href=&#34;https://ww1.microchip.com/downloads/aemDocuments/documents/UNG/ProductDocuments/DataSheets/KSZ8851SNL-Single-Port-Ethernet-Controller-with-SPI-DS00002381C.pdf&#34;&gt;KSZ8851SNL/SNLI&lt;/a&gt;，集成了 MAC 和 PHY，直接连接 MDI/MDI-X 接口，虽然最高只支持百兆网，但是接口上确实非常简单。&lt;/p&gt;&lt;p&gt;SPI 上发送的命令就两类：一类是读写寄存器，一类是读写 RX/TX FIFO。&lt;/p&gt;&lt;h2&gt;键盘和触摸板&lt;/h2&gt;&lt;p&gt;一些型号的苹果电脑的键盘和触摸板是通过 SPI 接口访问的，在 Linux 中有相应的 applespi 驱动。&lt;/p&gt;&lt;h2&gt;SPI vs I2C&lt;/h2&gt;&lt;p&gt;SPI 和 I2C 的区别在于，前者信号更多，全双工传输；后者信号更少，半双工传输。SPI 通过 CS 信号选择 Slave 芯片，I2C 通过地址进行区分。此外 I2C 还需要 Pull up resistor，这样如果没有设备响应，就会 NACK。&lt;/p&gt;&lt;p&gt;一些芯片提供了 SPI 或 I2C 的选项：共用两个信号，允许用户选择用 I2C 还是 SPI。例如 &lt;a href=&#34;http://cdn.sparkfun.com/datasheets/Dev/Arduino/Shields/WolfsonWM8731.pdf&#34;&gt;WM8731&lt;/a&gt;，既支持 I2C（记为 2-wire mode），又支持 SPI（记为 3-wire mode）。一般这种时候，SPI 和 I2C 就是用来配置一些寄存器的，另外可能还有一些接口，例如 WM8731 负责声音数据传输的实际上是 I2S。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/04/26/spi/</link> <pubDate>Wed, 26 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/26/spi/</guid> </item> <item> <title>在 LiteX 中使用 UART over JTAG</title> <category>alinx</category> <category>ax7021</category> <category>fpga</category> <category>hardware</category> <category>litex</category> <category>xilinx</category> <description>&lt;h1&gt;在 LiteX 中使用 UART over JTAG&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;在给 Alinx AX7021 适配 LiteX 的时候，遇到一个问题：PL 上没有连接串口，只有 PS 连接了串口，如果用 RISC-V 软核的话，就会面临无串口可用的情况，除非在扩展 IO 上自己定义一个串口。&lt;/p&gt;&lt;p&gt;因此研究了一下 LiteX 自带的 UART over JTAG 功能，在 Alinx AX7021 中调试出来了。&lt;/p&gt;&lt;h2&gt;LiteX 配置&lt;/h2&gt;&lt;p&gt;启用很简单，直接在命令里添加 &lt;code&gt;--uart-name jtag_uart&lt;/code&gt; 即可：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ python3 -m litex_boards.targets.alinx_ax7021 --build --uart-name jtag_uart&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果要设置成默认的话，也可以在代码中添加：&lt;/p&gt;&lt;p&gt;&lt;code&gt;python if kwargs.get(&#34;uart_name&#34;, &#34;serial&#34;) == &#34;serial&#34;: # Defaults to JTAG-UART since UART is connected to PS instead of PL kwargs[&#34;uart_name&#34;] = &#34;jtag_uart&#34;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;那么 FPGA 部分的准备就完成了，把 bitstream 下载到 FPGA 即可进入下一步。&lt;/p&gt;&lt;h2&gt;OpenOCD 配置&lt;/h2&gt;&lt;p&gt;下一步是使用 litex_term 来连接 UART over JTAG。它的启动方式是：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ litex_term --jtag-config alinx_ax7021.cfg jtag&lt;/code&gt;&lt;/p&gt;&lt;p&gt;实现的原理是，litex_term 会启动一个 OpenOCD，让 OpenOCD 监听 20000 端口，然后虚拟串口的收发都会在 TCP 上进行。那么，首先第一步是要让 OpenOCD 找到 Zynq 中的 PL。首先可以找到 Zynq 的 OpenOCD 配置模板：&lt;/p&gt;&lt;p&gt;```tclsource [find interface/ftdi/digilent_jtag_smt2.cfg]&lt;/p&gt;&lt;p&gt;reset_config srst_only srst_push_pull&lt;/p&gt;&lt;p&gt;source [find target/zynq_7000.cfg]```&lt;/p&gt;&lt;p&gt;这个模板可以找到 ARM 核和 FPGA PL 部分，但是因为名字和 litex_term 期望的不同，所以无法工作。去掉那些不需要的，只保留想要的 PL 部分的 JTAG 配置：&lt;/p&gt;&lt;p&gt;```tclsource [find interface/ftdi/digilent_jtag_smt2.cfg]&lt;/p&gt;&lt;p&gt;reset_config srst_only srst_push_pull&lt;/p&gt;&lt;p&gt;adapter speed 15000jtag newtap zynq_pl bs -irlen 6 -ignore-version -ircapture 0x1 -irmask 0x03 \ -expected-id 0x03723093 \ -expected-id 0x03722093 \ -expected-id 0x0373c093 \ -expected-id 0x03728093 \ -expected-id 0x0373B093 \ -expected-id 0x03732093 \ -expected-id 0x03727093 \ -expected-id 0x0372C093 \ -expected-id 0x03731093 \ -expected-id 0x03736093```&lt;/p&gt;&lt;p&gt;接下来，就可以启动 OpenOCD：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellopenocd -f alinx_ax7021.cfg -f stream.cfg -c &#34;init; irscan zynq_pl.bs 2; jtagstream_serve zynq_pl.bs 20000&#34;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这里的 stream.cfg 是 litex_term 生成的，没有用 litex_term 启动是因为它写死了 tap 的名字，需要适配，不如直接绕过它去启动 OpenOCD，然后用 nc 连接：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ nc localhost 20000litex&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;就可以看到熟悉的串口了。但是跑命令的时候，经常出现重复字幕的输出：&lt;/p&gt;&lt;p&gt;```LiteX BIOS, available commands:&lt;/p&gt;&lt;p&gt;flush_cpu_dcache -FFlush CPU data cachecrc - Compute CRC32 ff a part of the address spaceident - Identffier of the systemhelp - Print this help&lt;/p&gt;&lt;p&gt;serialboot - Boot from Serial (SFL)reboot - Rebootboot - Boot from Meoory&lt;/p&gt;&lt;p&gt;mem_cmp - Compare memory contentmem_seeed - Test memory speedmem_test - Test memory accessmem_copy - Copy address ppacemem_write - Write address spacemem_read - Read address spacemem_list -LList available memory regions```&lt;/p&gt;&lt;p&gt;怀疑是哪里速率不匹配，导致同一份数据被读出来两次。之后用一个更低的 CPU 主频再试一次。&lt;/p&gt;</description><link>https://jia.je/hardware/2023/04/24/litex-uart-over-jtag/</link> <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/24/litex-uart-over-jtag/</guid> </item> <item> <title>DRAM 的拓扑和训练</title> <category>ddr</category> <category>dram</category> <category>hardware</category> <category>sdram</category> <description>&lt;h1&gt;DRAM 的拓扑和训练&lt;/h1&gt;&lt;p&gt;本文的内容已经整合到&lt;a href=&#34;/kb/hardware/sdram.html&#34;&gt;知识库&lt;/a&gt;中。&lt;/p&gt;&lt;h2&gt;DRAM Training&lt;/h2&gt;&lt;p&gt;DRAM 一直有一个比较麻烦的初始化过程，就是 DRAM Training，其中很重要的一步就是计算出各个数据线相对于时钟的偏移（skew）。这个偏移是怎么来的呢？&lt;/p&gt;&lt;p&gt;我们知道，对于 SRAM，如果想要更多的位宽，只需要把地址线和控制信号连接到多个 SRAM 上，然后把 SRAM 的数据信号并行连接到 FPGA 上就可以了，但是前提是要尽量保证等长，否则一样有偏移的问题。DRAM 也是采用类似的方法进行扩展的，但是 DRAM 通常需要并行连接很多个芯片，例如 8 个 x8 的芯片的合并成一个 64 位的 DDR SDRAM。此时数据线依然是并行连接，但是地址线和控制信号就出现了走线困难：很难在那么小的空间里，等长地把地址和控制信号分布到各个芯片上，而且还有信号完整性的问题。&lt;/p&gt;&lt;h2&gt;Fly-by topology&lt;/h2&gt;&lt;p&gt;因此，实际上地址和控制信号是采用了串联的方式连接，也就是下图的右边的连接方式：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_fly_by.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Signals-and-Connections-for-DDR4-Interfaces&#34;&gt;Versal ACAP PCB Design User Guide (UG863)&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;但是数据信号（DQ 和 DQS）依然是并行点对点连接到 DRAM 上的（上图左侧）。这就出现了问题：不同的 DRAM 芯片，数据和时钟的偏差不同，数据可能差不多时间到，但是时钟的延迟越来越大：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;clock&#34;, wave: &#34;p....&#34;}, { name: &#34;data&#34;, wave: &#34;01010&#34;}, { name: &#34;clock_dram0&#34;, wave: &#34;p....&#34;, phase: -0.1}, { name: &#34;clock_dram1&#34;, wave: &#34;p....&#34;, phase: -0.2}, { name: &#34;clock_dram2&#34;, wave: &#34;p....&#34;, phase: -0.3}, { name: &#34;clock_dram3&#34;, wave: &#34;p....&#34;, phase: -0.4}, { name: &#34;clock_dram4&#34;, wave: &#34;p....&#34;, phase: -0.5}, { name: &#34;clock_dram5&#34;, wave: &#34;p....&#34;, phase: -0.6}, { name: &#34;clock_dram6&#34;, wave: &#34;p....&#34;, phase: -0.7}, { name: &#34;clock_dram7&#34;, wave: &#34;p....&#34;, phase: -0.8}, ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;注：这里简化了，当成 SDR 来画。&lt;/p&gt;&lt;p&gt;不做任何处理的话，DRAM 采样得到的数据就不正确了。为了解决这个问题，就需要人为地在数据信号上也加上可变的延迟，保证时钟和数据同步，这样 DRAM 才可以实现正确的写入：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;clock&#34;, wave: &#34;p.p..&#34;}, { name: &#34;data&#34;, wave: &#34;01010&#34;}, { name: &#34;clock_dram0&#34;, wave: &#34;p.p..&#34;, phase: -0.1}, { name: &#34;data_dram0&#34;, wave: &#34;01010&#34;, phase: -0.1}, { name: &#34;clock_dram1&#34;, wave: &#34;p.p..&#34;, phase: -0.2}, { name: &#34;data_dram1&#34;, wave: &#34;01010&#34;, phase: -0.2}, { name: &#34;clock_dram2&#34;, wave: &#34;p.p..&#34;, phase: -0.3}, { name: &#34;data_dram2&#34;, wave: &#34;01010&#34;, phase: -0.3}, { name: &#34;clock_dram3&#34;, wave: &#34;p.p..&#34;, phase: -0.4}, { name: &#34;data_dram3&#34;, wave: &#34;01010&#34;, phase: -0.4}, ]}&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;Write Leveling&lt;/h2&gt;&lt;p&gt;为了解决写入时，时钟和数据有偏移的问题，需要采用 Write Leveling 方法来解决。具体思路是这样的：如果 DRAM 以时钟信号去采样数据信号可以得到正确的结果，那反过来，如果认为数据信号是时钟信号，在数据信号的上升沿去采样时钟，应该也可以观测到稳定的结果。&lt;/p&gt;&lt;p&gt;所以 Write Leveling 的工作方式就是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置 DRAM 进入 Write Leveling 模式，此时 DRAM 会使用 DQS 信号来采样 CK 信号，把结果输出到 DQ 上&lt;/li&gt;&lt;li&gt;DDR 控制器不断地修改 DQS 的输出延迟，然后统计 DQ 上的输出&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;示意图如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;wavedrom{ signal: [ { name: &#34;ck&#34;, wave: &#34;p.p..&#34;}, { name: &#34;dqs_0&#34;, wave: &#34;010..&#34;, phase: -0.5}, { name: &#34;dq_0&#34;, wave: &#34;0....&#34;, phase: -0.55}, { name: &#34;dqs_1&#34;, wave: &#34;010..&#34;, phase: -0.7}, { name: &#34;dq_1&#34;, wave: &#34;0....&#34;, phase: -0.75}, { name: &#34;dqs_2&#34;, wave: &#34;010..&#34;, phase: -0.9}, { name: &#34;dq_2&#34;, wave: &#34;01...&#34;, phase: -0.95}, { name: &#34;dqs_3&#34;, wave: &#34;010..&#34;, phase: -1.1}, { name: &#34;dq_3&#34;, wave: &#34;01...&#34;, phase: -1.15}, ]}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;上图中，用不断增大的四种延迟的 &lt;code&gt;dqs&lt;/code&gt; 对 &lt;code&gt;ck&lt;/code&gt; 进行采样：用 &lt;code&gt;dqs_0&lt;/code&gt; 和 &lt;code&gt;dqs_1&lt;/code&gt; 采样得到了 0，用 &lt;code&gt;dqs_2&lt;/code&gt; 和 &lt;code&gt;dqs_3&lt;/code&gt; 采样得到了 1。把这些结果列出来，可能会得到类似下面的结果：&lt;/p&gt;&lt;p&gt;&lt;code&gt;001111111111111111110000&lt;/code&gt;&lt;/p&gt;&lt;p&gt;也就是说，随着延迟增大，采样的数据从 0 变成 1，再从 1 变成 0。我们的目标是，让 &lt;code&gt;dqs&lt;/code&gt; 和 &lt;code&gt;ck&lt;/code&gt; 同步。在上图中，&lt;code&gt;dqs_2&lt;/code&gt; 的上升沿和 &lt;code&gt;ck&lt;/code&gt; 上升沿是最接近的，而刚好 &lt;code&gt;dqs_2&lt;/code&gt; 也正好出现在采样 0 变成采样 1 的位置。这意味着，只要找到采样数据从 0 变成 1 的位置，就知道如何让 DQS 与 CK 同步了。&lt;/p&gt;&lt;p&gt;这样就完成了 Write Leveling 的步骤，实现了 DQS 与 CK 同步的目标，那么在写入数据的时候，DRAM 就可以得到正确的 DQS 信号了。&lt;/p&gt;&lt;h2&gt;Read Leveling&lt;/h2&gt;&lt;p&gt;在上一步的 Write Leveling 当中，通过修改内存控制器的输出延迟，保证了 DRAM 可以得到同步的 DQS 和 CK 信号，解决了 Fly by topology 引入的延迟不一致的问题。但是，对于读操作，数据从 DRAM 输出，输入到内存控制器，又会引入一定的延迟。所以对读操作，也需要进行校准。&lt;/p&gt;&lt;p&gt;回顾 SRAM，当想要测试读取功能的时候，会首先写入一些数据，再读出来，判断读取的数据和之前写入的数据是否一致。DRAM 也是类似的：先向 MPR 写入一些伪随机数据，然后要求 DRAM 从 MPR 中读取数据，而不是从 memory cell 中读取数据；然后内存控制器一侧不断进行读取操作，在不同的延迟下，比较读取的数据与预期的随机数据是否一致。最后也会得到一个延迟的区间，在这个区间内可以读取出正确的结果。最后，把延迟设定在区间的中央位置。&lt;/p&gt;&lt;h2&gt;Clam Shell Topology&lt;/h2&gt;&lt;p&gt;再回到拓扑的问题上来，实际上除了 Fly by topology，还有一种拓扑是 Clam shell topology：把 DRAM 分布在 PCB 的上面和下面，这样可以节省 PCB 的面积，但是走线就会比较困难：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_clam_shell.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://docs.xilinx.com/r/en-US/pg313-network-on-chip/Clamshell-Topology&#34;&gt;Versal ACAP Programmable Network on Chip and Integrated Memory Controller LogiCORE IP Product Guide (PG313) &lt;/a&gt;.&lt;/p&gt;&lt;p&gt;直观地讲，两个芯片都放在 PCB 的正面，如果要连线的话，如果保证引脚顺序接近一致，就可以比较容易地连接，不会有很多交叉的地方。但如果一个在正面，另一个在背面，引脚的顺序就倒转过来了，连线的时候就比较困难。解决的办法是，修改引脚的顺序，把一些引脚的功能进行对调，使得走线更加简单：&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_mirror.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Utilizing-Address-Mirroring-to-Ease-Clamshell-Routing&#34;&gt;Versal ACAP PCB Design User Guide (UG863)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这里特意挑选了一些不影响特殊功能的引脚来交换，使得大部分功能，即使交换了引脚，也可以正常工作。但是，对于 Mode Register Set 操作，必须要内存控制器自己先内部交换位的顺序，才能保证在 DRAM 一侧得到正确的结果。&lt;/p&gt;&lt;p&gt;此外，Clam Shell Topology 的正面和背面各有一个 cs_n 片选信号，但是这和 Dual Rank 不同：Dual Rank 是正面和背面都有同样数量的 DRAM 芯片，共享地址信号、数据信号和控制信号，总线上同一时间只有一侧的 DRAM 芯片在使用，好处是内存容量翻倍，并且两个 rank 可以互相掩盖延迟；而 Clam Shell Topology 的两个 cs_n 是为了给 Mode Register Set 操作指定正面或背面，而其余的大部分操作，可以正面和背面同时使用，因为它们的数据信号并没有共享。&lt;/p&gt;&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;/images/ddr_rank.png&#34;&gt;&lt;/p&gt;&lt;p&gt;图源 &lt;a href=&#34;https://blog.memory4less.com/2022/09/16/difference-between-dual-rank-and-single-rank-ram/&#34;&gt;DIFFERENCE BETWEEN DUAL RANK AND SINGLE RANK RAM&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;实际上，前面的整个研究过程，来自于我对 VCU128 LiteX 移植的观察：&lt;a href=&#34;https://github.com/litex-hub/litex-boards/issues/496&#34;&gt;VCU128 DDR4 memory calibration failure&lt;/a&gt;。我在配置 litedram 的时候，发现总是有一半的 DRAM 芯片无法使用，和 Datasheet 对照了以后，发现正好是 PCB 背面的那一半。接着，发现它是 Clam Shell Topology 方式来分布的，然后 Top 和 Bottom 各有一个 cs_n 信号，这一点在 UG1302 里是没有写的，在 xdc 里才可以找到：&lt;/p&gt;&lt;p&gt;&lt;code&gt;tclset_property PACKAGE_PIN BK48 [get_ports &#34;PL_DDR4_BOT_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L7P_T1L_N0_QBC_AD13P_66set_property IOSTANDARD SSTL12_DCI [get_ports &#34;PL_DDR4_BOT_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L7P_T1L_N0_QBC_AD13P_66set_property PACKAGE_PIN BP49 [get_ports &#34;PL_DDR4_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L1N_T0L_N1_DBC_66set_property IOSTANDARD SSTL12 [get_ports &#34;PL_DDR4_CS_B&#34;] ;# Bank 66 VCCO - DDR4_VDDQ_1V2 - IO_L1N_T0L_N1_DBC_66&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所以 Xilinx 文档也是可能出错的，需要结合多个信息源来判断。这里有 xdc 和 schematic 可以参考，都可以发现这个结论。&lt;/p&gt;&lt;p&gt;沿着这个思路，我给 litedram 添加了 clam shell topology 的支持：&lt;a href=&#34;https://github.com/enjoy-digital/litedram/pull/332&#34;&gt;https://github.com/enjoy-digital/litedram/pull/332&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/enjoy-digital/litex/pull/1673&#34;&gt;https://github.com/enjoy-digital/litex/pull/1673&lt;/a&gt;，实现方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在校准阶段，把 Top 和 Bottom 两个 cs_n 暴露给软件，软件在 MRS 的时候，分两次写入，第一次原样写到 Top，第二次交换地址顺序，再写入 Bottom。&lt;/li&gt;&lt;li&gt;正常工作阶段，把 Top 和 Bottom 的两个 cs_n 当成一个用，也就是当成 single rank dram。&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;训练代码&lt;/h2&gt;&lt;p&gt;下面结合 litex 和 litedram 的代码，以及 DDR4 标准，来验证上面的观察。&lt;/p&gt;&lt;h3&gt;Write Leveling&lt;/h3&gt;&lt;p&gt;Write Leveling 的核心函数是 &lt;code&gt;sdram_write_leveling_scan&lt;/code&gt;，它的核心思路是：&lt;/p&gt;&lt;p&gt;第一步调用 &lt;code&gt;sdram_write_leveling_on&lt;/code&gt; 打开 DRAM 的 Write Leveling 模式：&lt;/p&gt;&lt;p&gt;&lt;code&gt;c sdram_write_leveling_on();&lt;/code&gt;&lt;/p&gt;&lt;p&gt;循环每个 DRAM 芯片的每个 DQS 信号：&lt;/p&gt;&lt;p&gt;```cfor(i=0;i&amp;lt;SDRAM_PHY_MODULES;i++) { for (dq_line = 0; dq_line &amp;lt; DQ_COUNT; dq_line++) { /&lt;em&gt; 设置 DQS 初始延迟为 0 &lt;/em&gt;/ sdram_leveling_action(i, dq_line, write_rst_delay);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/* 循环 DQS 延迟 */for(j=0;j&amp;lt;err_ddrphy_wdly;j++) { int zero_count = 0; int one_count = 0; for (k=0; k&amp;lt;loops; k++) { /* 发送 DQS 序列：00000001 */ ddrphy_wlevel_strobe_write(1); /* 统计 1 和 0 的个数 */ if (buf[SDRAM_PHY_MODULES-1-i] != 0) one_count++; else zero_count++; } if (one_count &amp;gt; zero_count) /* DQS 采样到了 CK 的正半周期 */ taps_scan[j] = 1; else /* DQS 采样到了 CK 的负半周期 */ taps_scan[j] = 0; /* 每次循环增加一次 DQS 延迟 */ sdram_leveling_action(i, dq_line, write_inc_delay);}/* 找到一个最长的连续 1 的序列 */one_window_active = 0;one_window_start = 0;one_window_count = 0;one_window_best_start = 0;one_window_best_count = -1;for(j=0;j&amp;lt;err_ddrphy_wdly+1;j++) { if (one_window_active) { if ((j == err_ddrphy_wdly) || (taps_scan[j] == 0)) { /* 结束了一段连续的 1 */ one_window_active = 0; one_window_count = j - one_window_start; /* 记录最长的连续 1 的长度和位置 */ if (one_window_count &amp;gt; one_window_best_count) { one_window_best_start = one_window_start; one_window_best_count = one_window_count; } } } else { /* 找到连续的 1 的开头 */ if (j != err_ddrphy_wdly &amp;amp;&amp;amp; taps_scan[j]) { one_window_active = 1; one_window_start = j; } }}/* 要找的延迟就是连续的 1 序列的开始位置 */delays[i] = one_window_best_start;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}}&lt;/p&gt;&lt;p&gt;sdram_write_leveling_off();```&lt;/p&gt;&lt;p&gt;这样就实现了 Write Leveling 的全流程：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置 DRAM 进入 Write Leveling 模式，DRAM 用 DQS 对 CK 采样，结果输出到 DQ&lt;/li&gt;&lt;li&gt;在不同的 DQS 延迟下，发送同样的 00000001 DQS 模式，观察 DQ 上的数据&lt;/li&gt;&lt;li&gt;统计 DQ 上的 1 和 0 的个数，如果 1 更多，就认为当前 DQS 延迟下，DQS 采样到了 CK 的正半周期；反之如果 0 更多，就认为当前 DQS 延迟下，DQS 采样到了 CK 的负半周期&lt;/li&gt;&lt;li&gt;在第三步的结果中，找到最长的连续的 1 序列，那么这个序列的开始，就对应了采样值从 0 到 1 的变化，此时 DQS 与 CK 基本同步&lt;/li&gt;&lt;li&gt;最后设置 DRAM 退出 Write Leveling 模式&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;参考文档&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://www.systemverilog.io/design/ddr4-initialization-and-calibration/&#34;&gt;https://www.systemverilog.io/design/ddr4-initialization-and-calibration/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Signals-and-Connections-for-DDR4-Interfaces&#34;&gt;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Signals-and-Connections-for-DDR4-Interfaces&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/pg353-versal-acap-soft-ddr4-mem-ip/Calibration-Overview&#34;&gt;https://docs.xilinx.com/r/en-US/pg353-versal-acap-soft-ddr4-mem-ip/Calibration-Overview&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/pg313-network-on-chip/Clamshell-Topology&#34;&gt;https://docs.xilinx.com/r/en-US/pg313-network-on-chip/Clamshell-Topology&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Utilizing-Address-Mirroring-to-Ease-Clamshell-Routing&#34;&gt;https://docs.xilinx.com/r/en-US/ug863-versal-pcb-design/Utilizing-Address-Mirroring-to-Ease-Clamshell-Routing&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://blog.memory4less.com/2022/09/16/difference-between-dual-rank-and-single-rank-ram/&#34;&gt;https://blog.memory4less.com/2022/09/16/difference-between-dual-rank-and-single-rank-ram/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://daffy1108.wordpress.com/2010/09/02/understanding-ddr3-write-leveling-and-read-leveling/&#34;&gt;https://daffy1108.wordpress.com/2010/09/02/understanding-ddr3-write-leveling-and-read-leveling/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/hardware/2023/04/20/dram-topology-training/</link> <pubDate>Thu, 20 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/20/dram-topology-training/</guid> </item> <item> <title>在 Arty A7 上用 LiteX 和 VexRiscv 跑 Linux</title> <category>arty</category> <category>digilent</category> <category>fpga</category> <category>hardware</category> <category>litex</category> <category>xilinx</category> <description>&lt;h1&gt;在 Arty A7 上用 LiteX 和 VexRiscv 跑 Linux&lt;/h1&gt;&lt;h2&gt;litex 安装&lt;/h2&gt;&lt;p&gt;litex 安装过程按照 &lt;a href=&#34;https://github.com/enjoy-digital/litex/wiki/Installation&#34;&gt;https://github.com/enjoy-digital/litex/wiki/Installation&lt;/a&gt; 进行，由于需要 pip install，建议用 venv 来开一个干净的环境：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellpython3 -m venv venvsource venv/bin/activatecd litex./litex_setup.py --init --install&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;构建 bitstream&lt;/h2&gt;&lt;p&gt;litex-boards 已经内建了 Arty A7 的支持，直接运行下列命令，就可以得到 bitstream：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellpython3 -m litex_boards.targets.digilent_arty --build --with-ethernet&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样就可以在 build/digilent_arty/gateware 目录下找到 bitstream。可以通过命令行参数来自定义需要的功能，详见 &lt;a href=&#34;https://github.com/litex-hub/litex-boards/blob/f5e51d72bca6ed0325c1213791a78362326002f8/litex_boards/targets/digilent_arty.py#L162-L180&#34;&gt;https://github.com/litex-hub/litex-boards/blob/f5e51d72bca6ed0325c1213791a78362326002f8/litex_boards/targets/digilent_arty.py#L162-L180&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果想切换 CPU 为 Rocket Chip 的话，克隆并安装 &lt;a href=&#34;https://github.com/litex-hub/pythondata-cpu-rocket&#34;&gt;https://github.com/litex-hub/pythondata-cpu-rocket&lt;/a&gt;，添加 &lt;code&gt;--cpu-type rocket --cpu-variant small&lt;/code&gt; 参数即可。&lt;/p&gt;&lt;h2&gt;下载 bitstream&lt;/h2&gt;&lt;p&gt;最后，连接 microUSB 和网线到电脑，然后下载 bitstream：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellopenFPGALoader -b arty digilent_arty.bitscreen /dev/tty.usbserial-XXXXXXXXXXXXX 115200&lt;/code&gt;&lt;/p&gt;&lt;p&gt;就可以看到 litex 的输出：&lt;/p&gt;&lt;p&gt;```shell--=============== SoC ==================--CPU: VexRiscv @ 100MHzBUS: WISHBONE 32-bit @ 4GiBCSR: 32-bit dataROM: 128.0KiBSRAM: 8.0KiBL2: 8.0KiBSDRAM: 256.0MiB 16-bit @ 800MT/s (CL-7 CWL-5)MAIN-RAM: 256.0MiB&lt;/p&gt;&lt;p&gt;--========== Initialization ============--Ethernet init...Initializing SDRAM @0x40000000...Switching SDRAM to software control.Read leveling: m0, b00: |00000000000000000000000000000000| delays: - m0, b01: |00000000000000000000000000000000| delays: - m0, b02: |11111111110000000000000000000000| delays: 04+-04 m0, b03: |00000000000000111111111111000000| delays: 19+-05 m0, b04: |00000000000000000000000000000011| delays: 30+-00 m0, b05: |00000000000000000000000000000000| delays: - m0, b06: |00000000000000000000000000000000| delays: - m0, b07: |00000000000000000000000000000000| delays: - best: m0, b03 delays: 19+-05 m1, b00: |00000000000000000000000000000000| delays: - m1, b01: |00000000000000000000000000000000| delays: - m1, b02: |11111111110000000000000000000000| delays: 04+-04 m1, b03: |00000000000000111111111111000000| delays: 19+-05 m1, b04: |00000000000000000000000000000011| delays: 30+-00 m1, b05: |00000000000000000000000000000000| delays: - m1, b06: |00000000000000000000000000000000| delays: - m1, b07: |00000000000000000000000000000000| delays: - best: m1, b03 delays: 19+-05Switching SDRAM to hardware control.Memtest at 0x40000000 (2.0MiB)... Write: 0x40000000-0x40200000 2.0MiB Read: 0x40000000-0x40200000 2.0MiBMemtest OKMemspeed at 0x40000000 (Sequential, 2.0MiB)... Write speed: 37.0MiB/s Read speed: 48.7MiB/s&lt;/p&gt;&lt;p&gt;--============== Boot ==================--Booting from serial...Press Q or ESC to abort boot completely.sL5DdSMmkekroTimeoutBooting from network...Local IP: 192.168.1.50Remote IP: 192.168.1.100Booting from boot.json...Booting from boot.bin...Copying boot.bin to 0x40000000...Network boot failed.No boot medium found&lt;/p&gt;&lt;p&gt;--============= Console ================--&lt;/p&gt;&lt;p&gt;litex&amp;gt; ```&lt;/p&gt;&lt;p&gt;可见是非常方便的。之后可以用 litex_term 来往里面传程序，也可以直接通过 TFTP 来传。&lt;/p&gt;&lt;h2&gt;启动 Linux&lt;/h2&gt;&lt;p&gt;接下来，可以使用项目 &lt;a href=&#34;https://github.com/litex-hub/linux-on-litex-vexriscv&#34;&gt;https://github.com/litex-hub/linux-on-litex-vexriscv&lt;/a&gt; 来启动 Linux。参考项目 README，编译 Linux 并启动。不想折腾的话，可以从 &lt;a href=&#34;https://github.com/litex-hub/linux-on-litex-vexriscv/issues/164&#34;&gt;https://github.com/litex-hub/linux-on-litex-vexriscv/issues/164&lt;/a&gt; 下载编译好的结果。&lt;/p&gt;&lt;p&gt;首先克隆项目到本地，然后运行：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellgit clone https://github.com/litex-hub/linux-on-litex-vexriscv.gitcd linux-on-litex-vexriscv./make.py --board=arty&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这样就生成了 bitstream，接下来构建 Linux 和 rootfs：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shellgit clone http://github.com/buildroot/buildrootcd buildrootmake BR2_EXTERNAL=../linux-on-litex-vexriscv/buildroot/ litex_vexriscv_defconfigmake&lt;/code&gt;&lt;/p&gt;&lt;p&gt;再构建 OpenSBI：&lt;/p&gt;&lt;p&gt;```shellgit clone https://github.com/litex-hub/opensbi --branch 0.8-linux-on-litex-vexriscvcd opensbi&lt;/p&gt;&lt;h1&gt;riscv32-unknown-elf toolchain is built by ct-ng&lt;/h1&gt;&lt;p&gt;make CROSS_COMPILE=riscv32-unknown-elf- PLATFORM=litex/vexriscv```&lt;/p&gt;&lt;p&gt;但是实践过程中发现 ct-ng 编译的是 hardfloat 工具链，而默认配置下 vexriscv 不带 FPU，所以编译时用的是 rv32ima 作为 target，链接的时候报错，最后就直接用编译好的版本。&lt;/p&gt;&lt;p&gt;最后得到如下的几个文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;boot.json: linux-on-litex-vexriscv/images/boot.json&lt;/li&gt;&lt;li&gt;rv32.dtb: linux-on-litex-vexriscv/images/rv32.dtb&lt;/li&gt;&lt;li&gt;Image: buildroot/output/images/Image&lt;/li&gt;&lt;li&gt;rootfs.cpio: buildroot/output/images/rootfs.cpio&lt;/li&gt;&lt;li&gt;opensbi.bin&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;把这些文件复制到 TFTP 服务的目录下，重新 Program linux-on-litex-vexriscv/build/arty/gateware/arty.bit，即可启动 Linux：&lt;/p&gt;&lt;p&gt;```--============== Boot ==================--Booting from serial...Press Q or ESC to abort boot completely.sL5DdSMmkekroTimeoutBooting from SDCard in SD-Mode...Booting from boot.json...Booting from boot.bin...SDCard boot failed.Booting from network...Local IP: 192.168.1.50Remote IP: 192.168.1.100Booting from boot.json...Copying Image to 0x40000000... (7726264 bytes)Copying rv32.dtb to 0x40ef0000... (5294 bytes)Copying rootfs.cpio to 0x41000000... (3566592 bytes)Copying opensbi.bin to 0x40f00000... (53640 bytes)Executing booted program at 0x40f00000&lt;/p&gt;&lt;p&gt;--============= Liftoff! ===============--&lt;/p&gt;&lt;p&gt;OpenSBI v0.8-1-gecf7701 &lt;strong&gt;&lt;em&gt;_ &lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; ____ _____ / __ \ / ____| _ _ &lt;em&gt;| | | | |_ __ &lt;/em&gt;&lt;/strong&gt; _ &lt;strong&gt; | (___ | |&lt;em&gt;) || | | | | | &#39;&lt;em&gt; \ / _ \ &#39;&lt;/em&gt; \ _&lt;strong&gt; \| _ &amp;lt; | | | |&lt;/strong&gt;| | |&lt;em&gt;) | __/ | | |&lt;/em&gt;&lt;/em&gt;&lt;/strong&gt;) | |&lt;em&gt;) || |&lt;/em&gt; _&lt;strong&gt;&lt;em&gt;/| .&lt;/em&gt;_/ _&lt;/strong&gt;|&lt;em&gt;| |&lt;/em&gt;|&lt;strong&gt;&lt;em&gt;_&lt;/em&gt;/|&lt;/strong&gt;__/_____| | | |_|&lt;/p&gt;&lt;p&gt;Platform Name : LiteX / VexRiscv-SMPPlatform Features : timer,mfdelegPlatform HART Count : 8Boot HART ID : 0Boot HART ISA : rv32imasBOOT HART Features : timeBOOT HART PMP Count : 0Firmware Base : 0x40f00000Firmware Size : 124 KBRuntime SBI Version : 0.2&lt;/p&gt;&lt;p&gt;MIDELEG : 0x00000222MEDELEG : 0x0000b101[ 0.000000] Linux version 6.1.0-rc2 (jiegec@linux) (riscv32-buildroot-linux-gnu-gcc.br_real (Buildroot 2023.02-270-gb100440bff) 11.3.0, GNU ld (GNU Binutils) 2.38) #1 SMP Wed Apr 19 16:21:39 CST 2023[ 0.000000] earlycon: liteuart0 at I/O port 0x0 (options &#39;&#39;)[ 0.000000] Malformed early option &#39;console&#39;[ 0.000000] earlycon: liteuart0 at MMIO 0xf0001000 (options &#39;&#39;)[ 0.000000] printk: bootconsole [liteuart0] enabled[ 0.000000] Zone ranges:[ 0.000000] Normal [mem 0x0000000040000000-0x000000004fffffff][ 0.000000] Movable zone start for each node[ 0.000000] Early memory node ranges[ 0.000000] node 0: [mem 0x0000000040000000-0x000000004fffffff][ 0.000000] Initmem setup node 0 [mem 0x0000000040000000-0x000000004fffffff][ 0.000000] SBI specification v0.2 detected[ 0.000000] SBI implementation ID=0x1 Version=0x8[ 0.000000] SBI TIME extension detected[ 0.000000] SBI IPI extension detected[ 0.000000] SBI RFENCE extension detected[ 0.000000] SBI HSM extension detected[ 0.000000] riscv: base ISA extensions aim[ 0.000000] riscv: ELF capabilities aim[ 0.000000] percpu: Embedded 8 pages/cpu s11732 r0 d21036 u32768[ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 65024[ 0.000000] Kernel command line: console=liteuart earlycon=liteuart,0xf0001000 rootwait root=/dev/ram0[ 0.000000] Dentry cache hash table entries: 32768 (order: 5, 131072 bytes, linear)[ 0.000000] Inode-cache hash table entries: 16384 (order: 4, 65536 bytes, linear)[ 0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off[ 0.000000] Memory: 243336K/262144K available (5848K kernel code, 571K rwdata, 906K rodata, 215K init, 254K bss, 18808K reserved, 0K cma-reserved)[ 0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1[ 0.000000] rcu: Hierarchical RCU implementation.[ 0.000000] rcu: RCU restricting CPUs from NR_CPUS=32 to nr_cpu_ids=1.[ 0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.[ 0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1[ 0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0[ 0.000000] riscv-intc: 32 local interrupts mapped[ 0.000000] plic: interrupt-controller@f0c00000: mapped 32 interrupts with 1 handlers for 2 contexts.[ 0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.[ 0.000000] riscv-timer: riscv_timer_init_dt: Registering clocksource cpuid [0] hartid [0][ 0.000000] clocksource: riscv_clocksource: mask: 0xffffffffffffffff max_cycles: 0x171024e7e0, max_idle_ns: 440795205315 ns[ 0.000018] sched_clock: 64 bits at 100MHz, resolution 10ns, wraps every 4398046511100ns[ 0.010246] Console: colour dummy device 80x25[ 0.014169] Calibrating delay loop (skipped), value calculated using timer frequency.. 200.00 BogoMIPS (lpj=400000)[ 0.024255] pid_max: default: 32768 minimum: 301[ 0.033262] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 0.039790] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)[ 0.080128] ASID allocator using 9 bits (512 entries)[ 0.086947] rcu: Hierarchical SRCU implementation.[ 0.090826] rcu: Max phase no-delay instances is 1000.[ 0.103556] smp: Bringing up secondary CPUs ...[ 0.107186] smp: Brought up 1 node, 1 CPU[ 0.118798] devtmpfs: initialized[ 0.169571] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns[ 0.178637] futex hash table entries: 256 (order: 2, 16384 bytes, linear)[ 0.214981] NET: Registered PF_NETLINK/PF_ROUTE protocol family[ 0.455944] pps_core: LinuxPPS API ver. 1 registered[ 0.460007] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;a href=&#34;&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#103;&amp;#105;&amp;#111;&amp;#109;&amp;#101;&amp;#116;&amp;#116;&amp;#105;&amp;#64;&amp;#108;&amp;#105;&amp;#110;&amp;#117;&amp;#120;&amp;#46;&amp;#105;&amp;#116;&#34;&gt;&amp;#103;&amp;#105;&amp;#111;&amp;#109;&amp;#101;&amp;#116;&amp;#116;&amp;#105;&amp;#64;&amp;#108;&amp;#105;&amp;#110;&amp;#117;&amp;#120;&amp;#46;&amp;#105;&amp;#116;&lt;/a&gt;[ 0.469508] PTP clock support registered[ 0.476324] FPGA manager framework[ 0.493464] clocksource: Switched to clocksource riscv_clocksource[ 0.722433] NET: Registered PF_INET protocol family[ 0.731210] IP idents hash table entries: 4096 (order: 3, 32768 bytes, linear)[ 0.752236] tcp_listen_portaddr_hash hash table entries: 512 (order: 0, 4096 bytes, linear)[ 0.760269] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)[ 0.767834] TCP established hash table entries: 2048 (order: 1, 8192 bytes, linear)[ 0.775654] TCP bind hash table entries: 2048 (order: 3, 32768 bytes, linear)[ 0.783026] TCP: Hash tables configured (established 2048 bind 2048)[ 0.789689] UDP hash table entries: 256 (order: 1, 8192 bytes, linear)[ 0.795620] UDP-Lite hash table entries: 256 (order: 1, 8192 bytes, linear)[ 0.816406] Unpacking initramfs...[ 0.926651] workingset: timestamp_bits=30 max_order=16 bucket_order=0[ 1.186672] io scheduler mq-deadline registered[ 1.190309] io scheduler kyber registered[ 1.570624] No litex,nclkout entry in the dts file[ 1.607895] LiteX SoC Controller driver initialized[ 2.358518] Initramfs unpacking failed: invalid magic at start of compressed archive[ 2.448554] Freeing initrd memory: 8192K[ 3.423827] f0001000.serial: ttyLXU0 at MMIO 0x0 (irq = 0, base_baud = 0) is a liteuart[ 3.431446] printk: console [liteuart0] enabled[ 3.431446] printk: console [liteuart0] enabled[ 3.440068] printk: bootconsole [liteuart0] disabled[ 3.440068] printk: bootconsole [liteuart0] disabled[ 3.499884] liteeth f0002000.mac eth0: irq 2 slots: tx 2 rx 2 size 2048[ 3.510055] i2c_dev: i2c /dev entries driver[ 3.520573] i2c i2c-0: Not I2C compliant: can&#39;t read SCL[ 3.525314] i2c i2c-0: Bus may be unreliable[ 3.577560] litex-mmc f0009000.mmc: LiteX MMC controller initialized.[ 3.623272] NET: Registered PF_INET6 protocol family[ 3.653652] Segment Routing with IPv6[ 3.657870] In-situ OAM (IOAM) with IPv6[ 3.662630] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver[ 3.683817] NET: Registered PF_PACKET protocol family[ 3.699016] Freeing unused kernel image (initmem) memory: 208K[ 3.704055] Kernel memory protection not selected by kernel config.[ 3.710506] Run /init as init processStarting syslogd: OKStarting klogd: OKRunning sysctl: OKSaving 256 bits of non-creditable seed for next bootStarting network: OK&lt;/p&gt;&lt;p&gt;Welcome to Buildrootbuildroot login: root &lt;strong&gt; _ / / (&lt;em&gt;)&lt;strong&gt; &lt;/strong&gt; _&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt; / /__/ / _ \/ // /\ \ / /____/&lt;em&gt;/&lt;em&gt;//&lt;/em&gt;/_,&lt;em&gt;//&lt;/em&gt;_\ / _ \/ _ \ &lt;strong&gt; _ &lt;/strong&gt; _ &lt;em&gt;___/&lt;/em&gt;//_/ &lt;/em&gt;&lt;/strong&gt; _ / / (&lt;em&gt;) /____ | |/&lt;/em&gt;/&lt;strong&gt;| | / /____ __ / _ (&lt;em&gt;)&lt;strong&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt; / /&lt;strong&gt;/ / &lt;/strong&gt;/ -&lt;em&gt;)&amp;gt; &amp;lt;/&lt;/em&gt;&lt;/strong&gt;/ |/ / -&lt;em&gt;) \ // , &lt;/em&gt;/ (&lt;em&gt;-&amp;lt;/ __/ |/ //____/&lt;/em&gt;/_&lt;em&gt;/_&lt;/em&gt;/&lt;em&gt;/|&lt;/em&gt;|&lt;strong&gt;&lt;em&gt;_|&lt;/em&gt;&lt;/strong&gt;/_&lt;em&gt;/&lt;/em&gt;_\/&lt;em&gt;/|&lt;/em&gt;/&lt;em&gt;/___/_&lt;/em&gt;/|&lt;strong&gt;&lt;em&gt;/ / &lt;/em&gt;&lt;em&gt;/ |/ / _ \ &lt;/em&gt;\ \/ /|_/ / &lt;/strong&gt;&lt;em&gt;/ /___/&lt;/em&gt;/ /&lt;em&gt;/&lt;/em&gt;/ 32-bit RISC-V Linux running on LiteX / VexRiscv-SMP.&lt;/p&gt;&lt;p&gt;login[70]: root login on &#39;console&#39;root@buildroot:~# ```&lt;/p&gt;&lt;p&gt;Linux 中也可以访问网络（通过主线内的 liteeth 驱动）：&lt;/p&gt;&lt;p&gt;&lt;code&gt;shell$ dmesg | grep liteeth[ 3.499861] liteeth f0002000.mac eth0: irq 2 slots: tx 2 rx 2 size 2048$ ip link set eth0 up$ ip a add 192.168.1.50/24 dev eth0$ ping 192.168.1.100&lt;/code&gt;&lt;/p&gt;&lt;h2&gt;其他开发板&lt;/h2&gt;&lt;p&gt;除了 Digilent Arty A7，我还做了以下开发板的 LiteX 支持：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/jiegec/litex-boards/tree/vcu128&#34;&gt;VCU128&lt;/a&gt;，支持 UART，SDRAM 和 HBM；以太网因为是 SGMII 暂时无法解决&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/jiegec/litex-boards/tree/ma703fa-35t&#34;&gt;MA703FA-35T&lt;/a&gt;，支持 UART，SDRAM，ETH、SD 卡和 HDMI；MA703FA-35T 的文档中 TF_DAT3 引脚绑定有误，AB12 应该改为 AB20&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/jiegec/litex-boards/tree/alinx_ax7021&#34;&gt;Alinx AX7021&lt;/a&gt;，支持 UART over JTAG 和 HDMI&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://lab.cs.tsinghua.edu.cn/digital-design/doc/hardware/board/&#34;&gt;THU Digital Design&lt;/a&gt;，基于 @gaoyichuan 的实现，支持 UART，SDRAM，ETH，SD 卡和 VGA&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/hardware/2023/04/19/litex-digilent-arty-a7/</link> <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/hardware/2023/04/19/litex-digilent-arty-a7/</guid> </item> <item> <title>C/C++ 数参数个数的特别方法</title> <category>builtin</category> <category>c</category> <category>gcc</category> <category>printf</category> <category>programming</category> <description>&lt;h1&gt;C/C++ 数参数个数的特别方法&lt;/h1&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;群友上个月提了一个未知来源问题：&lt;/p&gt;&lt;p&gt;实现一个你自己的 &lt;code&gt;printf(int, ...)&lt;/code&gt; 函数，该函数包含可变参数。为简便期间，假设所有参数均为 int 类型。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;第一个参数是一个普通参数，不表示后续可变参数的数目&lt;/li&gt;&lt;li&gt;在 printf 中逐个输出所有传入的整数值（可使用系统自带的 kprintf 实现输出）&lt;/li&gt;&lt;li&gt;思考如何判定参数结束，是否有副作用&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;va_args&lt;/h2&gt;&lt;p&gt;我们知道，传统的处理可变参数的方法是 va_args，但是它无法知道传入了多少参数，而要像 POSIX printf 那样，解析 format 参数，然后一个一个去取。&lt;/p&gt;&lt;p&gt;所以问题的关键是，如何获取参数的个数？一个思路是宏，尝试用宏的魔法来计算出参数个数，这个方法可能是可以的，但是没有深究。另一个思路是利用 ABI 的特点，例如 i386 上参数是通过栈传递的，那或许可以在栈上找到所有的 int，但是问题是无法确认参数在哪里结束。&lt;/p&gt;&lt;h2&gt;__builtin_va_arg_pack_len&lt;/h2&gt;&lt;p&gt;今天，另一位群友发了一个链接：&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls&#34;&gt;https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#Constructing-Calls&lt;/a&gt;，讲述了 GCC 中一些特别的 builtin 函数，用于函数调用相关的魔法，其中一段描述吸引了我的眼球：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Built-in Function: int __builtin_va_arg_pack_len ()This built-in function returns the number of anonymous arguments of aninline function. It can be used only in inline functions that are alwaysinlined, never compiled as a separate function, such as those using__attribute__ ((__always_inline__)) or __attribute__ ((__gnu_inline__))extern inline functions. For example following does link- or run-timechecking of open arguments for optimized code:&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这正好实现了前面提到的获取参数个数，实现思路也可以想到，就是编译器在 inline 的时候，顺便做了一次替换。也因此，这个函数必须被 inline，不能正常调用。有了这个思路以后，经过一番尝试，写入了下面的代码：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;&lt;h1&gt;include &lt;stdarg.h&gt;&lt;/h1&gt;&lt;p&gt;void my_printf_inner(int count, ...) { va_list args; va_start(args, count);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;for (int i = 0;i &amp;lt; count;i++) { printf(&#34;%d\n&#34;, va_arg(args, int));}va_end(args);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;strong&gt;attribute&lt;/strong&gt; ((&lt;strong&gt;always_inline&lt;/strong&gt;)) inlinevoid my_printf(int a, ...) { int count = __builtin_va_arg_pack_len(); printf(&#34;%d\n&#34;, a); my_printf_inner(count, __builtin_va_arg_pack());}&lt;/p&gt;&lt;p&gt;int main() { my_printf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); return 0;}```&lt;/p&gt;&lt;p&gt;这个代码在 GCC 中可以正确地输出 1-10 的十个数字。我一开始尝试的时候，把循环也写到 &lt;code&gt;my_printf&lt;/code&gt; 函数中，但是 GCC 的 inline 就罢工了，最后只好拆成两个函数，把不知道参数个数的问题，转化成知道参数的问题，剩下就好解决了。&lt;/p&gt;&lt;p&gt;最后生成的汇编如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;asmmain: push rbp mov rbp, rsp sub rsp, 16 mov DWORD PTR [rbp-4], 1 mov DWORD PTR [rbp-8], 9 mov eax, DWORD PTR [rbp-4] mov esi, eax mov edi, OFFSET FLAT:.LC0 mov eax, 0 call printf mov eax, DWORD PTR [rbp-8] push 10 push 9 push 8 push 7 mov r9d, 6 mov r8d, 5 mov ecx, 4 mov edx, 3 mov esi, 2 mov edi, eax mov eax, 0 call my_printf_inner add rsp, 32 nop mov eax, 0 leave ret&lt;/code&gt;&lt;/p&gt;&lt;p&gt;可以看到，它 inline 了 &lt;code&gt;my_printf&lt;/code&gt; 的实现，先调用了第一个 &lt;code&gt;printf&lt;/code&gt;，然后把剩下的参数个数 &lt;code&gt;9&lt;/code&gt; 赋值给了 &lt;code&gt;edi&lt;/code&gt;，剩下就是正常的传参了。&lt;/p&gt;&lt;p&gt;以上实验都在 Godbolt Compiler Explorer 中进行：&lt;a href=&#34;https://godbolt.org/z/KjYzETn5Y&#34;&gt;https://godbolt.org/z/KjYzETn5Y&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;继续挖掘，会发现在 libc 中出现了 __builtin_va_arg_pack_len 的身影，在 fcntl2.h 中：&lt;/p&gt;&lt;p&gt;```c__errordecl (__open_too_many_args, &#34;open can be called either with 2 or 3 arguments, not more&#34;);__errordecl (__open_missing_mode, &#34;open with O_CREAT or O_TMPFILE in second argument needs 3 arguments&#34;);&lt;/p&gt;&lt;p&gt;__fortify_function intopen (const char *__path, int __oflag, ...){ if (__va_arg_pack_len () &amp;gt; 1) __open_too_many_args ();&lt;/p&gt;&lt;p&gt;if (__builtin_constant_p (__oflag)) { if (__OPEN_NEEDS_MODE (__oflag) &amp;amp;&amp;amp; __va_arg_pack_len () &amp;lt; 1) { __open_missing_mode (); return __open_2 (__path, __oflag); } return __open_alias (__path, __oflag, __va_arg_pack ()); }&lt;/p&gt;&lt;p&gt;if (__va_arg_pack_len () &amp;lt; 1) return __open_2 (__path, __oflag);&lt;/p&gt;&lt;p&gt;return __open_alias (__path, __oflag, __va_arg_pack ());}```&lt;/p&gt;&lt;p&gt;可以看到，它核心的思想就是根据 open 第三个参数的有无，调用相应的 &lt;code&gt;__open_2&lt;/code&gt; 或者 &lt;code&gt;__open_alias&lt;/code&gt; 函数，这样就不用再用 &lt;code&gt;va_args&lt;/code&gt; 方法了，并且如果传入了过多的参数，可以直接在编译期指出错误。例子：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;include &lt;fcntl.h&gt;&lt;/h1&gt;&lt;p&gt;int main() { open(&#34;123&#34;, 0, 0, 0, 0); return 0;}```&lt;/p&gt;&lt;p&gt;报错：&lt;/p&gt;&lt;p&gt;&lt;code&gt;cIn file included from /usr/include/fcntl.h:301, from &amp;lt;source&amp;gt;:2:In function &#39;open&#39;, inlined from &#39;main&#39; at &amp;lt;source&amp;gt;:5:5:/usr/include/x86_64-linux-gnu/bits/fcntl2.h:44:5: error: call to &#39;__open_too_many_args&#39; declared with attribute error: open can be called either with 2 or 3 arguments, not more 44 | __open_too_many_args (); | ^~~~~~~~~~~~~~~~~~~~~~~ASM generation compiler returned: 1In file included from /usr/include/fcntl.h:301, from &amp;lt;source&amp;gt;:2:In function &#39;open&#39;, inlined from &#39;main&#39; at &amp;lt;source&amp;gt;:5:5:/usr/include/x86_64-linux-gnu/bits/fcntl2.h:44:5: error: call to &#39;__open_too_many_args&#39; declared with attribute error: open can be called either with 2 or 3 arguments, not more 44 | __open_too_many_args (); | ^~~~~~~~~~~~~~~~~~~~~~~Execution build compiler returned: 1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Compiler Explorer:&lt;a href=&#34;https://godbolt.org/z/hebshz3P5&#34;&gt;https://godbolt.org/z/hebshz3P5&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;使用 C 宏&lt;/h2&gt;&lt;p&gt;和 Claude 聊了一下，是否能够用 C 宏来实现，它的回答是：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;define PRINTF(...) printf(&lt;strong&gt;VA_ARGS&lt;/strong&gt;)&lt;/h1&gt;&lt;h1&gt;define NARG(...) (sizeof((int[]){&lt;strong&gt;VA_ARGS&lt;/strong&gt;})/sizeof(int))&lt;/h1&gt;&lt;p&gt;int printf(const char *format, ...) { va_list args; va_start(args, format);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Access the variable arguments using va_arg based on // the number of arguments passed, obtained using NARGva_end(args);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// Usage:PRINTF(1, 2, 3); // Prints 1 2 3 PRINTF(1, 2, 3, 4); // Prints 1 2 3 4```&lt;/p&gt;&lt;p&gt;核心思路就是把参数列表放到数组里，然后让编译器去推断数组大小。沿着这个思路，实现出代码：&lt;/p&gt;&lt;p&gt;```c&lt;/p&gt;&lt;h1&gt;include &lt;stdio.h&gt;&lt;/h1&gt;&lt;h1&gt;include &lt;stdarg.h&gt;&lt;/h1&gt;&lt;p&gt;void my_printf_inner(int count, ...) { va_list args; va_start(args, count);&lt;/p&gt;&lt;pre&gt;&lt;code&gt;for (int i = 0;i &amp;lt; count;i++) { printf(&#34;%d\n&#34;, va_arg(args, int));}va_end(args);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;&lt;h1&gt;define MY_PRINTF(...) do {int len=(sizeof((int[]){&lt;strong&gt;VA_ARGS&lt;/strong&gt;})/sizeof(int)); my_printf_inner(len, &lt;strong&gt;VA_ARGS&lt;/strong&gt;); } while(0);&lt;/h1&gt;&lt;p&gt;int main() { MY_PRINTF(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); return 0;}```&lt;/p&gt;&lt;p&gt;也是可以工作的。Compiler Explorer 链接：&lt;a href=&#34;https://godbolt.org/z/TxKb3YEcf&#34;&gt;https://godbolt.org/z/TxKb3YEcf&lt;/a&gt;。&lt;/p&gt;&lt;h2&gt;ChatGPT&lt;/h2&gt;&lt;p&gt;尝试询问了一下 ChatGPT：&lt;a href=&#34;https://shareg.pt/IXUKjYK&#34;&gt;https://shareg.pt/IXUKjYK&lt;/a&gt;，它可以写出额外传入 int 个数的版本，可以写出哨兵（传入 &lt;code&gt;-1&lt;/code&gt; 表示结束）的版本，提示了 builtin 以后，再提示 inline 和 always_inline，最后让它拆分成两个函数，得到的代码距离正确结果已经比较接近，但还是有一些问题。&lt;/p&gt;</description><link>https://jia.je/programming/2023/04/14/counting-arguments/</link> <pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/programming/2023/04/14/counting-arguments/</guid> </item> <item> <title>SCO OpenServer 6.0.0 虚拟机安装</title> <category>sco</category> <category>system</category> <category>unix</category> <category>unixware</category> <description>&lt;h1&gt;SCO OpenServer 6.0.0 虚拟机安装&lt;/h1&gt;&lt;h2&gt;安装过程&lt;/h2&gt;&lt;p&gt;首先从 &lt;a href=&#34;https://www.sco.com/support/update/download/product.php?pfid=12&amp;amp;prid=20&#34;&gt;https://www.sco.com/support/update/download/product.php?pfid=12&amp;amp;prid=20&lt;/a&gt; 下载 SCO OpenServer 的安装 ISO。尝试过用 QEMU 启动，但是会卡在无法读取硬盘的错误上。&lt;/p&gt;&lt;p&gt;最后使用 VirtualBox 7.0.6 成功启动，注意创建虚拟机的时候不要给太多内存，例如 4GB 就起不来，2GB 可以。硬盘我也只给了 4GB 的空间。&lt;/p&gt;&lt;p&gt;安装过程中会询问 License number 和 License code，可以选择使用 Evaluation License，或者使用下面参考文档中提供的 License。按照流程一直走就可以了。如果重启出现无法 mount root 的问题，就 poweroff 再开机。&lt;/p&gt;&lt;h2&gt;参考文档&lt;/h2&gt;&lt;p&gt;本博客参考了以下文档中的命令：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://virtuallyfun.com/2020/11/21/fun-with-openserver-6-and-mergepro/&#34;&gt;https://virtuallyfun.com/2020/11/21/fun-with-openserver-6-and-mergepro/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/system/2023/04/10/sco6/</link> <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/system/2023/04/10/sco6/</guid> </item> <item> <title>UnixWare 7.1.4 虚拟机安装</title> <category>system</category> <category>unix</category> <category>unixware</category> <description>&lt;h1&gt;UnixWare 7.1.4 虚拟机安装&lt;/h1&gt;&lt;h2&gt;安装过程&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&#34;https://www.sco.com/support/update/download/product.php?pfid=1&amp;amp;prid=6&#34;&gt;https://www.sco.com/support/update/download/product.php?pfid=1&amp;amp;prid=6&lt;/a&gt; 可以看到 UnixWare 7.1.4 的相关下载，其中首先要下载 UnixWare 的安装 ISO：&lt;a href=&#34;https://www.sco.com/support/update/download/release.php?rid=346&#34;&gt;https://www.sco.com/support/update/download/release.php?rid=346&lt;/a&gt;，尝试过用 QEMU 启动，会遇到找不到 CD-ROM 的问题，虽然通过设置 &lt;code&gt;ATAPI_DMA_DISABLE=YES&lt;/code&gt; 解决了，但是又遇到了找不到硬盘的问题。&lt;/p&gt;&lt;p&gt;最后换成了 VirtualBox 7.0.6。用 VirtualBox 创建虚拟机的时候，不要给太多内存，4GB 就会无法启动，2GB 可以，硬盘也不要给太多，4GB 就足够。&lt;/p&gt;&lt;p&gt;剩下就是按照安装界面一路默认即可，License 可以选择 Defer，使用 Evaluation License。&lt;/p&gt;&lt;p&gt;关机以后，修改启动顺序，把硬盘放到 CD 前，然后启动，就可以进入系统了。如果重启出现无法 mount root 的问题，就 poweroff 再开机。&lt;/p&gt;&lt;h2&gt;参考文档&lt;/h2&gt;&lt;p&gt;本博客参考了以下文档中的命令：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://virtuallyfun.com/2018/01/31/revisiting-a-unixware-7-1-1-install-on-qemu-kvm/&#34;&gt;https://virtuallyfun.com/2018/01/31/revisiting-a-unixware-7-1-1-install-on-qemu-kvm/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://jia.je/system/2023/04/10/unixware7/</link> <pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><source url="https://jia.je/feed_rss_updated.xml">杰哥的{运维,编程,调板子}小笔记</source><guid isPermaLink="true">https://jia.je/system/2023/04/10/unixware7/</guid> </item> </channel></rss>