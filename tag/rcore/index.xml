<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - rcore</title>
 <link href="https://jiege.ch/tag/rcore/index.xml" rel="self"/>
 <link href="https://jiege.ch/tag/rcore.html"/>
 <updated>2019-04-01T09:19:05+08:00</updated>
 <id>https://jiege.ch/tag/rcore.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>静态编译 sqlite3</title>
   <link href="https://jiege.ch/software/2019/03/24/static-building-sqlite/"/>
   <updated>2019-03-24T19:13:00+08:00</updated>
   <id>https://jiege.ch/software/2019/03/24/static-building-sqlite</id>
   <content type="html">&lt;p&gt;最近 rCore 支持了动态链接库，于是想着在测试 sqlite 的时候直接用动态的，不过出现了玄学的问题，它会访问一个不存在的地址，看代码也没看出个所以然来。所以研究了一下 sqlite 的静态编译。首先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt; 的时候尝试了一下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./configure &lt;span class=&quot;nv&quot;&gt;CC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;x86_64-linux-musl-gcc &lt;span class=&quot;nt&quot;&gt;--disable-shared&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--enabled-static&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsqlite&lt;/code&gt; 确实是静态了，但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;sqlite3&lt;/code&gt; 并不是。一番研究以后，发现是 &lt;code class=&quot;highlighter-rouge&quot;&gt;libtool&lt;/code&gt; 的原因，只要这样编译：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nv&quot;&gt;LTLINK_EXTRAS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-all-static&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就可以编译出静态的 &lt;code class=&quot;highlighter-rouge&quot;&gt;sqlite3&lt;/code&gt; ：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlite3: ELF 64-bit LSB executable, x86-64, version 1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SYSV&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, statically linked, with debug_info, not stripped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>交叉编译 Nginx 1.14.2 到 RISC-V</title>
   <link href="https://jiege.ch/software/2019/03/22/cross-compiling-nginx-to-riscv/"/>
   <updated>2019-03-22T23:18:00+08:00</updated>
   <id>https://jiege.ch/software/2019/03/22/cross-compiling-nginx-to-riscv</id>
   <content type="html">&lt;p&gt;最近又把一定的精力放到了 RISC-V 64 上的 rCore 用户态程序的支持上，同时也借到了 HiFive Unleashed 板子，所以有真实硬件可以拿来跑了。在这之前先在 QEMU 上把能跑的都跑起来。&lt;/p&gt;

&lt;p&gt;由于 rCore 对 glibc 的支持一直有问题，RISC-V 也不例外，所以还是选择用 musl 来做这件事情。一般搜索，终于找到了 Linux 下能用的 &lt;a href=&quot;https://github.com/rv8-io/musl-riscv-toolchain&quot;&gt;musl-riscv-toolchain&lt;/a&gt; 。编译好工具链以后，很多需要 libc 的用户态都能跑了，于是想着试一下 nginx 的编译。试着编译了一下，遇到了各种问题，最后搜到了&lt;a href=&quot;https://www.jianshu.com/p/5d9b60f7b262&quot;&gt;交叉编译Hi3536上面使用的nginx&lt;/a&gt;，里面的方法解决了这个问题。最后总结出了这样的 patch :&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/nginx-1.14.2/auto/cc/name b/nginx-1.14.2/auto/cc/name
index ded93f5..d6ab27a 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/nginx-1.14.2/auto/cc/name
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/nginx-1.14.2/auto/cc/name
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -7,7 +7,7 @@ if [ &quot;$NGX_PLATFORM&quot; != win32 ]; then
&lt;/span&gt; 
     ngx_feature=&quot;C compiler&quot;
     ngx_feature_name=
&lt;span class=&quot;gd&quot;&gt;-    ngx_feature_run=yes
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    ngx_feature_run=no
&lt;/span&gt;     ngx_feature_incs=
     ngx_feature_path=
     ngx_feature_libs=
&lt;span class=&quot;gh&quot;&gt;diff --git a/nginx-1.14.2/auto/lib/openssl/make b/nginx-1.14.2/auto/lib/openssl/make
index 126a238..7a0e768 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/nginx-1.14.2/auto/lib/openssl/make
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/nginx-1.14.2/auto/lib/openssl/make
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -51,7 +51,7 @@ END
&lt;/span&gt; $OPENSSL/.openssl/include/openssl/ssl.h:	$NGX_MAKEFILE
 	cd $OPENSSL \\
 	&amp;amp;&amp;amp; if [ -f Makefile ]; then \$(MAKE) clean; fi \\
&lt;span class=&quot;gd&quot;&gt;-	&amp;amp;&amp;amp; ./config --prefix=$ngx_prefix no-shared no-threads $OPENSSL_OPT \\
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+	&amp;amp;&amp;amp; ./config --prefix=$ngx_prefix no-shared no-threads --cross-compile-prefix=riscv64-linux-musl- $OPENSSL_OPT \\
&lt;/span&gt; 	&amp;amp;&amp;amp; \$(MAKE) \\
 	&amp;amp;&amp;amp; \$(MAKE) install_sw LIBDIR=lib
 
&lt;span class=&quot;gh&quot;&gt;diff --git a/nginx-1.14.2/auto/types/sizeof b/nginx-1.14.2/auto/types/sizeof
index 480d8cf..52c7287 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/nginx-1.14.2/auto/types/sizeof
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/nginx-1.14.2/auto/types/sizeof
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -33,7 +33,7 @@ int main(void) {
&lt;/span&gt; END
 
 
&lt;span class=&quot;gd&quot;&gt;-ngx_test=&quot;$CC $CC_TEST_FLAGS $CC_AUX_FLAGS \
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+ngx_test=&quot;gcc $CC_TEST_FLAGS $CC_AUX_FLAGS \
&lt;/span&gt;           -o $NGX_AUTOTEST $NGX_AUTOTEST.c $NGX_LD_OPT $ngx_feature_libs&quot;
 
 eval &quot;$ngx_test &amp;gt;&amp;gt; $NGX_AUTOCONF_ERR 2&amp;gt;&amp;amp;1&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;./configure --with-cc=riscv64-linux-musl-gcc --with-cc-opt=-static --with-ld-opt=-static --without-pcre --without-http_rewrite_module --without-http_gzip_module --with-poll_module --without-http_upstream_zone_module&lt;/code&gt; 之后，修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;objs/ngx_auto_config.h&lt;/code&gt;，加入：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#ifndef NGX_SYS_NERR
#define NGX_SYS_NERR  132
#endif
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifndef NGX_HAVE_SYSVSHM
#define NGX_HAVE_SYSVSHM 1
#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着就可以正常编译了：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;file objs/nginx
objs/nginx: ELF 64-bit LSB executable, UCB RISC-V, version 1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SYSV&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, statically linked, with debug_info, not stripped
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>在 rCore 上运行 nginx</title>
   <link href="https://jiege.ch/programming/2019/03/08/running-nginx-on-rcore/"/>
   <updated>2019-03-08T18:07:00+08:00</updated>
   <id>https://jiege.ch/programming/2019/03/08/running-nginx-on-rcore</id>
   <content type="html">&lt;p&gt;阿 西 吧 nginx 终于能在 rCore 上跑了 orrrrrrrz&lt;/p&gt;

&lt;p&gt;通过这半个多月来的大量开发，我和王润基 @wangrunji0408 学长算是终于完成了第一个 milestone：跑起来一个 nginx 。遇到了很多困难，大概有这些：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;syscall 实现不全。各种方面都缺，然后 nginx 在编译的时候又检测到比较新的 OS 版本，所以很多 syscall 都用了新的来替代老的，例如 readv/writev pread/pwrite accept4 等等，所以这方面做了一些工作。另外，还有很多新的 syscall 进来，太多了我就不细说了，基本上一个commit做一点一个commit做一点这个样子。&lt;/li&gt;
  &lt;li&gt;nginx 用到了 SSE 的寄存器 xmm ，但是之前是没有开的。所以把 sse 打开，然后切换上下文的时候把 sse 通过 fxsave 保存和 fxrstor 恢复（有意思的是，as居然不认这俩，只好手动写字节码），然后为了 16bit 的对齐又写了几行汇编代码。这块问题不大，今天一会就搞定了。但是如果要性能更高一些的话，可能需要在第一次使用 xmm 的时候再开始保存，大概就是加一个bit的事情。&lt;/li&gt;
  &lt;li&gt;文件系统有点崩。实现还是有很多 BUG ，表现就是需要经常重新 mksfs 一下，再重启加载完好的 fs ，有时候强制关机一下就又崩了。&lt;/li&gt;
  &lt;li&gt;内存管理做了一些改变。为了实现更加完整的 mmap mumap 和 mprotect ，又发现了一些新的 BUG 在里面，然后慢慢修复了。就是实现的有点粗暴。&lt;/li&gt;
  &lt;li&gt;死锁问题。这个其实现在还会出现，只是还没调出来，也不会百分百出现。我们计划在锁上面做一些死锁检测，例如记住是谁上锁的，等等。现在就遇到一个很玄学的死锁问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后代码也是一边在写一边在重构吧，很多地方现在都写得很粗暴，FIXME和TODO留了很多，很多地方也写得不够优雅。以后再慢慢重构+优化吧。&lt;/p&gt;

&lt;p&gt;截图留念：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/nginx.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再往前的话，还有很多小的问题，例如网卡的中断启用了但没有改 mask ，所以啥也没收到，靠 QEMU Tracing 找到问题。还有一个很有意思的现象，就是如果 elf 的 program header 没有 phdr 这个项的时候，我们发现，可以通过第一个load（如果加载了完整的 elf 头的话），我们可以从这里推断出 phdr 的地址（load的虚拟地址加偏移），然后丢到 auxv 里去让 musl 配置 tls。总之这些都解决了。也不用去考虑兼容 litc 了，已经全部向 linux 靠拢了，稳。&lt;/p&gt;

&lt;p&gt;注：最简 nginx 编译参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure --with-cc=/usr/bin/musl-gcc --with-cc-opt=-static --with-ld-opt=-satic --without-pcre --without-http_rewrite_module --without-http_gzip_module --with-poll_module
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样编译出来是一个静态文件，并且在 strip 之后只有不到 1M 的大小。&lt;/p&gt;

&lt;p&gt;最简 nginx 配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;daemon off;
master_process off;

events {
    use poll;
}

http {
    server {
        listen 80;
        server_name _;

        root /;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就免去了一些麻烦（多线程、多进程交互还是有很多问题），但确实可以跑起来了。&lt;/p&gt;

&lt;p&gt;另外，还需要写一份 /etc/passwd 和 /etc/group 用于 nobody 和 nogroup 。不需要其他额外的东西了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>实现网络的 syscall</title>
   <link href="https://jiege.ch/programming/2019/03/04/implement-network-syscalls/"/>
   <updated>2019-03-04T16:40:00+08:00</updated>
   <id>https://jiege.ch/programming/2019/03/04/implement-network-syscalls</id>
   <content type="html">&lt;p&gt;有了网卡驱动，接下来要做的就做网络的 syscall 了。为了测试，首先在 busybox 里找可以用来测试的 applet ，由于没有实现 poll ，所以 nc telnet 啥的都用不了。最后选择到了 ping 和 pscan 上。&lt;/p&gt;

&lt;p&gt;ping大家都很了解，pscan就是一个扫端口的，对一个ip连续的若干个端口发起 tcp 请求。这就要求我提供 raw socket和tcp socket状态的支持。由于网络栈本身是异步的，但 read connect 这些函数在不调 setsockopt 的前提下又是同步的，然而现在又没有 signal 可以用，要是 block 了就再也出不来了。于是就采用了 Condvar 的办法，拿一个全局的条件变量，当 poll 不到内容的时候，先把线程拿掉，等到网络栈更新了，再恢复。这样至少不会把 cpu 也 block 住。&lt;/p&gt;

&lt;p&gt;然后就是把 socket 部分改了又改吧，数据结构的设计改了几次，为了解决 ownership 问题上锁啊也有点多，但是也更细了，虽然实际上可能没有必要，因为上面还有大的锁。不过性能还不是现在考虑的重点，关键还要先把 send recv accept bind listen 啥的写得差不多了，然后还有把 poll/select 实现了，这个很关键。&lt;/p&gt;

&lt;p&gt;中间遇到的最大的坑就是，接收 pci interrupt 的时候总是啥也没有，然后靠万能的 qemu trace 发现，原来是 mask 掉了，所以啥也收不了，然后最后的解决方案就是用 MSI Interrupt #55 搞定了这个问题。至于为啥是 55 呢，因为 23 + 32 = 55 啊（误&lt;/p&gt;

&lt;p&gt;总之是修好了。终于可以继续写其它的 syscall 了。还没想好 poll 要怎么写，orz。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用 Rust 实现 e1000 驱动</title>
   <link href="https://jiege.ch/programming/2019/02/26/network-driver-again/"/>
   <updated>2019-02-26T20:30:00+08:00</updated>
   <id>https://jiege.ch/programming/2019/02/26/network-driver-again</id>
   <content type="html">&lt;p&gt;是的。我又来了。上次做了&lt;a href=&quot;/programming/2019/01/29/virtio-drivers-implementation/&quot;&gt;使用 Rust 实现 VirtIO 驱动&lt;/a&gt;之后，继续往 rCore 加更多的驱动支持。由于现在工作重点是 x86_64 下的 syscall 实现，所以选了一个比较有代表性的驱动 e1000 来实现。其实如果只是为了在 qemu 下运行的话，其实只需要支持 virtio-pci 就可以了，原来的 virtio-net 直接拿来用就可以了。&lt;/p&gt;

&lt;p&gt;为什么挑 e1000 呢，一方面是支持的设备多，有真实硬件可以测试，虽然不一定要裸机上跑，但是可以通过 PCI passthrough 来测试驱动的正确性。另一方面是网上的资料比较多，有现成的简单的代码可以借鉴。这次主要借鉴了三个来源：一是 Biscuit OS， 二是 Judge Duck OS ，三是 Linux 。&lt;/p&gt;

&lt;p&gt;首先是实现了简单的 PCI 总线的枚举，然后找到对应的设备，激活，并且找到映射的内存地址，然后把原来 C 语言的实现搬运到 Rust 中。这个过程中遇到很多坑，例如一开始我以为内核里 pa 和 va 是一个固定的偏移，不过多次尝试后才发现这个假设只对 riscv 平台里的实现成立。&lt;/p&gt;

&lt;p&gt;这个时候就可以收到外面给进来的以太网帧了。接着就是把它接入到 smoltcp 的 API 中。但是发包又不工作了，尝试了很多次，各种方法也不行。其中特别要提到的就是 qemu 的 tracing API ，它在帮助我调试之前的 virtio 驱动和这次的 e1000(e) 驱动中起到了很大的帮助。不过，遗憾的是，发包相关的代码里的 trace 不足以让我找到问题的所在，我只好采用了最后一招：&lt;/p&gt;

&lt;p&gt;下载 QEMU ，自己改，然后自己编译。&lt;/p&gt;

&lt;p&gt;这个方法果然很有效啊，经过简单的几个修改，很快就定位到问题所在了，原来就是一个简单的错误，把 4 写成了 8 。这个过程中我也发现 QEMU 在 incremental build 的时候似乎会 segfault ，我没管这么多，反正编译也不慢，次数也不多，每次 clean 再 build 问题也不大。&lt;/p&gt;

&lt;p&gt;接下来要摸索 82559 的网卡适用情况如何，因为有一个真实的 82559 网卡可供测试。另一方面就要开始考虑 socket 那一套 syscall 怎么做了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用 Rust 实现 VirtIO 驱动</title>
   <link href="https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation/"/>
   <updated>2019-01-29T17:23:00+08:00</updated>
   <id>https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation</id>
   <content type="html">&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;最近在给 rCore 添加驱动层的支持。一开始是想做网卡驱动，后来发现， &lt;code class=&quot;highlighter-rouge&quot;&gt;qemu-system-riscv32&lt;/code&gt; 只支持如下的驱动：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# qemu-system-riscv32 -device help&lt;/span&gt;

Storage devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-cd&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI CD-ROM&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-disk&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI disk or CD-ROM (legacy)&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-hd&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI disk&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-blk-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-scsi-device&quot;&lt;/span&gt;, bus virtio-bus

Network devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-net-device&quot;&lt;/span&gt;, bus virtio-bus

Input devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtconsole&quot;&lt;/span&gt;, bus virtio-serial-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-keyboard-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-mouse-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-serial-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-tablet-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtserialport&quot;&lt;/span&gt;, bus virtio-serial-bus

Display devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-gpu-device&quot;&lt;/span&gt;, bus virtio-bus

Misc devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;loader&quot;&lt;/span&gt;, desc &lt;span class=&quot;s2&quot;&gt;&quot;Generic Loader&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-balloon-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-crypto-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-rng-device&quot;&lt;/span&gt;, bus virtio-bus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以要实现网卡的话，只能实现这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net-device&lt;/code&gt; ，而 VirtIO 驱动之间有很多共通的地方，于是顺带把 &lt;code class=&quot;highlighter-rouge&quot;&gt;gpu&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mouse&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;blk&lt;/code&gt; 实现了。&lt;/p&gt;

&lt;h1 id=&quot;第一个驱动-virtio-net-的实现&quot;&gt;第一个驱动 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net&lt;/code&gt; 的实现&lt;/h1&gt;

&lt;p&gt;首先想到并且实现了的是网卡驱动， &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net&lt;/code&gt; 。最开始的时候，为了简单，只开了一块缓冲区，每次同时只收/发一个包。首先拿了 &lt;a href=&quot;https://github.com/jiegec/device_tree-rs&quot;&gt;device_tree-rs&lt;/a&gt; 读取 bbl 传过来的 dtb 地址，找到各个 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio_mmio&lt;/code&gt; 总线以后按照设备类型找到对应的设备。然后就是对着 virtio 的标准死磕，同时看 Linux 和 QEMU 的源代码辅助理解，最后终于是成功地把收/发的两个 virtqueue 配置好，并且在中断的时候处理收到的包。这个时候，可以成功地输出收到的包的内容，并且发出指定内容的包了。效果就是看到了这样的图片（图中网站是 &lt;a href=&quot;https://hpd.gasmi.net/&quot;&gt;Hex Packet Decoder&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/arp_packet.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于此，写了一个简单的以太网帧的解析，ARP 的回复和 ping 的回复（直接修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO_REQUEST&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO_REPLY&lt;/code&gt; 然后更新 CHECKSUM），实现了最基本的 ping ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/arping.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ping.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;显卡驱动&quot;&gt;显卡驱动&lt;/h1&gt;

&lt;p&gt;网卡可以用了，很自然地会想到做一些其他的 virtio 驱动，第一个下手的是显卡。显卡和网卡的主要区别是，网卡是两个 queue 异步作，而在显卡驱动上则是在一个 queue 上每次放一输入一输出的缓冲区来进行交互，具体步骤在 virtio 标准中也写得很清楚。在这个过程中， QEMU 的 Tracing 功能帮了很大的忙，在调试 desc 的结构上提供了很多帮助。&lt;/p&gt;

&lt;p&gt;然后就在 framebuffer 上花了一个 mandelbrot ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mandelbrot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 @shankerwangmiao 的建议下，调了一下颜色：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mandelbrot2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就好看多了。&lt;/p&gt;

&lt;h1 id=&quot;http-服务器&quot;&gt;HTTP 服务器&lt;/h1&gt;

&lt;p&gt;在 @wangrunji0408 的提醒和建议下，我开始把一个 Rust 实现的网络栈 &lt;a href=&quot;https://github.com/m-labs/smoltcp&quot;&gt;smoltcp&lt;/a&gt; 集成到代码中来。这个库中，对底层 Interface 的要求如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当可以发包并且可以收包的时候，返回一收一发两个 Token ，并在使用的时候调用指定的函数。&lt;/li&gt;
  &lt;li&gt;当可以发包的时候，返回一个发的 Token ，含义同上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是我第一次看到这种抽象，而且也没有特别明确的文档表示，这个 Token 代表什么，我应该提供什么。我直接按照一些已有的例子，照着实现了一把。过程中遇到了 ownership 的问题，通过 Arc 和 Mutex 解决了，然后又出现了死锁的问题，调了半天才调出来。&lt;/p&gt;

&lt;p&gt;接着按照 somltcp 的样例写一个简单的 udp echo server 和（假的） tcp 服务器：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// simple http server&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TcpSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.can_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;write!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HTTP/1.1 200 OK&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Server: rCore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-Length: 13&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-Type: text/html&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Connection: Closed&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Hello, world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然很粗暴，但是 work 了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/http.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;鼠标驱动和块设备驱动&quot;&gt;鼠标驱动和块设备驱动&lt;/h1&gt;

&lt;p&gt;接着自然是往 QEMU 支持的剩下的 virtio 设备里下手。首先下手的是鼠标驱动。这次遇到了新的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由于缓冲的存在，每次只有在 EV_SYN 的时候才会一次性把若干个事件放入队列中。&lt;/li&gt;
  &lt;li&gt;一个事件就要一个 desc chain ，意味着直接串足够大小的 buffer 到同一个 desc chain 中并不能工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是只好痛定思痛照着 Linux 内核的实现把完整的 Virtqueue 的操作实现了，并且顺带把前面的网卡和显卡的驱动也更新了。果然，每次都是三个左右的事件（X，Y，SYN）插入，然后根据这些事件就可以计算出当前的鼠标位置了。&lt;/p&gt;

&lt;p&gt;至于块设备，遇到的则是别的坑。看标准的时候，本以为就一个结构体 virtio_blk_req 就搞完了，但仔细读了读，标准似乎没讲清楚，读的时候是怎么传，写的时候又是怎么传。于是在这里卡了很久，从 Tracing 信息可以看出，QEMU 一直认为我提供的 buffer 大小不正确，多次实验之后发现，给 device 写入的 buffer 大小为 block size 的整数倍加一，这个一存放的是状态，其他则是数据，真的太坑了。&lt;/p&gt;

&lt;p&gt;有了块设备以后，就可以替换掉原来的内嵌 SFS 的方案，转为直接从块设备读 SFS 文件。这里我没想明白 lazy_static 和 ownership 的一些问题，最后也则是@wangrunji0408 的帮助我解决了。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;用 Rust 写出一个可以工作的驱动并不难，只要知道 unsafe 怎么用，但是一旦需要深入思考这里应该用什么安全的方法封装的时候，才发现是个很困难的事情。现在虽然工作了，但是很多地方线程并不安全，代码也不够简洁高效，以后还有很多需要改进的地方。&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See also&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/oasis-tcs/virtio-spec&quot;&gt;Virtio Spec&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
</feed>
