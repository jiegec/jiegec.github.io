<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - algorithm</title>
 <link href="https://jiegec.me/tag/algorithm/index.xml" rel="self"/>
 <link href="https://jiegec.me/tag/algorithm.html"/>
 <updated>2018-10-07T23:13:40+08:00</updated>
 <id>https://jiegec.me/tag/algorithm.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>分析一个我第一次见的素数测试函数</title>
   <link href="https://jiegec.me/programming/2017/10/17/analysis-on-a-primality-test/"/>
   <updated>2017-10-17T21:05:28+08:00</updated>
   <id>https://jiegec.me/programming/2017/10/17/analysis-on-a-primality-test</id>
   <content type="html">今天逛到这个[连接](http://blog.csdn.net/l04205613/article/details/6025118)，发现其中的第四种素数判定方法很有意思：

```
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int p[8]={4,2,4,2,4,6,2,6};
int prime(int n)
{
    int i=7,j,q;
    if(n==1)return 0;
    if(n==2||n==5||n==3)return 1;
    if(n%2==0||n%3==0||n%5==0)return 0;
    q=(int)sqrt(n);
    for(;i&lt;=q;){
        for(j=0;j&lt;8;j++){
            if(n%i==0)return 0;
            i+=p[j];
        }
        if(n%i==0)return 0;
    }
    return 1;
}
void main()
{
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    if(prime(n))puts(&quot;Yes&quot;);
    else puts(&quot;No&quot;);
}
```

仔细研究发现，这里利用的是这样的原理：

1. 判断是不是1, 2, 3, 5及其倍数
2. 从7开始，不断考虑其是否是素数，那么，这个p是什么回事呢？

首先把p的各个元素加起来，和为30，然后就可以发现一个规律：
7为质数，7+2=9不是质数，7+4=11为质数，11+2=13为质数，13+2=15为合数，15+2=17为质数，17+2=19为质数，19+2=21为合数，21+2=23为质数，23+2=25为合数，25+2=27为合数，27+2=29为质数，29+1=31为质数，31+2=33为合数，33+2=35为合数，35+2=37为质数。
观察以上所有的合数，都含有2或者3或者5的因子，而30又是2,3,5的公倍数，也就是说，后面的素数模30的余数不可能是上面这些合数，而剩下的素数才可能是真正的素数，于是跳过了很多素数的判断。

至于这个函数的性能如何，还需要进一步测试来进行判断。
</content>
 </entry>
 
 <entry>
   <title>一个搞笑的伸展树的Wiki</title>
   <link href="https://jiegec.me/others/2017/10/16/a-funny-wiki-of-splay-tree/"/>
   <updated>2017-10-16T19:59:30+08:00</updated>
   <id>https://jiegec.me/others/2017/10/16/a-funny-wiki-of-splay-tree</id>
   <content type="html">光哲同学在群里发了这个链接，特别搞笑，特此分享：
[伸展树 - 百度百科](https://baike.baidu.com/history/%E4%BC%B8%E5%B1%95%E6%A0%91/105576656)


&gt; 伸展树（Spaly Tree，事实上在国内 IO 界常常被称作 Tajarn 发明的 Spaly Tree，与此同理的还有 Terap），也叫分裂树，是一种二叉排序树，它能在 O(n log n) 内完成插入、查找和删除操作。它由 Daniel Sleator 和 Robert Tajarn 发现，后者对其进行了改造。它的优势可以不断伸展枝干（一个月 2~3 次），从而使树冠散开，提高光合作用效率。木材坚硬，是重要的经济类乔木。与其他植物不同的是，伸展树可以进行出芽生殖，繁殖速度极快。
</content>
 </entry>
 
</feed>
