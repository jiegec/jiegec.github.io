<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - nat</title>
 <link href="https://jiegec.github.io/tag/nat/index.xml" rel="self"/>
 <link href="https://jiegec.github.io/tag/nat.html"/>
 <updated>2018-05-08T13:26:02+08:00</updated>
 <id>https://jiegec.github.io/tag/nat.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>使用 iptables 和策略路由进行带源地址的 forwarding</title>
   <link href="https://jiegec.github.io/networking/2018/05/06/nat-forwarding-with-src-address/"/>
   <updated>2018-05-06T14:07:00+08:00</updated>
   <id>https://jiegec.github.io/networking/2018/05/06/nat-forwarding-with-src-address</id>
   <content type="html">&lt;p&gt;陈老师打开他的服务器，突然发现 CPU 莫名高负载，然后发现是有一个用户被远程登录拿来挖矿了。但是这台机器在 NAT 后，所以登录的源地址全是 NAT 路由，所以不知道对方的地址是什么。我们为了能使用 fail2ban 来禁用多次尝试失败的 IP ，但又不想因为别人把 NAT 路由的地址给禁了，这样我们自己也用不了了。所以必须要让这台机器能够知道 ssh 的源地址，我们现在简单的 socat 方案不能满足这个需求。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以在外网连 NAT 路由的高端口（如2222）来访问这台机器。&lt;/li&gt;
  &lt;li&gt;在内网中，既可以直接连它的内网地址，也可以连 NAT 路由的高端口来访问这台服务器。此时，由于连 ssh 的机器就在同一个子网中，如果保留了源地址，服务器发的包会直接回来不经过 NAT 。所以我们还是保留了 socat 的方案。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现方法：&lt;/p&gt;

&lt;p&gt;在 NAT Router 上配置 DNAT ，这样发到 NAT Router 上的包就可以转发到服务器上：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; nat &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; external_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 2222 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; internal_server_ip:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，从服务器回来的包到了 NAT Router 上后，由于路由表的配置问题，默认的路由并不能把包送达对方。所以，我们首先给包打上 mark：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; mangle &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; internal_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--sport&lt;/span&gt; 22 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; MARK &lt;span class=&quot;nt&quot;&gt;--set-mark&lt;/span&gt; 0x2222
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后配置策略路由：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip rule add fwmark 0x2222 table 2222
ip route add table 2222 default via gateway_address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以保证 ssh 的回包可以原路返回了。&lt;/p&gt;

&lt;p&gt;由于前面提到的原因，上面我们配置的 DNAT 规则只对外网过来的包有效。为了内网的访问，我们仍然采用了 socat 的方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socat TCP-LISTEN:2222,reuseaddr,fork TCP:internal_server_ip:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从不同的机器测试，都可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;who&lt;/code&gt; 看到，地址确实是我们想看到的源地址。接下来配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;fail2ban &lt;/code&gt;即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>利用 UPnP 协议进行 mosh NAT 穿透的研究</title>
   <link href="https://jiegec.github.io/networking/2018/05/05/mosh-behind-nat-with-upnp/"/>
   <updated>2018-05-05T20:25:00+08:00</updated>
   <id>https://jiegec.github.io/networking/2018/05/05/mosh-behind-nat-with-upnp</id>
   <content type="html">&lt;p&gt;由于经常要从宿舍、教室等不同的 Wi-Fi 之间切换，但是 ssh 连接又总是断，所以想用 mosh 代替 ssh 。但是 mosh 也有它的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不能滚动。这个可以在 mosh 中嵌套一层 tmux 解决。我目前写了一些自动 mosh 后打开 tmux 并且开启鼠标支持的脚本，但还是有缺陷。&lt;/li&gt;
  &lt;li&gt;在高端口 60000+ 监听 UDP ，这使得 NAT 后的服务器难以直接通过端口转发。如果直接转发到 NAT 后的机器，那么 NAT 后面如果有多台机器，这又失效了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是找了找网上的 NAT 穿透的一些文章，看到了 UPnP 的方法。大致就是，用户可以向路由器注册一个临时的转发规则，路由会自动在 iptables 上配置转发。但是，这样也会遇到一个问题：路由上的 mosh-server 不知道这个转发的存在，所以它可能会尝试监听同样的端口。解决方案下面会提到。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server &amp;lt;---&amp;gt; NAT Router &amp;lt;---&amp;gt; My Laptop
On NAT Router, port 8022 is forwarded to Server:22
1. mosh router # works
2. mosh --ssh=&quot;ssh -p 8022&quot; router # works
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先在 NAT Router 上配置 miniupnpd （以 Debian 为例）&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install miniupnpd
&lt;span class=&quot;c&quot;&gt;# you will get a dialog upon installation&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# input your wan interface and listening ip accordingly&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim /etc/default/miniupnpd
&lt;span class=&quot;c&quot;&gt;# edit START_DAEMON=0 to START_DAEMON=1&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim /etc/miniupnpd/miniupnpd.conf
&lt;span class=&quot;c&quot;&gt;# edit ext_ifname, listening_ip accordingly&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# set secure_mode=yes&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# add 'allow 60000-60023 internal_ip/prefix 60000-60023'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# before the last line 'deny 0-65535 0.0.0.0/0 0-65535'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; miniupnpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，复制 &lt;a href=&quot;https://github.com/jiegec/mosh-upnp-hole-puncher/blob/master/mosh-wrapper.js&quot;&gt;我修改的mosh-wrapper.js&lt;/a&gt; 到用户的 home 目录下，在 Server 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpc&lt;/code&gt; 然后通过：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mosh &lt;span class=&quot;nt&quot;&gt;--ssh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ssh -p 8022&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/mosh-wrapper.js user@router
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样， mosh 首先会通过 ssh 和 Server 协商一个 AES 的密钥和 UDP 端口（如 60001 ），之后的通信都通过 UDP 端口走加密后的流量。我的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-wrapper.js&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpc&lt;/code&gt; 向路由器请求把该 UDP 端口转发到 Server 上，这样， &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 就能通过 NAT 路由穿透到后面的 Server 上。&lt;/p&gt;

&lt;p&gt;等会！问题来了：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 默认的 IP 范围是 &lt;code class=&quot;highlighter-rouge&quot;&gt;60000-61000&lt;/code&gt; ，根据我的观察，它会从 60001 开始尝试监听本机地址，如果已经被占用，则 60002, 60003, … 但是！Router 和 Server 实际上占用了相同的端口空间，并且 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 只知道本机哪些端口被占用了，而不知道 Router 和 Server 共同占用了多少端口。&lt;/p&gt;

&lt;p&gt;我想到了一些可能的解决方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 Router 上让 miniupnpd 监听对应的端口，占住这个坑。这样，Router 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 就不会用和 Server 相同的端口&lt;/li&gt;
  &lt;li&gt;如果有多个 Server ，则会出现抢夺相同端口的情况。我目前的想法是，让 &lt;code class=&quot;highlighter-rouge&quot;&gt;upnpc&lt;/code&gt; 去询问 Router 找空闲的端口，然后再传给 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 使用。另一种方法则是，给不同的 Server 划分不同的端口范围，比如 Router 用 60001-60005, 然后 Server1 用 60006-60010, Server2 用 60011-60015 如此下去。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后，新的问题又发现了：&lt;/p&gt;

&lt;p&gt;当我在和 Server 同一个子网的时候，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpd&lt;/code&gt; 配置的 &lt;code class=&quot;highlighter-rouge&quot;&gt;iptables&lt;/code&gt; 规则中来源只有 WAN interface ，所以我在内网发的包是不会被转发的。当然，既然在内网了，为啥不直接用内网 IP 呢，不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 有没有提供设置备用 IP 的功能。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>NAT64 初尝试</title>
   <link href="https://jiegec.github.io/networking/2018/01/02/first-trial-of-NAT64/"/>
   <updated>2018-01-02T19:41:22+08:00</updated>
   <id>https://jiegec.github.io/networking/2018/01/02/first-trial-of-NAT64</id>
   <content type="html">&lt;p&gt;最近宿舍里有线网络的 IPv4 总是拿不到地址，只能连无线网，不禁对计算机系学生的可怕的设备数量有了深刻的认识。不过，作为一个有道德（误）的良好青年，还是不要给已经枯竭的 IPv4 地址填堵了，还是赶紧玩玩 IPv6 的网络吧。然后在 TUNA 群里受青年千人续本达 (@heroxbd) 的安利，本地搭建一下 NAT64+DNS64 的环境。不过考虑到宿舍还是拿不到有线的 IPv4 地址，我就先利用苹果先前在强制 iOS 的应用支持 NAT64 网络的同时，在 macOS 上为了方便开发者调试，提供的便捷的建立 NAT64 网络的能力。&lt;/p&gt;

&lt;p&gt;首先在设置中按住 Option 键打开 Sharing ， 点击 Internet Sharing ，勾上 Create NAT64 Network 然后把网络共享给设备。然后在手机上关掉 Wi-Fi 和 Cellular ，发现还能正常上网。此时可以打开 Wireshark 验证我们的成果了：&lt;/p&gt;

&lt;p&gt;在手机上打开浏览器，浏览千度，得到如下的 Wireshark 截图：
&lt;img src=&quot;/assets/baidu-nat64.jpg&quot; alt=&quot;baidu-nat64&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里，&lt;code class=&quot;highlighter-rouge&quot;&gt;2001:2:0:aab1::1&lt;/code&gt; 是本机在这个子网中的地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;2001:2::aab1:cda2:5de:87f6:fd78&lt;/code&gt; 是我的 iOS 设备的地址，然后 iOS 向 macOS 发出了 DNS请求， macOS 发送 DNS 请求后得到 &lt;code class=&quot;highlighter-rouge&quot;&gt;baidu.com&lt;/code&gt; 的 IPv4 地址之一为 &lt;code class=&quot;highlighter-rouge&quot;&gt;111.13.101.208&lt;/code&gt; ：
&lt;img src=&quot;/assets/baidu-dns.jpg&quot; alt=&quot;baidu-dns&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，我们可以看到， &lt;code class=&quot;highlighter-rouge&quot;&gt;baidu.com&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;AAAA&lt;/code&gt; 记录是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2001:2:0:1baa::6f0d:65d0&lt;/code&gt; ，这个就是 DNS64 转译的地址，前面为网关的 &lt;code class=&quot;highlighter-rouge&quot;&gt;prefix&lt;/code&gt; ，后面就是对应的 IPv4 地址： &lt;code class=&quot;highlighter-rouge&quot;&gt;0x6f=111, 0x0d=13, 0x65=101, 0xd0=208&lt;/code&gt; ，当客户端向这个地址发包的时候，网关发现前缀符合条件，把最后的这部分 IPv4 地址取出来，自己把包发送到真实的地址上去，再把返回来的包再转为 IPv6 的地址返还给客户端。可以验证，剩下的几个地址也符合这个转译规则。&lt;/p&gt;

&lt;p&gt;这就实现了：利用一台连接着 IPv6 和 IPv4 两种网络的网关，可以使得 IPv6 这个网络通过网关访问 IPv4 。通过配置，也可以使得 IPv4 访问 IPv6 中的地址（即 Stateful 和 Stateless 的区分，需要手动配置映射）。&lt;/p&gt;

&lt;p&gt;好处：作为比较成熟的 IPv4 到 IPv6 过渡方案之一，可以让自己组建的 IPv6 网络访问一些仅 IPv4 的网站。
坏处：依赖于 DNS64 ，必须要经过一层翻译，一些应用或协议可能写死了 IPv4 的地址，该方法可能会失效。&lt;/p&gt;
</content>
 </entry>
 
</feed>
