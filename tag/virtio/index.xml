<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - virtio</title>
 <link href="https://jiege.ch/tag/virtio/index.xml" rel="self"/>
 <link href="https://jiege.ch/tag/virtio.html"/>
 <updated>2019-02-09T20:45:26+04:00</updated>
 <id>https://jiege.ch/tag/virtio.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>使用 Rust 实现 VirtIO 驱动</title>
   <link href="https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation/"/>
   <updated>2019-01-29T13:23:00+04:00</updated>
   <id>https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation</id>
   <content type="html">&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;最近在给 rCore 添加驱动层的支持。一开始是想做网卡驱动，后来发现， &lt;code class=&quot;highlighter-rouge&quot;&gt;qemu-system-riscv32&lt;/code&gt; 只支持如下的驱动：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# qemu-system-riscv32 -device help&lt;/span&gt;

Storage devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-cd&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI CD-ROM&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-disk&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI disk or CD-ROM (legacy)&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-hd&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI disk&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-blk-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-scsi-device&quot;&lt;/span&gt;, bus virtio-bus

Network devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-net-device&quot;&lt;/span&gt;, bus virtio-bus

Input devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtconsole&quot;&lt;/span&gt;, bus virtio-serial-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-keyboard-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-mouse-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-serial-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-tablet-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtserialport&quot;&lt;/span&gt;, bus virtio-serial-bus

Display devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-gpu-device&quot;&lt;/span&gt;, bus virtio-bus

Misc devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;loader&quot;&lt;/span&gt;, desc &lt;span class=&quot;s2&quot;&gt;&quot;Generic Loader&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-balloon-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-crypto-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-rng-device&quot;&lt;/span&gt;, bus virtio-bus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以要实现网卡的话，只能实现这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net-device&lt;/code&gt; ，而 VirtIO 驱动之间有很多共通的地方，于是顺带把 &lt;code class=&quot;highlighter-rouge&quot;&gt;gpu&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mouse&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;blk&lt;/code&gt; 实现了。&lt;/p&gt;

&lt;h1 id=&quot;第一个驱动-virtio-net-的实现&quot;&gt;第一个驱动 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net&lt;/code&gt; 的实现&lt;/h1&gt;

&lt;p&gt;首先想到并且实现了的是网卡驱动， &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net&lt;/code&gt; 。最开始的时候，为了简单，只开了一块缓冲区，每次同时只收/发一个包。首先拿了 &lt;a href=&quot;https://github.com/jiegec/device_tree-rs&quot;&gt;device_tree-rs&lt;/a&gt; 读取 bbl 传过来的 dtb 地址，找到各个 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio_mmio&lt;/code&gt; 总线以后按照设备类型找到对应的设备。然后就是对着 virtio 的标准死磕，同时看 Linux 和 QEMU 的源代码辅助理解，最后终于是成功地把收/发的两个 virtqueue 配置好，并且在中断的时候处理收到的包。这个时候，可以成功地输出收到的包的内容，并且发出指定内容的包了。效果就是看到了这样的图片（图中网站是 &lt;a href=&quot;https://hpd.gasmi.net/&quot;&gt;Hex Packet Decoder&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/arp_packet.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于此，写了一个简单的以太网帧的解析，ARP 的回复和 ping 的回复（直接修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO_REQUEST&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO_REPLY&lt;/code&gt; 然后更新 CHECKSUM），实现了最基本的 ping ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/arping.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ping.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;显卡驱动&quot;&gt;显卡驱动&lt;/h1&gt;

&lt;p&gt;网卡可以用了，很自然地会想到做一些其他的 virtio 驱动，第一个下手的是显卡。显卡和网卡的主要区别是，网卡是两个 queue 异步作，而在显卡驱动上则是在一个 queue 上每次放一输入一输出的缓冲区来进行交互，具体步骤在 virtio 标准中也写得很清楚。在这个过程中， QEMU 的 Tracing 功能帮了很大的忙，在调试 desc 的结构上提供了很多帮助。&lt;/p&gt;

&lt;p&gt;然后就在 framebuffer 上花了一个 mandelbrot ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mandelbrot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 @shankerwangmiao 的建议下，调了一下颜色：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mandelbrot2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就好看多了。&lt;/p&gt;

&lt;h1 id=&quot;http-服务器&quot;&gt;HTTP 服务器&lt;/h1&gt;

&lt;p&gt;在 @wangrunji0408 的提醒和建议下，我开始把一个 Rust 实现的网络栈 &lt;a href=&quot;https://github.com/m-labs/smoltcp&quot;&gt;smoltcp&lt;/a&gt; 集成到代码中来。这个库中，对底层 Interface 的要求如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当可以发包并且可以收包的时候，返回一收一发两个 Token ，并在使用的时候调用指定的函数。&lt;/li&gt;
  &lt;li&gt;当可以发包的时候，返回一个发的 Token ，含义同上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是我第一次看到这种抽象，而且也没有特别明确的文档表示，这个 Token 代表什么，我应该提供什么。我直接按照一些已有的例子，照着实现了一把。过程中遇到了 ownership 的问题，通过 Arc 和 Mutex 解决了，然后又出现了死锁的问题，调了半天才调出来。&lt;/p&gt;

&lt;p&gt;接着按照 somltcp 的样例写一个简单的 udp echo server 和（假的） tcp 服务器：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// simple http server&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TcpSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.can_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;write!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HTTP/1.1 200 OK&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Server: rCore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-Length: 13&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-Type: text/html&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Connection: Closed&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Hello, world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然很粗暴，但是 work 了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/http.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;鼠标驱动和块设备驱动&quot;&gt;鼠标驱动和块设备驱动&lt;/h1&gt;

&lt;p&gt;接着自然是往 QEMU 支持的剩下的 virtio 设备里下手。首先下手的是鼠标驱动。这次遇到了新的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由于缓冲的存在，每次只有在 EV_SYN 的时候才会一次性把若干个事件放入队列中。&lt;/li&gt;
  &lt;li&gt;一个事件就要一个 desc chain ，意味着直接串足够大小的 buffer 到同一个 desc chain 中并不能工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是只好痛定思痛照着 Linux 内核的实现把完整的 Virtqueue 的操作实现了，并且顺带把前面的网卡和显卡的驱动也更新了。果然，每次都是三个左右的事件（X，Y，SYN）插入，然后根据这些事件就可以计算出当前的鼠标位置了。&lt;/p&gt;

&lt;p&gt;至于块设备，遇到的则是别的坑。看标准的时候，本以为就一个结构体 virtio_blk_req 就搞完了，但仔细读了读，标准似乎没讲清楚，读的时候是怎么传，写的时候又是怎么传。于是在这里卡了很久，从 Tracing 信息可以看出，QEMU 一直认为我提供的 buffer 大小不正确，多次实验之后发现，给 device 写入的 buffer 大小为 block size 的整数倍加一，这个一存放的是状态，其他则是数据，真的太坑了。&lt;/p&gt;

&lt;p&gt;有了块设备以后，就可以替换掉原来的内嵌 SFS 的方案，转为直接从块设备读 SFS 文件。这里我没想明白 lazy_static 和 ownership 的一些问题，最后也则是@wangrunji0408 的帮助我解决了。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;用 Rust 写出一个可以工作的驱动并不难，只要知道 unsafe 怎么用，但是一旦需要深入思考这里应该用什么安全的方法封装的时候，才发现是个很困难的事情。现在虽然工作了，但是很多地方线程并不安全，代码也不够简洁高效，以后还有很多需要改进的地方。&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See also&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/oasis-tcs/virtio-spec&quot;&gt;Virtio Spec&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
</feed>
