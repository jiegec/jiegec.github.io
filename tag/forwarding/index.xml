<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - forwarding</title>
 <link href="https://jiegec.me/tag/forwarding/index.xml" rel="self"/>
 <link href="https://jiegec.me/tag/forwarding.html"/>
 <updated>2018-10-07T23:13:40+08:00</updated>
 <id>https://jiegec.me/tag/forwarding.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>通过 SSH 隧道连接 ADB 和 Android 设备</title>
   <link href="https://jiegec.me/networking/2018/09/13/adb-over-ssh-tunnel/"/>
   <updated>2018-09-13T13:20:00+08:00</updated>
   <id>https://jiegec.me/networking/2018/09/13/adb-over-ssh-tunnel</id>
   <content type="html">由于本机算力不足，想要在远程[编译 LineageOS](/programming/2018/06/18/building-lineageos-in-archlinux/) ，其中有一步需要连接到已有的设备，于是突发奇想：

1. adb 可以通过 网络连接
2. ssh 可以进行端口转发，这里是把 remote 的端口转发到 Android 设备上的端口。

方法如下：

```shell
$ adb shell ip -f inet addr show wlan0
$ # remember the ip address here
$ adb tcpip PORT1
$ ssh -R PORT2:ANDROID_IP:PORT1 REMOTE
(remote)$ adb connect localhost:PORT2 # trust this device on Android
```

参考文档：

1. [How can I connect to Android with ADB over TCP?](https://stackoverflow.com/a/3623727)
2. [SSH PORT FORWARDING EXAMPLE](https://www.ssh.com/ssh/tunneling/example)</content>
 </entry>
 
 <entry>
   <title>使用 Nginx 转发 VMware ESXi</title>
   <link href="https://jiegec.me/networking/2018/05/08/nginx-proxy-vmware-esxi/"/>
   <updated>2018-05-08T19:26:00+08:00</updated>
   <id>https://jiegec.me/networking/2018/05/08/nginx-proxy-vmware-esxi</id>
   <content type="html">我们的 VMware ESXi 在一台 NAT Router 之后，但是我们希望通过域名可以直接访问 VMware ESXi 。我们首先的尝试是，把 8443 转发到它的 443 端口，比如：

```shell
socat TCP-LISTEN:8443,reuseaddr,fork TCP:esxi_addr:443
```

它能工作地很好（假的，如果你把 8443 换成 9443 它就不工作了），但是，我们想要的是，直接通过 esxi.example.org 就可以访问它。于是，我们需要 Nginx 在其中做一个转发的功能。在这个过程中遇到了很多的坑，最后终于是做好了 （VMware Remote Console等功能还不行，需要继续研究）。

首先讲讲为啥把 8443 换成 9443 不能工作吧 -- 很简单，ESXi 的网页界面会请求 8443 端口。只是恰好我用 8443 转发到 443， 所以可以正常工作。这个很迷，但是测试的结果确实如此。VMware Remote Console 还用到了别的端口，我还在研究之中。

来谈谈怎么配置这个 Nginx 转发吧。首先是 80 跳转 443:
```
server {
        listen 80;
        listen 8080;
        server_name esxi.example.org;

        return 301 https://$host$request_uri;
}
```

这个很简单，接下来是转发 443 端口：
```

server {
        listen 443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;

        location / {
                proxy_pass https://esxi_addr;
                proxy_ssl_verify off;
                proxy_ssl_session_reuse on;
                proxy_set_header Host $http_host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }
}
```

此时，打开 https://esxi.example.org 就能看到登录界面了。但是仍然无法登录。从 DevTools 看错误，发现它请求了 8443 端口。于是进行转发：
```
server {
        listen 8443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;


        location / {
                if ($request_method = 'OPTIONS') {
                        add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org';
                        add_header 'Access-Control-Allow-Credentials' 'true';
                        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
                        add_header 'Access-Control-Max-Age' 1728000;
                        add_header 'Access-Control-Allow-Headers' 'VMware-CSRF-Token,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Cookie,SOAPAction';
                        add_header 'Content-Type' 'text/plain; charset=utf-8';
                        add_header 'Content-Length' 0;
                        return 204;
                }

                add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org';
                add_header 'Access-Control-Allow-Credentials' 'true';
                proxy_pass https://esxi_addr:443;
                proxy_ssl_verify off;
                proxy_ssl_session_reuse on;
                proxy_set_header Host $http_host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }
}
```

主要麻烦的是配置 CORS 的相关策略。我也是看了 DevTools 的错误提示半天才慢慢写出来的。这样配置以后，就可以成功登录 VMware ESXi 了。

20:02 更新：现在做了 WebSocket 转发，目前可以在浏览器中打开 Web Console 了。但是，在访问 https://esxi.example.org/ 的时候还是会出现一些问题，然而 https://esxi.example.org:8443/ 是好的。

转发 WebSocket：
```
map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
}

server {
        listen 8443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;


        location / {

                if ($request_method = 'OPTIONS') {
                        add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org';
                        add_header 'Access-Control-Allow-Credentials' 'true';
                        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
                        add_header 'Access-Control-Max-Age' 1728000;
                        add_header 'Access-Control-Allow-Headers' 'VMware-CSRF-Token,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Cookie,SOAPAction';
                        add_header 'Content-Type' 'text/plain; charset=utf-8';
                        add_header 'Content-Length' 0;
                        return 204;
                }

                add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org' always;
                add_header 'Access-Control-Allow-Credentials' 'true' always;

                proxy_pass https://esxi_addr:443;
                proxy_ssl_verify off;
                proxy_ssl_session_reuse on;
                proxy_set_header Host $http_host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
        }
}
```

20:29 更新：找到了 VMware Remote Console 的端口：902，用 iptables 进行 DNAT 即可：
```shell
iptables -A PREROUTING -i wan_interface -p tcp -m tcp --dport 902 -j DNAT --to-destination esxi_addr:902
```

2018-05-09 08:07 更新：最后发现，还是直接隧道到内网访问 ESXi 最科学。或者，让 443 重定向到 8443 ：
```
server {
        listen 443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;

        return 301 https://$host:8443$request_uri;
}
```
这样，前面也不用写那么多 CORS 的东西了。
</content>
 </entry>
 
 <entry>
   <title>搭建 FTP server behind NAT</title>
   <link href="https://jiegec.me/networking/2018/05/08/ftp-behind-nat/"/>
   <updated>2018-05-08T13:34:00+08:00</updated>
   <id>https://jiegec.me/networking/2018/05/08/ftp-behind-nat</id>
   <content type="html">我们出现新的需求，要把以前的 FTP 服务器迁移到 NAT 之后的一台机器上。但是，FTP 不仅用到 20 21 端口， PASV 还会用到高端口，这给端口转发带来了一些麻烦。我们一开始测试，直接在 Router 上转发 20 和 21 端口到 Server 上。但是很快发现， Filezilla 通过 PASV 获取到地址为 （内网地址，端口高8位，端口低8位），然后，Filezilla 检测出这个地址是内网地址，于是转而向 router_ip:port 发包，这自然是不会得到结果的。

此时我们去网上找了找资料，找到了一个很粗暴的方法：
```shell
iptables -A PREROUTING -i external_interface -p tcp -m tcp --dport 20 -j DNAT --to-destination internal_ip:20
iptables -A PREROUTING -i external_interface -p tcp -m tcp --dport 21 -j DNAT --to-destination internal_ip:21
iptables -A PREROUTING -i external_interface -p tcp -m tcp --dport 1024:65535 -j DNAT --to-destination internal_ip:1024-65535
```


有趣地是， macOS 自带的 ftp 命令（High Sierra似乎已经删去）可以正常使用。研究发现，它用 EPSV（Extended Passive Mode） 代替 PASV ，这里并没有写内网地址，因而可以正常使用。

这么做， Filezilla 可以成功访问了。但是，用其它客户端的时候，它会直连那个内网地址而不是 Router 的地址，于是还是连不上。而且，使用了 1024-65535 的所有端口，这个太浪费而且会影响我们其它的服务。

我们开始研究我们 FTP 服务器(pyftpdlib)的配置。果然，找到了适用于 FTP behind NAT 的相关配置：
```
     - (str) masquerade_address:
        the &quot;masqueraded&quot; IP address to provide along PASV reply when
        pyftpdlib is running behind a NAT or other types of gateways.
        When configured pyftpdlib will hide its local address and
        instead use the public address of your NAT (default None).
     - (dict) masquerade_address_map:
        in case the server has multiple IP addresses which are all
        behind a NAT router, you may wish to specify individual
        masquerade_addresses for each of them. The map expects a
        dictionary containing private IP addresses as keys, and their
        corresponding public (masquerade) addresses as values.
     - (list) passive_ports:
        what ports the ftpd will use for its passive data transfers.
        Value expected is a list of integers (e.g. range(60000, 65535)).
        When configured pyftpdlib will no longer use kernel-assigned
        random ports (default None).
```

于是，我们配置了 `masquerade_address` 使得 FTP 服务器会在 PASV 中返回 Router 的地址，并且在 `passive_ports` 中缩小了 `pyftpdlib` 使用的端口范围。

进行配置以后，我们在前述的 iptables 命令中相应修改了端口范围，现在工作一切正常。
</content>
 </entry>
 
 <entry>
   <title>使用 iptables 和策略路由进行带源地址的 forwarding</title>
   <link href="https://jiegec.me/networking/2018/05/06/nat-forwarding-with-src-address/"/>
   <updated>2018-05-06T14:07:00+08:00</updated>
   <id>https://jiegec.me/networking/2018/05/06/nat-forwarding-with-src-address</id>
   <content type="html">陈老师打开他的服务器，突然发现 CPU 莫名高负载，然后发现是有一个用户被远程登录拿来挖矿了。但是这台机器在 NAT 后，所以登录的源地址全是 NAT 路由，所以不知道对方的地址是什么。我们为了能使用 fail2ban 来禁用多次尝试失败的 IP ，但又不想因为别人把 NAT 路由的地址给禁了，这样我们自己也用不了了。所以必须要让这台机器能够知道 ssh 的源地址，我们现在简单的 socat 方案不能满足这个需求。

需求：

1. 可以在外网连 NAT 路由的高端口（如2222）来访问这台机器。
2. 在内网中，既可以直接连它的内网地址，也可以连 NAT 路由的高端口来访问这台服务器。此时，由于连 ssh 的机器就在同一个子网中，如果保留了源地址，服务器发的包会直接回来不经过 NAT 。所以我们还是保留了 socat 的方案。

实现方法：

在 NAT Router 上配置 DNAT ，这样发到 NAT Router 上的包就可以转发到服务器上：

```shell
iptables -t nat -A PREROUTING -i external_interface -p tcp -m tcp --dport 2222 -j DNAT --to-destination internal_server_ip:22
```

但是，从服务器回来的包到了 NAT Router 上后，由于路由表的配置问题，默认的路由并不能把包送达对方。

方法1:
我们首先给包打上 mark：

```shell
iptables -t mangle -A PREROUTING -i internal_interface -p tcp -m tcp --sport 22 -j MARK --set-mark 0x2222
```

然后配置策略路由：

```shell
ip rule add fwmark 0x2222 table 2222
ip route add table 2222 default via gateway_address
```

方法2: (UPD 2018-07-07)
利用 `ip rule` 直接达成同样的效果

```shell
ip rule add from internal_ip/prefix table 2222
# or
ip rule add iif internal_interface table 2222
ip route add table 2222 default via gateway_address
```

这样就可以保证 ssh 的回包可以原路返回了。

由于前面提到的原因，上面我们配置的 DNAT 规则只对外网过来的包有效。为了内网的访问，我们仍然采用了 socat 的方式：

```shell
socat TCP-LISTEN:2222,reuseaddr,fork TCP:internal_server_ip:22
```

从不同的机器测试，都可以在 `who` 看到，地址确实是我们想看到的源地址。接下来配置 `fail2ban `即可。
</content>
 </entry>
 
</feed>
