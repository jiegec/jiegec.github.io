<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - wireguard</title>
 <link href="https://jiege.ch/tag/wireguard/index.xml" rel="self"/>
 <link href="https://jiege.ch/tag/wireguard.html"/>
 <updated>2019-03-22T23:31:55+08:00</updated>
 <id>https://jiege.ch/tag/wireguard.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>在 WireGuard 构建的 Overlay Network 上跑 babel 路由协议</title>
   <link href="https://jiege.ch/networking/2018/08/10/use-babel-in-overlay-network-with-wireguard/"/>
   <updated>2018-08-10T09:17:00+08:00</updated>
   <id>https://jiege.ch/networking/2018/08/10/use-babel-in-overlay-network-with-wireguard</id>
   <content type="html">&lt;p&gt;受 &lt;a href=&quot;https://fugoes.github.io/computer/network/2018/02/03/Run-Babeld-over-Wireguard.html&quot;&gt;Run Babeld over Wireguard - Fugoes’s Blog&lt;/a&gt; 和 &lt;a href=&quot;https://vincent.bernat.im/en/blog/2018-route-based-vpn-wireguard&quot;&gt;Route-based VPN on Linux with WireGuard&lt;/a&gt; 启发，自己也想尝试一下，在一个有多个结点的网络中，如何通过 WireGuard 构建一个 overlay network，并通过 babel 自动进行结点发现和路径选择。&lt;/p&gt;

&lt;p&gt;首先建立点对点的 WireGuard Tunnel 。由于我们用 babel 进行路由，所以我们不能采用 Wiregurad 本身基于目的地址的端口复用，所以每一个 WireGuard interface 都只有一个 Peer 。&lt;/p&gt;

&lt;p&gt;配置一个点对点的 WireGuard Tunnel：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ # for wg-quick
$ cat wg0.conf
[Interface]
Address = IPV4/32, fe80::ID/64
PrivateKey = REDACTED
ListenPort = PORT1
Table = off # ask wg-quick not to insert peer address into routing table

[Peer]
PublicKey = REDACTED
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = REDACTED:PORT2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的 IPV4 和 ID 在同一设备上的不同 WireGuard Tunnel 上相同。只是通过 wg interface 编号来区分。&lt;/p&gt;

&lt;p&gt;接着配置 babeld ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat babeld.conf

router-id ID
local-port 33123 # for babelweb2

# one line for each wg interface
interface wg0 type tunnel rtt-max 512

redistribute ip PREFIX/LEN ge LEN le 32 local allow # tunnel neighbors
redistribute proto 42 # routes installed by babeld
redistribute local deny
# consult babeld man page for more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后通过 BabelWeb2 （很难用）进行可视化，然后通过手动触发一些网络波动即可达到效果。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Wireguard 隧道搭建</title>
   <link href="https://jiege.ch/networking/2018/06/29/wireguard-tunnel/"/>
   <updated>2018-06-29T10:59:00+08:00</updated>
   <id>https://jiege.ch/networking/2018/06/29/wireguard-tunnel</id>
   <content type="html">&lt;p&gt;随着 Wireguard Go 版本的开发，在 macOS 上起 WireGuard Tunnel 成为现实。于是，搭建了一个 macOS 和 Linux 之间的 WireGuard Tunnel。假设 Linux 端为服务端， macOS 端为客户端。&lt;/p&gt;

&lt;p&gt;macOS端：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew install wireguard-tools
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /usr/local/etc/wireguard
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wg genkey &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; privatekey
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wg pubkey &amp;lt; privatekey &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; publickey
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim tunnel.conf
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Interface]
PrivateKey &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; MACOS_PRIVATE_KEY

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Peer]
PublicKey &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; LINUX_PUBLIC_KEY &lt;span class=&quot;c&quot;&gt;# Generated below&lt;/span&gt;
AllowedIPs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 192.168.0.0/24
Endpoint &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; LINUX_PUBLIC_IP:12345
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim up.sh
&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# change interface name when necessary&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;wireguard-go utun0
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;wg setconf utun0 tunnel.conf
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;ifconfig utun0 192.168.0.2 192.168.0.1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;chmod +x up.sh
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./up.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置 Linux 端：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://git.zx2c4.com/WireGuard
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;make install
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;fish
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/wireguard
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wg genkey &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; privatekey
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wg pubkey &amp;lt; privatekey &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; publickey
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim wg0.conf
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Interface]
Address &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 192.168.0.1/24
PrivateKey &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; LINUX_PRIVATE_KEY
ListenPort &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 12345

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Peer]
PublicKey &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; MACOS_PUBLIC_KEY
AllowedIPs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 192.168.0.2/24
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wg-quick up wg0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;经过测试，两边可以互相 ping 通。&lt;/p&gt;

&lt;p&gt;后续尝试在 Android 上跑通 WireGuard 。&lt;/p&gt;

&lt;p&gt;UPDATE 2018-07-11:&lt;/p&gt;

&lt;p&gt;成功在 Android 上跑通 WireGuard 。在 Google Play 上下载官方的 App 即可。麻烦在于，将 Android 上生成的 Public Key 和服务器的 Public Key 进行交换。&lt;/p&gt;

&lt;p&gt;然后又看到&lt;a href=&quot;https://wiki.debian.org/Wireguard#Step_2_-_Alternative_C_-_systemd&quot;&gt;WireGuard在systemd-networkd&lt;/a&gt;上的配置方案，自己也实践了一下。首先，如果用的是 stretch ，请首先打开 stretch-backports 源并把 systemd 升级到 237 版本。&lt;/p&gt;

&lt;p&gt;然后，根据上面这个连接进行配置，由于都是 ini 格式，基本就是复制粘贴就可以配置了。有一点要注意，就是，要保护 PrivateKey 的安全，注意配置 .netdev 文件的权限。&lt;/p&gt;
</content>
 </entry>
 
</feed>
