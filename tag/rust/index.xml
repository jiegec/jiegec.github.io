<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - rust</title>
 <link href="https://jiege.ch/tag/rust/index.xml" rel="self"/>
 <link href="https://jiege.ch/tag/rust.html"/>
 <updated>2019-01-11T17:56:51+08:00</updated>
 <id>https://jiege.ch/tag/rust.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>Rust 获取 Linker Script 中的地址</title>
   <link href="https://jiege.ch/programming/2019/01/07/rust-access-linker-script-address/"/>
   <updated>2019-01-07T11:57:00+08:00</updated>
   <id>https://jiege.ch/programming/2019/01/07/rust-access-linker-script-address</id>
   <content type="html">&lt;p&gt;在 Linker Script 中可以记录下一个地址到一个变量中，大概这样：&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.text: {
	PROVIDE(__text_start = .);
    *(.text .text.* .gnu.linkonce.t*)
    PROVIDE(__text_end = .);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PROVIDE()&lt;/code&gt; 是可选的。这样，代码里就可以获取到 .text 段的地址了。在 C 中，直接 extern 一个同名的变量就可以了，但在 Rust 中，需要这样获取：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__text_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__text_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// __text_start as usize&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// __text_end as usize&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以拿到地址了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（8）</title>
   <link href="https://jiege.ch/programming/2018/04/10/thoughts-on-stanford-cs140e-8/"/>
   <updated>2018-04-10T17:27:00+08:00</updated>
   <id>https://jiege.ch/programming/2018/04/10/thoughts-on-stanford-cs140e-8</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/04/07/thoughts-on-stanford-cs140e-7/&quot;&gt;上一篇文章&lt;/a&gt;之后，我其实还是很忙，但是一直心理惦记着这件事，毕竟只剩最后的一点点就可以做完了，不做完总是觉得心痒。&lt;/p&gt;

&lt;p&gt;今天做的部分是调度。我们目前只在 EL0 运行了一个 shell ，每当触发 exception 时回到 kernel 进行处理，再回到原来的地方。但现在，我要实现一个 preemtive round-robin scheduler ，就需要管理当前的所有进程，并且维护当前的进程状态，当时钟中断到来的时候，决定下一个 time slice 要执行的进程，再切换过去。这个过程当然会遇到不少的坑。&lt;/p&gt;

&lt;p&gt;首先，我们需要判断一个进程是否可以执行了。考虑到阻塞的 IO ，作者提供了一个优雅的方法：如果这个进程阻塞在 IO 上，那么，提供一个函数，在 scheduler 中调用，判断所需要的数据是否到达。这样，我们就可以一个循环把下一个 time slice 要执行的线程找到。如果找不到，就等待 interrupt 再尝试。&lt;/p&gt;

&lt;p&gt;困难的地方在于，在启动的时候，切换到一个起始线程。并且在上下文切换的时候，在 process 1 -&amp;gt; kernel -&amp;gt; process 2 这两步过程中，有许多寄存器都需要仔细考虑如何实现。并且在这个过程中，我也发现了之前写的代码中的问题，最终修复了（目前来看是 working 了）。&lt;/p&gt;

&lt;p&gt;我的代码实现在 &lt;a href=&quot;https://github.com/jiegec/cs140e/commit/977f179a9b28e88e85f4ba9577a0682bf2b6c57b&quot;&gt;这里&lt;/a&gt; 。下一步就要写 syscall 了。希望能在期中前抽时间赶紧把这个做完。&lt;/p&gt;

&lt;p&gt;18:54 PM Update: 刚实现完了 sleep 的 syscall 。比预想中要简单。果然找到了自己实现的调度器的 BUG 。此系列大概是完结了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（7）</title>
   <link href="https://jiege.ch/programming/2018/04/07/thoughts-on-stanford-cs140e-7/"/>
   <updated>2018-04-07T14:05:00+08:00</updated>
   <id>https://jiege.ch/programming/2018/04/07/thoughts-on-stanford-cs140e-7</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/05/thoughts-on-stanford-cs140e-6/&quot;&gt;上一篇文章&lt;/a&gt;之后，我很长时间都没有在继续我这个项目，清明节刚好闲下来了我就回来继续啃它。Stanford那边已经结课，最后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;3-spawn&lt;/code&gt; 也只有一部分，剩下的部分不知道什么时候作者才会填上去了。&lt;/p&gt;

&lt;p&gt;这次主要要写的代码就是，对异常的处理。这里的异常并不是我们编程语言中的 catch/throw ，而是硬件的异常。AArch64 和 x86 一样，也有不同的特权级别的区分，前者是 EL0~EL3 ，后者则是 RING0 和 RING3 。特权级别高可以往特权级别低转换，但是反过来，只能通过异常的方式提高特权等级，并且切换特权等级后只有固定的一些代码可能会跳转，这就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception handler/vectors&lt;/code&gt; 。这些函数可以知道是什么原因调用了他们，根据硬件规定好的文档，我们可以知道发生了什么事情，是对齐出错了呢，还是用户调用了 syscall 呢，等等。根据不同的情况，我们需要进行不同的处理。当处理完之后，我们需要考虑，跳转回用户代码的时候，回到哪里，提供什么值，不提供什么。&lt;/p&gt;

&lt;p&gt;实现的话，需要很多步骤。首先是构造好 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception vector&lt;/code&gt; ，这里作者已经写好了一个宏（这里 @BenYip 遇到了一个 assembler 的 BUG ），直接用宏就可以把它写出来。然后，我们需要把它加载到当前 EL 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;VBAR_ELx&lt;/code&gt; 寄存器中，当 CPU 抛出异常的时候，就会找到这里相应的处理器进行处理。进到这里以后，我们首先先不考虑太多上下文保存的事情–我们先保证能处理异常，恢复也是个有很多坑的步骤，作者也是在这里分成了两个 Subphase 。首先还是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ESR_ELx&lt;/code&gt; 中解析到错误的来源的具体内容，如果是我们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 中自己调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 指令，我们就自己新开一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，修改了提示符以示区别。这样，我们就成功地捕捉到了这个异常。由于我们还无法恢复回去，所以我们直接死循环。&lt;/p&gt;

&lt;p&gt;接下来我们要做的是，从异常中恢复出来。由于用户代码可能在各种地方抛出异常，异常也分同步和异步两种情况，这里有许多需要考虑的问题。为了简化，我们目前只考虑同步的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 导致的 Brk 异常。为了能恢复之后能够正常运行，我们需要把所有的寄存器都保存下来，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;TrapFrame&lt;/code&gt; 。保存的时候需要讲究 AArch64 平台下 SP 寄存器的对齐问题。我们也要把一些特殊的寄存器保存下来。还有一点，就是，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception handler&lt;/code&gt; 中调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;context_save&lt;/code&gt; 函数，所以此时的 lr 本身也需要进行保存，这个地方也卡了我很久。最后，再把这些一个一个地恢复到原来的样子，调整 &lt;code class=&quot;highlighter-rouge&quot;&gt;ELR_EL1&lt;/code&gt; 使得退回到原来的状态时，会跳过当前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 指令，调用它的下一调指令。这样，我们就成功地在遇到异常时，弹出一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，而且还可以回退回来。&lt;/p&gt;

&lt;p&gt;学到了很多很多。之后大三，我们可能需要做自己的 CPU ，在自己的 CPU 上跑自己的操作系统，在自己的操作系统中跑自己的编译器，在自己的编译器中编译一个数据库。希望到时我还活着吧。#flag&lt;/p&gt;

&lt;p&gt;更新：&lt;a href=&quot;/programming/2018/04/10/thoughts-on-stanford-cs140e-8/&quot;&gt;下一篇在这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（6）</title>
   <link href="https://jiege.ch/programming/2018/03/05/thoughts-on-stanford-cs140e-6/"/>
   <updated>2018-03-05T19:55:49+08:00</updated>
   <id>https://jiege.ch/programming/2018/03/05/thoughts-on-stanford-cs140e-6</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/03/thoughts-on-stanford-cs140e-5/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者终于更新了测试的用例，我的程序终于可以成功跑过所有测试，也成功在树莓派跑起来。不过，我的代码中很多地方的错误处理比较偷懒，往往直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; ，显然并不友好。同时，我想到了使用 &lt;a href=&quot;https://github.com/rust-fuzz/cargo-fuzz&quot;&gt;cargo-fuzz&lt;/a&gt; 来进行自动化测试，果然，使用这个很快就修复了不少我没想到的会出错的地方，比如乘法溢出，目录项没有正确结束等等。目前还发现一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 的问题，研究发现大概是文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cluster chain&lt;/code&gt; 中出现了环，导致一直读取文件而没有停止。要解决这个问题，我目前想到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Floyd&lt;/code&gt; 的判圈算法，但还没上实现。等过几天，新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 3&lt;/code&gt; 出了以后，再继续更新。希望作者少点跳票，多点勤奋，哈哈哈哈哈&lt;/p&gt;

&lt;p&gt;更新：&lt;a href=&quot;/programming/2018/04/07/thoughts-on-stanford-cs140e-7/&quot;&gt;下一篇在这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（5）</title>
   <link href="https://jiege.ch/programming/2018/03/03/thoughts-on-stanford-cs140e-5/"/>
   <updated>2018-03-03T11:07:30+08:00</updated>
   <id>https://jiege.ch/programming/2018/03/03/thoughts-on-stanford-cs140e-5</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/27/thoughts-on-stanford-cs140e-4/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后（again），终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 3: Saddle Up&lt;/code&gt; 。这次，我们要做的变成了把已经写好的（错漏百出）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 的驱动搬到树莓派里面去，然后实现一些基本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 等等。作者首先更新了老版本的新的测试样例，放了一些映像然后提供了预期的结果，结果发现，这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 有一些不同，主要的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes_per_sector&lt;/code&gt; 不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt; 了，意味着物理的扇区和逻辑扇区并不一致。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;sectors_per_cluster&lt;/code&gt; 也不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 了，需要考虑多个扇区的情况。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;read_cluster&lt;/code&gt; 传入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;offset&lt;/code&gt; 也可能不再是第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sector&lt;/code&gt; 中的，所以需要做一个处理。对于物理和逻辑扇区的问题，作者推荐的方案是，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 之外的扇区保持不变，把其内的扇区视为逻辑扇区。这样，其它代码都可以透明地工作，而不用到处更改，这就体现了封装的威力。接着，作者提供了一个写好了的 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsd&lt;/code&gt; 和一些导出的函数，使用这些函数即可。不过，在错误处理和 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 上也遇到了一些坑。后面，把东西搬到树莓派上运行，问题就出现了：读取了第一个扇区（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 所在的扇区）之后，直接就死掉了。想了半天都没找到方案，突然想起可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic!&lt;/code&gt; 对错误语句进行二分查找。查找了大概有七八个小时之后，终于发现，问题出现在读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 类型的变量上。我起初怀疑是栈出了问题，所以放到堆上分配，然而还是不行。忽然想起以前遇到的对齐问题，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AArch64&lt;/code&gt; 架构上，可能为了简化，读取的 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 必须对齐到四个字节上。于是找了找 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中的对齐方面的文档，找到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(align=4)]&lt;/code&gt; 这种表示方法，代替了原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(packed)]&lt;/code&gt; ，并且把数据先拷贝到对齐后的栈上的对应数据结构，然后再读取对应的项。果然，这个问题就解决了。然后又发现我的盘中会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;lfn&lt;/code&gt; 项并不是从后往前的情况，于是我又修改了一下相关的代码。现在，终于可以成功地 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;不过还是要吐槽一下，作者的测试用的映像文件中，会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xE5&lt;/code&gt; 表示这个项已经被删除的情况，但是似乎作者的代码并没有处理这个，所以在预期的输出中出现了一些明显不正确的结果，导致我的代码跑测试并不能通过。而且，作者的代码在一些情况下会把文件的后缀漏掉。作者后来更新了几次测试的文件，不过这个问题只解决了一部分，并没有完全解决。坐等作者继续放出新的测试文件吧。&lt;/p&gt;

&lt;p&gt;更新：&lt;a href=&quot;/programming/2018/03/05/thoughts-on-stanford-cs140e-6/&quot;&gt;下一篇在这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（4）</title>
   <link href="https://jiege.ch/programming/2018/02/27/thoughts-on-stanford-cs140e-4/"/>
   <updated>2018-02-27T22:42:59+08:00</updated>
   <id>https://jiege.ch/programming/2018/02/27/thoughts-on-stanford-cs140e-4</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/16/thoughts-on-stanford-cs140e-3/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后，终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 2:32-bit Lipids&lt;/code&gt; ，这两天就把只读 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 写完了（不过封装得并不好，许多地方利用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;pub(super)&lt;/code&gt; 把变量可以访问的范围控制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;vfat&lt;/code&gt; 中，然后直接读，只有少数需要特殊处理的进行了函数的封装）。首先当然是研究了半天 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的结构，拿了不同来源的 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 结构说明进行对比和验证，最后终于把格式搞清楚了，先实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;MasterBootRecord&lt;/code&gt; ，这个其实很好实现，以前也有接触过 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; ，本身也很简单。然后就是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 找到第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的分区，根据偏移找到分区的开头，开头的第一个扇区就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 数据结构，里面保存了 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 分区的各种信息。根据里面的信息，可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表的位置和数量，还有数据部分的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 的位置和数量。接着，解析一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表，实际上是一个与 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 一一对应的链表结构，用特殊的数据代表链表的尾和空、坏扇区。利用这些，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 中根目录所在的第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; ，先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;VFat&lt;/code&gt; 里面实现了读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 链的内容的函数，利用这个函数读取一个一个的目录项，解析目录项，把长文件名的项合并到一个之中，然后对应地丢到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt; 对象中，目录则可以枚举子目录项，根据名字比较去找子目录或者子文件夹，文件则实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Read&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Seek&lt;/code&gt; 使得可以读取文件的内容。实现好了这些以后，就拿了 &lt;code class=&quot;highlighter-rouge&quot;&gt;raspbian-strech-lite.img&lt;/code&gt; 作为硬盘映像，从文件里读取文件信息，成功地把 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.txt&lt;/code&gt; 读取出来。&lt;/p&gt;

&lt;p&gt;其中还是遇到许多困难，如各种偏移的计算，如何处理跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 和跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sector&lt;/code&gt; 的读写，等等，有不少的坑在其中，花了两天的空余时间才差不多完善了这个功能。还有就是利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 现有的功能完成 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 里面很轻易就可以实现的指针操作，也花了不少时间。&lt;/p&gt;

&lt;p&gt;更新：&lt;a href=&quot;/programming/2018/03/03/thoughts-on-stanford-cs140e-5/&quot;&gt;下一篇在这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（3）</title>
   <link href="https://jiege.ch/programming/2018/02/16/thoughts-on-stanford-cs140e-3/"/>
   <updated>2018-02-16T20:09:00+08:00</updated>
   <id>https://jiege.ch/programming/2018/02/16/thoughts-on-stanford-cs140e-3</id>
   <content type="html">&lt;p&gt;由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2: File System &lt;/code&gt; 延期发布，所以中间那段时间转向 &lt;code class=&quot;highlighter-rouge&quot;&gt;MIT 6.828&lt;/code&gt; 稍微研究了一下。前几天放出了新的任务，在&lt;a href=&quot;/programming/2018/02/06/thoughts-on-stanford-cs140e-2/&quot;&gt;上一篇文章&lt;/a&gt;之后，我又有了一些进展： 实现了从内存中读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;ATAGS(ARM Tags)&lt;/code&gt; 信息的代码，从而可以获得内存大小的信息，根据这个信息，实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;bump&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 两种内存分配器，并且把二者之一注册为全局内存分配器，利用上更新了的 &lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; 就可以使用需要动态分配内存的相关工具了。利用这个，我实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 输入历史的回溯，把输入历史保存在一个动态增长的数组中，再特殊处理上下键，把当前的行替换为历史。&lt;/p&gt;

&lt;p&gt;这个过程也不是没有踩坑。一开始代码放出来了，但是题目说明还没出，我就自己按照代码做了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ATAGS&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bump&lt;/code&gt; 分配器，后来做完了，看到说明出了以后，发现理解还是有偏差，把代码更改了并修复了分配器的 BUG 。看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 分配器的时候，我按照网上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;buddy memory allocation&lt;/code&gt; 实现了一个内存分配器，原理看起来简单实现起来还是有很多细节问题，后来按照新放出的单元测试，修修补补才写得差不多可用了。同时，原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 因为用了新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; 而缺失了 &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt; 不能编译，我就把 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 下的相关文件软连接过去，调了数次后把问题解决。此时， &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 文件大小已经有 40K ，按照 115200 Baudrate 发送需要几秒才能传输过去，我就调到了 230400 Baudrate ，果然现在的传输速度就有所提升，可以接受了。等之后写了 &lt;code class=&quot;highlighter-rouge&quot;&gt;EMMC(SD card)&lt;/code&gt; 的驱动和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的文件系统后，就可以实现更多的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 的功能了。中间还遇到一个问题，就是如果给 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 开启了 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 分配器，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt; 回到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 就无法传新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 上去了，结果发现是因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 中用到的侵入式 &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt; 实现覆盖了部分 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 的代码，换回不能回收内存的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bump&lt;/code&gt; 分配器即可，反正目前远远还用不了那么多内存。&lt;/p&gt;

&lt;p&gt;之后还要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;aarch64&lt;/code&gt; 上用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MMU&lt;/code&gt; 实现虚拟内存，之前在 &lt;code class=&quot;highlighter-rouge&quot;&gt;MIT 6.828&lt;/code&gt; 里被页表整得脑子眩晕，希望到时我还活着吧（逃&lt;/p&gt;

&lt;p&gt;更新：&lt;a href=&quot;/programming/2018/02/27/thoughts-on-stanford-cs140e-4/&quot;&gt;下一篇在这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（2）</title>
   <link href="https://jiege.ch/programming/2018/02/06/thoughts-on-stanford-cs140e-2/"/>
   <updated>2018-02-06T12:52:59+08:00</updated>
   <id>https://jiege.ch/programming/2018/02/06/thoughts-on-stanford-cs140e-2</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/04/thoughts-on-stanford-cs140e/&quot;&gt;上一篇文章&lt;/a&gt;之后，我又有了一些进展：&lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，简易的&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，修复了之前写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmodem&lt;/code&gt; 中的 BUG，一个可以从 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 接收一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 写入到内存中再跳转过去的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;首先是 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，就是通过两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO pin&lt;/code&gt; 进行数据传输，首先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;memory mapped IO&lt;/code&gt; 上进行相应的初始化，然后包装了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Read&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Write&lt;/code&gt; （这里实现一开始有 BUG，后来修复了），然后很快地完成了一个仅仅能 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;然后实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONSOLE&lt;/code&gt; ，一个对 &lt;code class=&quot;highlighter-rouge&quot;&gt;MiniUart&lt;/code&gt; 和单例封装，就可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;kprint!/kprintln!&lt;/code&gt; 宏来输出到 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，接着实现了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，读入一行输出一行。然后实现退格键和方向键，这里的难点在于要控制光标并且用读入的或者空格覆盖掉屏幕上已经显示而不应该显示的内容。接着，利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;skeleton&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Command&lt;/code&gt; 做了一个简单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;接着，利用之前编写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; ，配合上新编写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; ，实现通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 把新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;XMODEM&lt;/code&gt; 协议发送到设备，写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80000&lt;/code&gt; 启动地址并且调转到新加载的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 中执行。&lt;/p&gt;

&lt;p&gt;最后，又实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt; （输出设备启动到现在的时间）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt; （跳转回 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; ，可以上传新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; ）。并添加了 &lt;code class=&quot;highlighter-rouge&quot;&gt;TUNA&lt;/code&gt; 作为 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 启动时输出的 &lt;code class=&quot;highlighter-rouge&quot;&gt;BANNER&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;整个过程挺虐的，踩了很多的坑，由于很多东西都没有，输入输出目前也只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，写了 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 后又遇到 &lt;code class=&quot;highlighter-rouge&quot;&gt;XMODEM&lt;/code&gt; 难以调试的问题。十分感谢 &lt;code class=&quot;highlighter-rouge&quot;&gt;#tuna&lt;/code&gt; 上的 @BenYip 及时地指出了代码的几处问题，节省了我许多时间。&lt;/p&gt;

&lt;p&gt;更新：&lt;a href=&quot;/programming/2018/02/16/thoughts-on-stanford-cs140e-3/&quot;&gt;下一篇在这里&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考</title>
   <link href="https://jiege.ch/programming/2018/02/04/thoughts-on-stanford-cs140e/"/>
   <updated>2018-02-04T22:28:23+08:00</updated>
   <id>https://jiege.ch/programming/2018/02/04/thoughts-on-stanford-cs140e</id>
   <content type="html">&lt;p&gt;最近，受各路安利，剁手买下了 &lt;a href=&quot;https://item.taobao.com/item.htm?id=537501616420&quot;&gt;这个淘宝商家的树莓派的套餐C&lt;/a&gt; ，还买了许多 LED 灯泡、杜邦线和电阻，开始按照 &lt;a href=&quot;http://web.stanford.edu/class/cs140e/&quot;&gt;CS 140e&lt;/a&gt; 学习 Rust 并且用 Rust 编译写一个简易的操作系统。Assignment 0 的目标就是编写一个向 GPIO 16 连接的 LED 灯闪烁。首先当然就是愉快地按照教程下载 bootloader ，下载交叉编译工具链，顺带装一个 Raspbian 到机器上，随时可以当成一个低性能的 ARM/ARM64 （实际上，Raspbian 只用了armv7l，没有用 64bit）机器来用，以后如果配上 &lt;a href=&quot;https://scateu.me&quot;&gt;@scateu&lt;/a&gt; 团购的 Motorola Laptop Dock 的话就是一个几百块的笔记本了。把课程上的文件丢上去，可以看到绿色的活动指示灯闪烁，后面又把 CP2102 模块连上去，又能看到 Blink on, Blink off 的输出。然后按照要求，自己先码一段 C 语言，实现 blinky:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define GPIO_BASE (0x3F000000 + 0x200000)
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spin_sleep_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nop&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;spin_sleep_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// STEP 1: Set GPIO Pin 16 as output.
&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// STEP 2: Continuously set and clear GPIO 16.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中大部分代码都已经给出了，自己要实现也只是查询一下 BCM2837 SoC 的 GPIO 文档，按照文档把该做的内存操作和位运算都写一下即可。最后发现，闪烁的频率特别慢，几秒钟才闪烁一次。毕竟是按照 CPU 的 clock speed 进行粗略的计时，而生成的代码也不是很高效，没有 inline。接着则是用 Rust 再实现一下上面这部分的代码：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compiler_builtins_lib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang_items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pointer_methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no_builtins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no_std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compiler_builtins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang_items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x3F000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x200000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x04&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x1C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[inline(never)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;asm!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nop&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;::::&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;volatile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kmain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// STEP 1: Set GPIO Pin 16 as output.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write_volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// STEP 2: Continuously set and clear GPIO 16.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write_volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write_volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边和上面一样，很多东西都已经给出了，只是重新改写一下而已。不过，这边的实测结果则是，一秒钟会闪烁很多下，看了下汇编，生成的循环比较紧凑，所以也没有达到想要的效果，不过后面到我实现了 Timer 的读取之后，就很精准了。&lt;/p&gt;

&lt;p&gt;接下来就是痛苦的学习 Rust 的过程，Assignment 1 上来就是解答关于 Rust 语言的一些问题，在过程中被 Rust 十分严格的 Lifetime 和 Borrow checker 弄得想死，好歹最后还是让测试都通过了。接下来就是真正地提供一些封装硬件接口的 API，然后利用这些 API 去实现更多功能，首先是利用栈上分配的空间模拟一个变长数组的 API：&lt;code class=&quot;highlighter-rouge&quot;&gt;stack-vec&lt;/code&gt; ，然后是把底层的直接操作硬件的内存操作封装成类型安全的 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; ，然后实现一个简单的支持断点续传的传文件的协议 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmodem&lt;/code&gt; ，又做了一个辅助电脑上使用 TTY+XMODEM 的小工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;ttywrite&lt;/code&gt; ，然后就开始撸硬件了：时钟 &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; ，针对 GPIO pin 的类型安全的状态机 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; 。目前只实现到这里，然后做出了一个准确一秒闪烁的 blinky （令人惊讶的是，因为这里的 kernel 直接从文件头开始就是代码，最后的 binary 异常地小，而之前的代码从文件的偏移 0x8000 开始。目前看来，是因为之前的代码是整个文件加载到 0x0000 上，而代码默认了从  0x8000 开始，所以除了最开头的一个跳转指令，中间留了许多空余的空间。而这里的代码是直接被 bootloader 加载到了 0x80000 处并且跳转到这里执行，所以省去了许多空间）：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;blinky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Gpio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin_out16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin16&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.into_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pin_out16&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pin_out16&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kmain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// FIXME: Start the shell.&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;blinky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;目前只做到这里。后面还有大把的坑要踩，难写的 Rust 还得继续啃下去。我的代码都以 diff 的形式放在了 &lt;a href=&quot;https://github.com/jiegec/cs140e&quot;&gt;jiegec/cs140e&lt;/a&gt; ，写得并不美观。接下来就是实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 了，终于要实现串口通信了。&lt;/p&gt;

&lt;p&gt;2018-01-06 更新： &lt;a href=&quot;/programming/2018/02/06/thoughts-on-stanford-cs140e-2/&quot;&gt;下一篇文章已经更新&lt;/a&gt; 。&lt;/p&gt;
</content>
 </entry>
 
</feed>
