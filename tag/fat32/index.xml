<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - FAT32</title>
 <link href="https://jiegec.github.io/tag/fat32/index.xml" rel="self"/>
 <link href="https://jiegec.github.io/tag/FAT32.html"/>
 <updated>2018-04-28T22:51:17+08:00</updated>
 <id>https://jiegec.github.io/tag/FAT32.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（6）</title>
   <link href="https://jiegec.github.io/programming/2018/03/05/thoughts-on-stanford-cs140e-6/"/>
   <updated>2018-03-05T19:55:49+08:00</updated>
   <id>https://jiegec.github.io/programming/2018/03/05/thoughts-on-stanford-cs140e-6</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/03/thoughts-on-stanford-cs140e-5/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者终于更新了测试的用例，我的程序终于可以成功跑过所有测试，也成功在树莓派跑起来。不过，我的代码中很多地方的错误处理比较偷懒，往往直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; ，显然并不友好。同时，我想到了使用 &lt;a href=&quot;https://github.com/rust-fuzz/cargo-fuzz&quot;&gt;cargo-fuzz&lt;/a&gt; 来进行自动化测试，果然，使用这个很快就修复了不少我没想到的会出错的地方，比如乘法溢出，目录项没有正确结束等等。目前还发现一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 的问题，研究发现大概是文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cluster chain&lt;/code&gt; 中出现了环，导致一直读取文件而没有停止。要解决这个问题，我目前想到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Floyd&lt;/code&gt; 的判圈算法，但还没上实现。等过几天，新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 3&lt;/code&gt; 出了以后，再继续更新。希望作者少点跳票，多点勤奋，哈哈哈哈哈&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（5）</title>
   <link href="https://jiegec.github.io/programming/2018/03/03/thoughts-on-stanford-cs140e-5/"/>
   <updated>2018-03-03T11:07:30+08:00</updated>
   <id>https://jiegec.github.io/programming/2018/03/03/thoughts-on-stanford-cs140e-5</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/27/thoughts-on-stanford-cs140e-4/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后（again），终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 3: Saddle Up&lt;/code&gt; 。这次，我们要做的变成了把已经写好的（错漏百出）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 的驱动搬到树莓派里面去，然后实现一些基本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 等等。作者首先更新了老版本的新的测试样例，放了一些映像然后提供了预期的结果，结果发现，这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 有一些不同，主要的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes_per_sector&lt;/code&gt; 不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt; 了，意味着物理的扇区和逻辑扇区并不一致。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;sectors_per_cluster&lt;/code&gt; 也不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 了，需要考虑多个扇区的情况。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;read_cluster&lt;/code&gt; 传入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;offset&lt;/code&gt; 也可能不再是第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sector&lt;/code&gt; 中的，所以需要做一个处理。对于物理和逻辑扇区的问题，作者推荐的方案是，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 之外的扇区保持不变，把其内的扇区视为逻辑扇区。这样，其它代码都可以透明地工作，而不用到处更改，这就体现了封装的威力。接着，作者提供了一个写好了的 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsd&lt;/code&gt; 和一些导出的函数，使用这些函数即可。不过，在错误处理和 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 上也遇到了一些坑。后面，把东西搬到树莓派上运行，问题就出现了：读取了第一个扇区（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 所在的扇区）之后，直接就死掉了。想了半天都没找到方案，突然想起可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic!&lt;/code&gt; 对错误语句进行二分查找。查找了大概有七八个小时之后，终于发现，问题出现在读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 类型的变量上。我起初怀疑是栈出了问题，所以放到堆上分配，然而还是不行。忽然想起以前遇到的对齐问题，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AArch64&lt;/code&gt; 架构上，可能为了简化，读取的 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 必须对齐到四个字节上。于是找了找 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中的对齐方面的文档，找到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(align=4)]&lt;/code&gt; 这种表示方法，代替了原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(packed)]&lt;/code&gt; ，并且把数据先拷贝到对齐后的栈上的对应数据结构，然后再读取对应的项。果然，这个问题就解决了。然后又发现我的盘中会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;lfn&lt;/code&gt; 项并不是从后往前的情况，于是我又修改了一下相关的代码。现在，终于可以成功地 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;不过还是要吐槽一下，作者的测试用的映像文件中，会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xE5&lt;/code&gt; 表示这个项已经被删除的情况，但是似乎作者的代码并没有处理这个，所以在预期的输出中出现了一些明显不正确的结果，导致我的代码跑测试并不能通过。而且，作者的代码在一些情况下会把文件的后缀漏掉。作者后来更新了几次测试的文件，不过这个问题只解决了一部分，并没有完全解决。坐等作者继续放出新的测试文件吧。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>近来做 Stanford CS140e 的一些进展和思考（4）</title>
   <link href="https://jiegec.github.io/programming/2018/02/27/thoughts-on-stanford-cs140e-4/"/>
   <updated>2018-02-27T22:42:59+08:00</updated>
   <id>https://jiegec.github.io/programming/2018/02/27/thoughts-on-stanford-cs140e-4</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/16/thoughts-on-stanford-cs140e-3/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后，终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 2:32-bit Lipids&lt;/code&gt; ，这两天就把只读 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 写完了（不过封装得并不好，许多地方利用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;pub(super)&lt;/code&gt; 把变量可以访问的范围控制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;vfat&lt;/code&gt; 中，然后直接读，只有少数需要特殊处理的进行了函数的封装）。首先当然是研究了半天 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的结构，拿了不同来源的 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 结构说明进行对比和验证，最后终于把格式搞清楚了，先实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;MasterBootRecord&lt;/code&gt; ，这个其实很好实现，以前也有接触过 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; ，本身也很简单。然后就是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 找到第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的分区，根据偏移找到分区的开头，开头的第一个扇区就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 数据结构，里面保存了 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 分区的各种信息。根据里面的信息，可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表的位置和数量，还有数据部分的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 的位置和数量。接着，解析一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表，实际上是一个与 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 一一对应的链表结构，用特殊的数据代表链表的尾和空、坏扇区。利用这些，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 中根目录所在的第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; ，先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;VFat&lt;/code&gt; 里面实现了读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 链的内容的函数，利用这个函数读取一个一个的目录项，解析目录项，把长文件名的项合并到一个之中，然后对应地丢到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt; 对象中，目录则可以枚举子目录项，根据名字比较去找子目录或者子文件夹，文件则实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Read&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Seek&lt;/code&gt; 使得可以读取文件的内容。实现好了这些以后，就拿了 &lt;code class=&quot;highlighter-rouge&quot;&gt;raspbian-strech-lite.img&lt;/code&gt; 作为硬盘映像，从文件里读取文件信息，成功地把 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.txt&lt;/code&gt; 读取出来。&lt;/p&gt;

&lt;p&gt;其中还是遇到许多困难，如各种偏移的计算，如何处理跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 和跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sector&lt;/code&gt; 的读写，等等，有不少的坑在其中，花了两天的空余时间才差不多完善了这个功能。还有就是利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 现有的功能完成 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 里面很轻易就可以实现的指针操作，也花了不少时间。&lt;/p&gt;
</content>
 </entry>
 
</feed>
