<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - cpu</title>
 <link href="https://jiegec.me/tag/cpu/index.xml" rel="self"/>
 <link href="https://jiegec.me/tag/cpu.html"/>
 <updated>2018-10-07T22:32:08+08:00</updated>
 <id>https://jiegec.me/tag/cpu.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>Verilog 初体验</title>
   <link href="https://jiegec.me/programming/2018/06/21/verilog-first-try/"/>
   <updated>2018-06-21T21:36:00+08:00</updated>
   <id>https://jiegec.me/programming/2018/06/21/verilog-first-try</id>
   <content type="html">自己以前一直对硬件方面没有接触，但是大二大三很快就要接触相关知识，所以自己就先预习一下 Verilog HDL，以便以后造计算机。听学长们推荐了一本书叫《自己动手写CPU》，由于自己手中只有很老的 Spartan-3 板子，手上没有可以用来试验的 FPGA ，所以选择用 Verilog + Verilator 进行模拟。既然是模拟，自然是会有一定的问题，不过这个以后再说。

然后就是模仿着这本书的例子，写了指令的获取和指令的解码两部分很少很少的代码，只能解码 ori (or with immidiate) 这一个指令。然后，通过 verilator 跑模拟，输出 vcd 文件，再用 gtkwave 显示波形，终于能够看到我想要的结果了。能够看到，前一个时钟周期获取指令，下一个时钟周期进行解码，出现了流水线的结果。这让我十分开心。

接下来就是实现一些基本的算术指令，然后讲计算的结果写入到相应的寄存器中。这样做完之后，就可以做一个基于 verilator 的简易 A+B 程序了。

我的代码发布在[jiegec/learn_verilog](https://github.com/jiegec/learn_verilog)中。最近马上到考试周，可能到暑假会更频繁地更新吧。
</content>
 </entry>
 
 <entry>
   <title>用CPUID获取评测机器的CPU</title>
   <link href="https://jiegec.me/oi/2017/10/30/use-cpuid-to-get-machine-cpu/"/>
   <updated>2017-10-30T21:07:23+08:00</updated>
   <id>https://jiegec.me/oi/2017/10/30/use-cpuid-to-get-machine-cpu</id>
   <content type="html">受[用 CPUID 检测各大 OJ 测评机所用的 CPU（以及日常黑 BZOJ）](https://zhuanlan.zhihu.com/p/28322626)的启发，我决定去测试一下徐老师自己写的OJ（名为Tyche）所跑的机器是什么CPU。于是我改造一下代码，用以下代码测评：

```cpp
#include &lt;stdint.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;cpuid.h&gt;
#include &lt;sys/time.h&gt;
static void cpuid(uint32_t func, uint32_t sub, uint32_t data[4]) {
    __cpuid_count(func, sub, data[0], data[1], data[2], data[3]);
}
int main() {
    uint32_t data[4];
    char str[48];
    for(int i = 0; i &lt; 3; ++i) {
        cpuid(0x80000002 + i, 0, data);
        for(int j = 0; j &lt; 4; ++j)
            reinterpret_cast&lt;uint32_t*&gt;(str)[i * 4 + j] = data[j];
    }

    struct timeval stop, start;
    gettimeofday(&amp;start, NULL);
    while(1) {
        gettimeofday(&amp;stop, NULL);
        if(stop.tv_usec - start.tv_usec &gt; (str[##EDITME##] - 32) * 10000)
            break;
    }
}
```

经过测试，```usleep()```和```clock()```都被封杀，但是```gettimeofday()```存活了下来。然后我就不断地```C-a```上面的```###EDITME###```，根据评测出来的时间推算出字符串，然后得到以下结果：

```
0 ~ 7 : PADDING
8 73 I
9 110 n
10 116 t
11 101 e
12 108 l
13 40 (
14 82 R
15 41 )
16 32 SPC
17 67 C
18 111 o
19 114 r
20 101 e
21 40 (
22 84 T
23 77 M
24 41 )
25 32 SPC
26 105 i
27 51 3
28 45 -
29 50 2
30 49 1
31 50 2
32 48 0
33 32 SPC
34 67 C
35 80 P
36 85 U
37 32 SPC
38 64 @
39 32 SPC
40 51 3
41 46 .
42 51 3
43 48 0
44 71 G
45 72 H
46 122 z
```

连起来就是[这个CPU](https://ark.intel.com/zh-cn/products/53426/Intel-Core-i3-2120-Processor-3M-Cache-3_30-GHz)：

```
Intel(R) Core(TM) i3-2120 CPU @ 3.30GHz
```

相比之下，还是比BZOJ好哈哈哈（又黑BZOJ）。后来有大神在群里建议，可以用字符串比较的方式，对了就让题目AC，不对就WA。这个方法更加适合手里已经知道了一些常见CPUID的返回字符串，这里就是这样。
</content>
 </entry>
 
</feed>
