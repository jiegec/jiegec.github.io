<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <title>Tag - c++</title>
 <link href="https://jiegec.me/tag/c++/index.xml" rel="self"/>
 <link href="https://jiegec.me/tag/c++.html"/>
 <updated>2018-10-07T22:32:08+08:00</updated>
 <id>https://jiegec.me/tag/c++.html</id>
 <author>
   <name>Jiege Chen</name>
 </author>
 
 <entry>
   <title>〖新手向〗绕过 C++ 类的访问限制</title>
   <link href="https://jiegec.me/programming/2018/03/07/breaking-C++-weak-access-control/"/>
   <updated>2018-03-07T07:59:20+08:00</updated>
   <id>https://jiegec.me/programming/2018/03/07/breaking-C++-weak-access-control</id>
   <content type="html">这是一篇很水的文章，面向萌新，已经知道了的可以自觉绕道。

昨天上课，有同学问，如果用户偷偷把 `private` 改成 `public` 再和原有的库链接，是不是就可以在用户代码里更改了。这个答案是肯定的。下面我们就做个实验：

首先，创建 good_class.h 和 good_class.cpp:

```c++
class SomeClass {
private:
    int data;
public:
    int getData();
};
```

```c++
#include &quot;good_class.h&quot;

int SomeClass::getData() {
    return data;
}
```

然后，首先编译，

```shell
clang++ -c good_class.cpp -o good_class.o
```

然后，修改 good_class.cpp 并写一个 evil_user.cpp

```c++
class SomeClass {
public:
    int data;
public:
    int getData();
};
```

```c++
#include &lt;stdio.h&gt;
#include &quot;good_class.h&quot;

int main() {
    SomeClass a;
    a.data = 37;
    printf(&quot;%d\n&quot;, a.getData());
    return 0;
}
```

编译：

```shell
clang++ good_class.o evil_user.cpp -o evil
```

然后 `evil` 如愿地输出了 `37` 。

一些提醒：

1. `C++` 的访问控制十分的弱，仅仅是编译期。所以是很容易绕过的。
2. 对于不想泄露源代码的库，不要导出 `C++` 的类和函数。选择导出 `C` 函数，结构体用 incomplete type 或者干脆 `void *` 。

扩展阅读： [L叔的通过虚函数表访问私有函数](https://liam0205.me/2018/01/23/crack-private-member-function-by-vtable/) 。
</content>
 </entry>
 
 <entry>
   <title>再次吐槽 VS 关于 scanf 和 scanf_s 的问题</title>
   <link href="https://jiegec.me/programming/2018/01/30/more-on-scanf-and-scanf_s/"/>
   <updated>2018-01-30T16:05:33+08:00</updated>
   <id>https://jiegec.me/programming/2018/01/30/more-on-scanf-and-scanf_s</id>
   <content type="html">继[上次的吐槽](https://jiegec.github.io/programming/2017/10/17/on-scanf-and-scanf_s/)后，今天再次遇到同学因为 `scanf` 在 VS 下的 `deprecation error` 感到十分迷茫，在知乎上求助又因为拍照的原因被说，我就在此再次吐槽一下 VS 这对初学者很不友善很不友善的两点。

一点就是上面提到的这个，另一点就是程序结束后任意键以退出这一功能要做得更加醒目一点 。前者由于大多数新手在学习 `C/C++` 的时候都会跟着书上或者网上的代码敲一遍输入输出的代码，很容易就会撞到这个问题。后者则会让新手习惯性地以为程序闪退了，没有出结果，而不知道其实是程序执行结束后关闭而已。
</content>
 </entry>
 
 <entry>
   <title>Run Cpp In Jupyter Notebook</title>
   <link href="https://jiegec.me/programming/2017/11/30/run-cpp-in-jupyter-notebook/"/>
   <updated>2017-11-30T18:07:10+08:00</updated>
   <id>https://jiegec.me/programming/2017/11/30/run-cpp-in-jupyter-notebook</id>
   <content type="html">刚刚在HN上看到了这么一个文章：[Interactive Workflows for C++ with Jupyter](https://blog.jupyter.org/interactive-workflows-for-c-with-jupyter-fe9b54227d92) [HN](https://news.ycombinator.com/item?id=15808809) ，终于可以在Jupyter Notebook里跑C++代码了，很开心，于是开始自己研究了起来怎么本地跑。

首先当然是更新一波jupyter，安装一波cling：

```shell
pip3 install -U jupyter
brew install cling
```

然后根据[官方教程](https://github.com/root-project/cling/tree/master/tools/Jupyter)里的要求执行：

```shell
cd /usr/local/share/cling/Jupyter/kernel
pip3 install -e .
jupyter kernelspec install cling-cpp11
jupyter kernelspec install cling-cpp14
jupyter kernelspec install cling-cpp17
jupyter kernelspec install cling-cpp1z
```

结果发现找不到`jupyter-kernelspec`，遂重装了一下`jupyter-client`这个包，果然就可以了。打开一个notebook测试：

```
jupyter notebook
```

然后创建一个C++14的Notebook，结果发现一直Kernel rebooting，错误信息是说找不到`../Cellar/cling/0.5/lib/libclingJupyter.dylib`。这一看就是路径处理的问题，当前目录肯定不是`/usr/local`，肯定出现了什么问题，然后研究发现`cling-kernel.py`中对`cling`判断是否是个连接，如果是连接则按照连接去找`cling`的安装目录，但是！没有考虑到这个连接是个相对路径的问题（Homebrew你背锅吗）。于是我愉快地改了代码并提交了[PR](https://github.com/root-project/cling/pull/198)。修复了以后就可以用了。

以下是一个小小的例子：
```shell
&gt;&gt; jupyter console --kernel cling-cpp14
Jupyter console 5.2.0

cling-X


In [1]: #include &lt;stdio.h&gt;
Out[1]:

In [2]: char *s = &quot;Hello, world!&quot;;
input_line_4:2:12: warning: ISO C++11 does not allow conversion from string literal to 'char *' [-Wwritable-strings]
 char *s = &quot;Hello, world!&quot;;
           ^
Out[2]:

In [3]: printf(&quot;%s&quot;,s);
Hello, world!Out[3]:
(int) 13

```

Okay，大功告成！
</content>
 </entry>
 
 <entry>
   <title>关于scanf和scanf_s的问题</title>
   <link href="https://jiegec.me/programming/2017/10/17/on-scanf-and-scanf_s/"/>
   <updated>2017-10-17T16:46:40+08:00</updated>
   <id>https://jiegec.me/programming/2017/10/17/on-scanf-and-scanf_s</id>
   <content type="html">最近作为程设基础的小教员，收到很多同学的求助，关于`scanf`和`scanf_s`的问题已经遇到了两次，特此写一篇博文来叙述一下这个问题。

一开始，有同学问我，
```
char a;
scanf(&quot;%c&quot;,&amp;a);
```
为什么会报错？我说，vs默认强制要求使用scanf_s函数，于是我建议这位同学把这个错误信息关掉了。嗯。经过百度，这位同学的问题解决了。

后来，又有一位同学问我，
```
char a;
scanf_s(&quot;%c&quot;,&amp;a);
```
程序为什么会崩溃？我想了想，如果scanf_s和scanf是一样的行为，这段代码是没问题的。但scanf_s既然安全，必然是在字符串方面做了处理。这里的char*勉强也算一个？网上一查，果然，应该写成`scanf_s(&quot;%c&quot;,&amp;a,1);`，字符串则要写成`scanf_s(&quot;%s&quot;,str,sizeof(str))`，来保证缓冲区不会溢出。

但是，这样解决这个问题又面临着不同的选择：

1. 学习`scanf_s`和`scanf`的不同，把所有`scanf`换成`scanf_s`并做相应的修改。
   这样当然符合了语言进化的潮流，也会让vs闭嘴。但是，scanf_s只有在C11标准中有，而且，根据[cpprefrence.com上关于scanf的描述](http://en.cppreference.com/w/c/io/fscanf)，只有在`__STDC_LIB_EXT1__`被定义且在`#include&lt;stdio.h&gt;`之前`#define __STDC_WANT_LIB_EXT1__`才能确保使用`scanf_s`能使用，当然在vs较新版本中是默认可以使用的。但是，程设基础的作业是要丢到oj上的，而oj上的编译器不一定支持这些，所以这个选项不行。
2. 坚持用`scanf`，自己按照题目要求保证缓冲区不溢出，同时让vs闭嘴。
   网上已有[教程](https://www.cnblogs.com/wangduo/p/5554465.html)，已经讲的很全面了，大家可以根据这个教程把vs教训一顿。为了能在oj里跑，建议用里面的方法五到八。（个人最推荐在文件头添加`#define _CRT_SECURE_NO_WARNINGS`）

以后再遇到这个问题，我就丢这个连接上来就好了咯。yeah！
</content>
 </entry>
 
</feed>
