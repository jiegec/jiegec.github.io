<!DOCTYPE html>
<html>
<head>
    <title>杰哥的{运维,编程,调板子}小笔记</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="杰哥的{运维,编程,调板子}小笔记" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://jia.je/" />
    
<link href="/feed.xml" rel="alternate" type="application/rss+xml" title="杰哥的{运维,编程,调板子}小笔记" />
    <link rel="shortcut icon" href="/favicon.ico">

    <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/style.css">
    
    <script src="/js/wavedrom/default.js" type="text/javascript"></script>
    <script src="/js/wavedrom/wavedrom.min.js" type="text/javascript" /></script>

    <meta name="generator" content="Hugo 0.113.0">
</head>

<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="/">杰哥的{运维,编程,调板子}小笔记</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">关于</a>
                
                <a class="main-nav-link" href="/category/">分类</a>
                
                <a class="main-nav-link" href="/open-source-contributions/">开源</a>
                
                <a class="main-nav-link" href="/tags/">标签</a>
                
                <a class="main-nav-link" href="/kb/">知识库</a>
                
                <a class="main-nav-link" href="/series/">系列</a>
                
                <a class="main-nav-link" href="/feed.xml">订阅</a>
                
                <a class="main-nav-link" href="/projects/readme/">项目</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/05/09/tilelink/">TileLink 总线协议分析</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/05/09/tilelink/" class="article-date">
                        <time datetime='2022-05-09T16:15:00.000&#43;08:00' itemprop="datePublished">2022-05-09</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/05/09/tilelink/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    本文的内容已经整合到知识库中。
背景 最近在研究一些支持缓存一致性的缓存的实现，比如 rocket-chip 的实现和 sifive 的实现，因此需要研究一些 TileLink 协议。本文讨论的时候默认读者具有一定的 AXI 知识，因此很多内容会直接参考 AXI。
信号 根据 TileLink Spec 1.8.0，TileLink 分为以下三种：
TL-UL: 只支持读写，不支持 burst，类比 AXI-Lite TL-UH：支持读写，原子指令，预取，支持 burst，类比 AXI+ATOP（AXI5 引入的原子操作） TL-C：在 TL-UH 基础上支持缓存一致性协议，类比 AXI+ACE/CHI TileLink Uncached TileLink Uncached(TL-UL 和 TL-UH) 包括了两个 channel：
A channel: M-&gt;S 发送请求，类比 AXI 的 AR/AW/W D channel: S-&gt;M 发送响应，类比 AXI 的 R/W 因此 TileLink 每个周期只能发送读或者写的请求，而 AXI 可以同时在 AR 和 AW channel 上发送请求。
一些请求的例子：
读：M-&gt;S 在 A channel 上发送 Get，S-&gt;M 在 D channel 上发送 AccessAckData 写：M-&gt;S 在 A channel 上发送 PutFullData/PutPartialData，S-&gt;M 在 D channel 是发送 AccessAck 原子操作：M-&gt;S 在 A channel 上发送 ArithmeticData/LogicalData，S-&gt;M 在 D channel 上发送 AccessAckData 预取操作：M-&gt;S 在 A channel 上发送 Intent，S-&gt;M 在 D channel 上发送 AccessAck AXI4ToTL 针对 AXI4ToTL 模块的例子，来分析一下如何把一个 AXI4 Master 转换为 TileLink。
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/05/09/tilelink/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/tilelink">tilelink
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/bus">bus
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cache">cache
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/coherence">coherence
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/system/2022/05/05/nuc11-igpu-passthrough/">NUC11 ESXi 中 iGPU 直通虚拟机</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/system/2022/05/05/nuc11-igpu-passthrough/" class="article-date">
                        <time datetime='2022-05-05T10:24:00.000&#43;08:00' itemprop="datePublished">2022-05-05</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/system/2022/05/05/nuc11-igpu-passthrough/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 之前在 NUC11PAKi5 上装了 ESXI 加几个虚拟机系统，但是自带的 iGPU Intel Iris Xe Graphics(Tiger Lake GT-2) 没用上，感觉有些浪费。因此想要给 Windows 直通。在直通到 Windows 后发现会无限重启，最后直通到 Linux 中。
步骤 第一步是到 esxi 的设备设置的地方，把 iGPU 的 Passthrough 打开，这时候会提示需要重启，但是如果重启，会发现还是处于 Needs reboot 状态。网上进行搜索，发现是 ESXi 自己占用了 iGPU 的输出，解决方法如下：
$ esxcli system settings kernel set -s vga -v FALSE 这样设置以后就不会在显卡输出上显示 dcui 了，这是一个比较大的缺点，但是平时也不用自带的显示输出，就无所谓了。
第二步，重启以后，这时候看设备状态就是 Active。回到 Windows 虚拟机，添加 PCI device，然后启动。这时候，我遇到了这样的错误：
Module ‘DevicePowerOn’ power on failed Failed to register the device pciPassthru0 搜索了一番，解决方法是关掉 IOMMU。在虚拟机设计中关掉 IOMMU，就可以正常启动了。
第三步，进入 Windows，这时候就可以看到有一个新的未知设备了，VID=8086，PID=9a49；等待一段时间，Windows 自动安装好了驱动，就可以正常识别了。GPU-Z 中可以看到效果如下：
                    </p>
                    <p class="article-more-link">
                        <a href="/system/2022/05/05/nuc11-igpu-passthrough/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/windows">windows
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/win11">win11
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/esxi">esxi
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/vmware">vmware
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gpu">gpu
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/igpu">igpu
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/passthrough">passthrough
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2022/05/02/loongarch64-toolchain/">LoongArch64 工具链构建</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2022/05/02/loongarch64-toolchain/" class="article-date">
                        <time datetime='2022-05-02T20:35:00.000&#43;08:00' itemprop="datePublished">2022-05-02</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2022/05/02/loongarch64-toolchain/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    最近因为龙芯杯的原因，想自己搞个 LoongArch64 的交叉编译工具链试试，结果遇到了很多坑，最后终于算是搞出来了。
一开始是想搞一个 newlib 的工具链，比较简单，而且之前做过一个仓库：jiegec/riscv-toolchain，就是构建的 riscv64-unknown-elf 工具链，照着 riscv-gnu-toolchain 就可以了。不过研究发现，newlib 还不支持 loongarch，目前只有 glibc 支持，只好硬着头皮上了。
于是我就在 riscv-toolchain 的基础上搞 loongarch64-unknown-linux-gnu，也就是带 glibc 的工具链，结果发现遇到很多坑。首先编译 libgcc 的时候就找不到头文件，于是先要从 glibc 和 linux 安装头文件到 sysroot 里面，对于 sysroot 里面的头文件路径到底是 include 还是 usr/include 也折腾了半天。然后编译 libgcc 又各种出问题，最后折腾了半天，结果是 gcc stage1 和 glibc 都没问题，gcc stage2 会报链接错误，但是不管它也能用，可以编译出正常的程序，毕竟 libc 是好的。
于是转念一想，要不要试试 crosstool-ng。克隆了一份上游的版本，照着 riscv 的部分抄了一份变成了 loongarch，然后把 config 里面的 linux/glibc/gcc/binutils-gdb 都替换为 custom location，这样我就可以用上游的最新版本了。中途还遇到了 crosstool-ng 对 gcc 12/13 不兼容的 bug，还好下面有人提出了解决方法。这些都搞定以后，终于构建出了一个完整的 loongarch64-unknown-linux-gnu 工具链。仓库地址是 jiegec/ct-ng-loongarch64，需要配合添加了 LoongArch 的 jiegec/crosstool-ng loongarch 分支 使用。
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2022/05/02/loongarch64-toolchain/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/loongarch">loongarch
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/toolchain">toolchain
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gcc">gcc
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/04/19/wch-ch32v307-eval/">试用沁恒 CH32V307 评估板</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/04/19/wch-ch32v307-eval/" class="article-date">
                        <time datetime='2022-04-19T22:53:00.000&#43;08:00' itemprop="datePublished">2022-04-19</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/04/19/wch-ch32v307-eval/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 之前有一天看到朋友在捣鼓 CH32V307，因此自己也萌生了试用 CH32V307 评估板的兴趣，于是在沁恒官网申请样品，很快就接到电话了解情况，几天后就顺丰送到了，不过因为疫情原因直到现在才拿到手上，只能说疫情期间说不定货比人还快。
开箱 收到的盒子里有一个 CH32V307 评估板，和一个 WCH-Link，相关资料可以在 官网 或者 openwch/ch32v307 下载。在说明书中有如下的图示：
板子自带的跳线帽不是很多，建议自备一些，或者用杜邦线替代。比较重要的是 WCH-Link 子板上 CH549 和 CH2V307 连接的几个信号，和下面 BOOT0/1 的选择。
WCH-Link 可以看到评估板自带了一个 WCH-Link，所以不需要附赠的那一个，直接把 11 号 Type-C 连接到电脑上即可。这里还遇到一个小插曲，用 Type-C to Type-C 的线连电脑上不工作，连 PWR LED 都点不亮，换一根 Type-A to Type-C 的就可以，没有继续研究是什么原因。电脑上可以看到 WCH-Link 的设备：VID=1a86, PID=8010。比较有意思的是，在 RISC-V 模式（CON 灯不亮）的时候 PID 是 8010，ARM 模式（CON 灯亮）的时候 PID 是 8011，从 RISC-V 模式切换到 ARM 模式的方法是连接 TX 和 GND 后上电，反过来要用 MounRiver，详见 WCH-Link 使用说明 V1.0 V1.3 和原理图 V1.1。
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/04/19/wch-ch32v307-eval/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/wch">wch
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/ch32">ch32
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/ch32v307">ch32v307
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/riscv">riscv
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/eval">eval
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/04/10/vivado-program-bitstream-svf/">导出 Vivado 下载 Bitstream 的 SVF 文件</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/04/10/vivado-program-bitstream-svf/" class="article-date">
                        <time datetime='2022-04-10T09:36:00.000&#43;08:00' itemprop="datePublished">2022-04-10</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/04/10/vivado-program-bitstream-svf/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在研究如何实现一个远程 JTAG 的功能，目前实现在 jiegec/jtag-remote-server，实现了简单的 XVC 协议，底层用的是 libftdi 的 MPSSE 协议来操作 JTAG。但是，在用 Vivado 尝试的时候，SysMon 可以正常使用，但是下载 Bitstream 会失败，所以要研究一下 Vivado 都做了什么（目前已经修好，是最后一个字节的部分位读取的处理问题）。
SVF SVF 格式其实是一系列的 JTAG 上的操作。想到这个，也是因为在网上搜到了一个 dcfeb_v45.svf，里面描述的就是一段 JTAG 操作：
// Created using Xilinx Cse Software [ISE - 12.4] // Date: Mon May 09 11:00:32 2011 TRST OFF; ENDIR IDLE; ENDDR IDLE; STATE RESET; STATE IDLE; FREQUENCY 1E6 HZ; //Operation: Program -p 0 -dataWidth 16 -rs1 NONE -rs0 NONE -bpionly -e -loadfpga TIR 0 ; HIR 0 ; TDR 0 ; HDR 0 ; TIR 0 ; HIR 0 ; HDR 0 ; TDR 0 ; //Loading device with &#39;idcode&#39; instruction.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/04/10/vivado-program-bitstream-svf/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/vivado">vivado
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/svf">svf
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/jtag">jtag
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/bitstream">bitstream
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/03/31/brief-into-ooo-2/">浅谈乱序执行 CPU（二）</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/03/31/brief-into-ooo-2/" class="article-date">
                        <time datetime='2022-03-31T01:18:00.000&#43;08:00' itemprop="datePublished">2022-03-31</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/03/31/brief-into-ooo-2/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    本文的内容已经整合到知识库中。
背景 之前写过一个浅谈乱序执行 CPU，随着学习的深入，内容越来越多，页面太长，因此把后面的一部分内容独立出来，变成了这篇博客文章。之后也许会有（三）（四）等等。
内存访问 内存访问是一个比较复杂的操作，它涉及到缓存、页表、内存序等问题。在乱序执行中，要尽量优化内存访问对其他指令的延迟的影响，同时也要保证正确性。这里参考的是 BOOM 的 LSU 设计。
首先是正确性。一般来说可以认为，Load 是没有副作用的（实际上，Load 会导致 Cache 加载数据，这也引发了以 Meltdown 为首的一系列漏洞），因此可以很激进地预测执行 Load。但是，Store 是有副作用的，写出去的数据就没法还原了。因此，Store 指令只有在 ROB Head 被 Commit 的时候，才会写入到 Cache 中。
其次是性能，我们希望 Load 指令可以尽快地完成，这样可以使得后续的计算指令可以尽快地开始进行。当 Load 指令的地址已经计算好的时候，就可以去取数据，这时候，首先要去 Store Queue 里面找，如果有 Store 指令要写入的地址等于 Load 的地址，说明后面的 Load 依赖于前面的 Store，如果 Store 的数据已经准备好了，就可以直接把数据转发过来，就不需要从 Cache 中获取，如果数据还没准备好，就需要等待这一条 Store 完成；如果没有找到匹配的 Store 指令，再从内存中取。不过，有一种情况就是，当 Store 指令的地址迟迟没有计算出来，而后面的 Load 已经提前从 Cache 中获取数据了，这时候就会出现错误，所以当 Store 计算出地址的时候，需要检查后面的 Load 指令是否出现地址重合，如果出现了，就要把这条 Load 以及依赖这条 Load 指令的其余指令重新执行。POWER8 处理器微架构论文中对此也有类似的表述：
The POWER8 IFU also implements mechanisms to mitigate performance degradation associated with pipeline hazards.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/03/31/brief-into-ooo-2/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/ooo">ooo
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/cpu">cpu
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/tomasulo">tomasulo
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/outoforder">outoforder
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/renaming">renaming
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/brief-into-ooo">brief-into-ooo
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/03/30/sv2v-fpnew/">用 sv2v&#43;yosys 把 fpnew 转为 verilog 网表</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/03/30/sv2v-fpnew/" class="article-date">
                        <time datetime='2022-03-30T00:33:00.000&#43;08:00' itemprop="datePublished">2022-03-30</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/03/30/sv2v-fpnew/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 FPnew 是一个比较好用的浮点计算单元，但它是 SystemVerilog 编写的，并且用了很多高级特性，虽然闭源软件是支持的，但是开源拖拉机经常会遇到这样那样的问题。所以一直想用 sv2v 把它翻译成 Verilog，但此时的 Verilog 还有很多复杂的结构，再用 yosys 转换为一个通用可综合的网表。
步骤 经过一系列踩坑，一个很重要的点是要用最新的 sv2v(v0.0.9-24-gf868f06) 和 yosys(0.15+70)。Debian 打包的 yosys 版本比较老，不能满足需求。
首先，用 verilator 进行预处理，把一堆 sv 文件合成一个：
$ cat a.sv b.sv c.sv &gt; test.sv $ verilator -E test.sv &gt; merged.sv $ sed -i &#39;/^`line/d&#39; merged.sv 注意这里用 sed 去掉了无用的行号信息。然后，用 sv2v 进行转换：
$ sv2v merged.sv &gt; merge.v $ sed -i &#39;/\$$fatal/d&#39; merge.v 这里又用 sed 把不支持的 $fatal 去掉。最后，用 yosys 进行处理：
$ yosys -p &#39;read_verilog -defer merge.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/03/30/sv2v-fpnew/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/hdl">hdl
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/yosys">yosys
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sv2v">sv2v
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/fpnew">fpnew
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/fpu">fpu
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/03/14/design-compiler-synthesis/">Synopsys Design Compiler 综合实践</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/03/14/design-compiler-synthesis/" class="article-date">
                        <time datetime='2022-03-14T15:22:00.000&#43;08:00' itemprop="datePublished">2022-03-14</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/03/14/design-compiler-synthesis/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    工艺库 综合很重要的一步是把 HDL 的逻辑变成一个个单元，这些单元加上连接方式就成为了网表。那么，基本单元有哪些，怎么决定用哪些基本单元？
这个就需要工艺库了，工艺库定义了一个个单元，单元的引脚、功能，还有各种参数，这样 Design Compiler 就可以按照这些信息去找到一个优化的网表。
Liberty 格式 网上可以找到一些 Liberty 格式的工艺库，比如 Nangate45，它的设定是 25 摄氏度，1.10 伏，属于 TT（Typical/Typical）的 Process Corner。
在里面可以看到一些基本单元的定理，比如 AND2_X1，就是一个 drive strength 是 1 的二输入与门：
cell (AND2_X1) { drive_strength : 1; pin (A1) { direction : input; } pin (A2) { direction : input; } pin (ZN) { direction : output; function : &#34;(A1 &amp; A2)&#34;; } /* ... */ } 这样就定义了两个输入 pin，一个输出 pin，还有它实现的功能。还有很重要的一点是保存了时序信息，比如：
lu_table_template (Timing_7_7) { variable_1 : input_net_transition; variable_2 : total_output_net_capacitance; index_1 (&#34;0.
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/03/14/design-compiler-synthesis/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/synthesis">synthesis
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/synopsys">synopsys
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/dc">dc
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/designcompiler">designcompiler
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/03/12/try-openroad-flow/">OpenROAD Flow 初尝试</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/03/12/try-openroad-flow/" class="article-date">
                        <time datetime='2022-03-12T22:52:00.000&#43;08:00' itemprop="datePublished">2022-03-12</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/03/12/try-openroad-flow/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近在尝试接触一些芯片前后端的知识。正好有现成的开源工具链 OpenROAD 来做这个事情，借此机会来学习一下整个流程。
尝试过程 首先 clone 仓库 OpenROAD-flow-scripts，然后运行：./build_openroad.sh，脚本会克隆一些仓库，自动进行编译。
编译中会找不到一些库，比如可能需要安装这些依赖：liblemon-dev libeigen3-dev libreadline-dev swig，此外运行的时候还需要 klayout 依赖。
如果遇到解决 cmake 找不到 LEMON 的问题，这是一个 BUG，可以运行下面的命令解决：
cd /usr/lib/x86_64-linux-gnu/cmake/lemon cp lemonConfig.cmake LEMONConfig.cmake 编译后整个目录大概有 4.8G，输出的二进制目录是 133M。
如果要跑一下样例里的 nangate45 工艺的 gcd 例子，运行：
cd flow make DESIGN_CONFIG=./designs/nangate45/gcd/config.mk 分析 GCD 测例 这个测例的代码提供了这样一个接口：
module gcd ( input wire clk, input wire [ 31:0] req_msg, output wire req_rdy, input wire req_val, input wire reset, output wire [ 15:0] resp_msg, input wire resp_rdy, output wire resp_val ); endmodule 从名字可以推断出，外部通过 req 发送请求到 GCD 模块，然后模块计算出 GCD 后再返回结果。
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/03/12/try-openroad-flow/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/openroad">openroad
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/synthesis">synthesis
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/yosys">yosys
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2022/03/09/rocket-chip-jtag-debug/">通过 JTAG 对 VCU128 上的 Rocket Chip 进行调试</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2022/03/09/rocket-chip-jtag-debug/" class="article-date">
                        <time datetime='2022-03-09T19:04:00.000&#43;08:00' itemprop="datePublished">2022-03-09</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2022/03/09/rocket-chip-jtag-debug/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    前言 两年前，我尝试过用 BSCAN JTAG 来配置 Rocket Chip 的调试，但是这个方法不是很好用，具体来说，如果有独立的一组 JTAG 信号，配置起来会更方便，而且不用和 Vivado 去抢，OpenOCD 可以和 Vivado hw_server 同时运行和工作。但是，苦于 VCU128 上没有 PMOD 接口，之前一直没考虑过在 VCU128 上配置独立的 JTAG。然后最近研究了一下，终于解决了这个问题。
寻找 JTAG 接口 前几天在研究别的问题的时候，看到 VCU128 文档中的这段话：
The FT4232HL U8 multi-function USB-UART on the VCU128 board provides three level-shifted UART connections through the single micro-AB USB connector J2. • Channel A is configured in JTAG mode to support the JTAG chain • Channel B implements 4-wire UART0 (level-shifted) FPGA U1 bank 67 connections • Channel C implements 4-wire UART1 (level-shifted) FPGA U1 bank 67 connections • Channel D implements 2-wire (level-shifted) SYSCTLR U42 bank 501 connections 其中 Channel A 是到 FPGA 本身的 JTAG 接口，是给 Vivado 用的，如果是通过 BSCAN 的方式，也是在这个 Channel 上，但是需要经过 FPGA 自己的 TAP 再隧道到 BSCAN 上，比较麻烦。Channel B 和 C 是串口，Channel D 是连接 VCU128 上的 System Controller 的。之前的时候，都是直接用 Channel B 做串口，然后突发奇想：注意到这里是 4-wire UART，说明连接到 FPGA 是四条线，那是不是也可以拿来当 JTAG 用？
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2022/03/09/rocket-chip-jtag-debug/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/fpga">fpga
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/riscv">riscv
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/rocketchip">rocketchip
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/jtag">jtag
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/openocd">openocd
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/vcu128">vcu128
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/ft4232">ft4232
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        

        

<nav id="page-nav">
    
    <a href="/page/6/" rel="prev" class="extend prev">&laquo; Prev</a>
    
    
    
    <a href="/">1</a>
    
    
    
    <a href="/page/2/">2</a>
    
    
    
    <a href="/page/3/">3</a>
    
    
    
    <a href="/page/4/">4</a>
    
    
    
    <a href="/page/5/">5</a>
    
    
    
    <a href="/page/6/">6</a>
    
    
    
    <span class="page-number current">7</span>
    
    
    
    <a href="/page/8/">8</a>
    
    
    
    <a href="/page/9/">9</a>
    
    
    
    <a href="/page/10/">10</a>
    
    
    
    <a href="/page/11/">11</a>
    
    
    
    <a href="/page/12/">12</a>
    
    
    
    <a href="/page/13/">13</a>
    
    
    
    <a href="/page/14/">14</a>
    
    
    
    <a href="/page/15/">15</a>
    
    
    
    <a href="/page/16/">16</a>
    
    
    
    <a href="/page/17/">17</a>
    
    
    
    <a href="/page/18/">18</a>
    
    
    
    <a href="/page/19/">19</a>
    
    
    
    <a href="/page/20/">20</a>
    
    
    
    <a href="/page/21/">21</a>
    
    
    
    <a href="/page/22/">22</a>
    
    
    
    <a href="/page/23/">23</a>
    
    
    
    <a href="/page/24/">24</a>
    
    
    
    <a href="/page/25/">25</a>
    
    
    
    <a href="/page/26/">26</a>
    
    
    
    <a href="/page/27/">27</a>
    
    
    
    <a href="/page/28/">28</a>
    
    
    
    <a href="/page/29/">29</a>
    
    
    
    <a href="/page/30/">30</a>
    
    
    
    <a href="/page/31/">31</a>
    
    
    
    <a href="/page/32/">32</a>
    
    
    
    <a href="/page/33/">33</a>
    
    
    
    <a href="/page/34/">34</a>
    
    
    
    <a href="/page/35/">35</a>
    
    
    
    <a href="/page/36/">36</a>
    
    

    
    <a href="/page/8/" rel="next" class="extend next">Next &raquo;</a>
    
</nav>


    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2023 杰哥的{运维,编程,调板子}小笔记
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3109FRSVTT"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3109FRSVTT', { 'anonymize_ip': false });
}
</script>


    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
        <script>renderMathInElement(document.body);</script>
    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>