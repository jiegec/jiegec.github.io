<!DOCTYPE html>
<html>
<head>
    <title>杰哥的{运维,编程,调板子}小笔记</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="杰哥的{运维,编程,调板子}小笔记" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://jia.je/" />
    
<link href="/feed.xml" rel="alternate" type="application/rss+xml" title="杰哥的{运维,编程,调板子}小笔记" />
    <link rel="shortcut icon" href="/favicon.ico">

    <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/style.css">
    
    <script src="/js/wavedrom/default.js" type="text/javascript"></script>
    <script src="/js/wavedrom/wavedrom.min.js" type="text/javascript" /></script>

    <meta name="generator" content="Hugo 0.106.0">
</head>

<body>
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="/">杰哥的{运维,编程,调板子}小笔记</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">关于</a>
                
                <a class="main-nav-link" href="/category/">分类</a>
                
                <a class="main-nav-link" href="/open-source-contributions/">开源</a>
                
                <a class="main-nav-link" href="/tags/">标签</a>
                
                <a class="main-nav-link" href="/series/">系列</a>
                
                <a class="main-nav-link" href="/feed.xml">订阅</a>
                
                <a class="main-nav-link" href="/projects/readme/">项目</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/devops/2020/04/17/tke-nginx-ingress-without-lb/">在 TKE 上配置不使用 LB 的 Nginx Ingress Controller</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/devops/2020/04/17/tke-nginx-ingress-without-lb/" class="article-date">
                        <time datetime='2020-04-17T17:30:00.000&#43;08:00' itemprop="datePublished">2020-04-17</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/devops/2020/04/17/tke-nginx-ingress-without-lb/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 想要在 k8s 里面 host 一个网站，但又不想额外花钱用 LB，想直接用节点的 IP。
方法 首先安装 nginx-ingress：
$ helm repo add nginx-stable https://helm.nginx.com/stable $ helm repo update $ helm install ingress-controller nginx-stable/nginx-ingress --set controller.service.type=NodePort --set controller.hostNetwork=true 这里给 ingress controller chart 传了两个参数：第一个指定 service 类型是 NodePort，替代默认的 LoadBalancer；第二个指定 ingress controller 直接在节点上监听，这样就可以用节点的公网 IP 访问了。
然后配一个 ingress：
apiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: name: ingress-example annotations: kubernetes.io/ingress.class: &#34;nginx&#34; spec: rules: - host: example.com http: paths: - path: / backend: serviceName: example-service servicePort: 80 然后就可以发现请求被正确路由到 example-service 的 80 端口了。
                    </p>
                    <p class="article-more-link">
                        <a href="/devops/2020/04/17/tke-nginx-ingress-without-lb/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/k8s">k8s
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/kubernetes">kubernetes
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/tencentcloud">tencentcloud
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/tke">tke
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/nginx">nginx
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/nginx-ingress">nginx-ingress
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/software/2020/04/13/sbt-fork-parallel-test/">在 sbt 中 fork 并且并行运行测试</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/software/2020/04/13/sbt-fork-parallel-test/" class="article-date">
                        <time datetime='2020-04-13T21:00:00.000&#43;08:00' itemprop="datePublished">2020-04-13</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/software/2020/04/13/sbt-fork-parallel-test/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    问题 最近在 sbt 使用遇到一个问题，有两个测试，分别用 testOnly 测试的时候没有问题，如果同时测试就会出问题，应该是全局的状态上出现了冲突。一个自然的解决思路是 fork，但是 sbt 默认 fork 之后 test 是顺序执行的，这会很慢。所以搜索了一下，找到了 fork 并且并行测试的方法。
解决方法 解决方法在 sbt 文档中其实就有（原文）。简单来说就是：把每个 test 放到单独的 TestGroup 中，每个 TestGroup 分别用一个 forked JVM 去运行；然后让 sbt 的并行限制设高一些：
// move each test into a group and fork them to avoid race condition import Tests._ def singleTests(tests: Seq[TestDefinition]) = tests map { test =&gt; new Group( name = test.name, tests = Seq(test), SubProcess(ForkOptions())) } Test / testGrouping := singleTests( (Test / definedTests).
                    </p>
                    <p class="article-more-link">
                        <a href="/software/2020/04/13/sbt-fork-parallel-test/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/sbt">sbt
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/scala">scala
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/testing">testing
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2020/04/04/vivado-simulation-command/">在命令行中进行 Vivado 仿真</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2020/04/04/vivado-simulation-command/" class="article-date">
                        <time datetime='2020-04-04T18:50:00.000&#43;08:00' itemprop="datePublished">2020-04-04</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2020/04/04/vivado-simulation-command/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    想要在命令行里进行 Vivado 仿真，所以查了下 Xilinx 的 UG900 文档，找到了命令行仿真的方法。首先是生成仿真所需的文件：
# assuming batch mode open_project xxx.xpr set_property top YOUR_SIM_TOP [current_fileset -simset] export_ip_user_files -no_script -force export_simulation -simulator xsim -force 可以把这些语句放到 tcl 文件里然后用 batch mode 执行。执行成功以后，会在 export_sim/xsim 目录下生成一些文件。里面会有生成的脚本以供仿真：
cd export_sim/xsim &amp;&amp; ./YOUR_SIM_TOP.sh 默认情况下它会执行 export_sim/xsim/cmd.tcl 里面的命令。如果想要记录 vcd 文件，修改内容为：
open_vcd log_vcd run 20us close_vcd quit 这样就可以把仿真的波形输出到 dump.vcd 文件，拖到本地然后用 GTKWave 看。更多支持的命令可以到 UG900 里找。
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2020/04/04/vivado-simulation-command/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/vivado">vivado
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/simulation">simulation
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/verilog">verilog
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/tcl">tcl
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2020/03/17/rocket-chip-tlram-load/">在 Rocket Chip 上挂接 TLRAM</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2020/03/17/rocket-chip-tlram-load/" class="article-date">
                        <time datetime='2020-03-17T23:20:00.000&#43;08:00' itemprop="datePublished">2020-03-17</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2020/03/17/rocket-chip-tlram-load/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    最近遇到一个需求，需要在 Rocket Chip 里面开辟一块空间，通过 verilog 的 $readmemh 来进行初始化而不是用 BootROM，这样每次修改内容不需要重新跑一次 Chisel -&gt; Verilog 的流程。然后到处研究了一下，找到了解决的方案：
首先是新建一个 TLRAM 然后挂接到 cbus 上：
import freechips.rocketchip.tilelink.TLRAM import freechips.rocketchip.tilelink.TLFragmenter import freechips.rocketchip.diplomacy.LazyModule import freechips.rocketchip.diplomacy.AddressSet trait HasTestRAM { this: BaseSubsystem =&gt; val testRAM = LazyModule( new TLRAM(AddressSet(0x40000000, 0x1FFF), beatBytes = cbus.beatBytes) ) testRAM.node := cbus.coupleTo(&#34;bootrom&#34;) { TLFragmenter(cbus) := _ } } 这里的地址和大小都可以自由定义。然后添加到自己的 Top Module 中：
class TestTop(implicit p:Parameters) extends RocketSystem // ... with HasTestRAM //... { override lazy ... } 实际上这时候 TLRAM 就已经加入到了 TileLink 总线中。接着，为了让 firrtl 生成 $readmemh 的代码，需要两个步骤：
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2020/03/17/rocket-chip-tlram-load/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/chisel">chisel
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/rocketchip">rocketchip
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/riscv">riscv
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/devops/2020/03/17/setup-k8s-tencentcloud/">体验 Tencent Kubernetes Engine</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/devops/2020/03/17/setup-k8s-tencentcloud/" class="article-date">
                        <time datetime='2020-03-17T21:56:00.000&#43;08:00' itemprop="datePublished">2020-03-17</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/devops/2020/03/17/setup-k8s-tencentcloud/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    之前在机器上试验了一下 kubernetes，感觉挺不错的，所以就想把腾讯云上面的机器也交给 kubernetes 管理。找到容器服务，新建集群，选择模板里的标准托管集群就可以了。然后开启下面的公网访问，设置一个比较小的 IP 地址段，按照页面下面的要求合并一下 kube config（因为还有别的 k8s cluster）：
$ KUBECONFIG=~/.kube/config:/path/to/new/config kubectl config view --merge --flatten &gt; new_config $ cp new_config ~/.kube/config 覆盖之前先确认原来的配置还在，然后就可以用 kubectl 切换到新的 context：
$ kubectl config get-contexts $ kubectl config use-context new-context-here $ kubectl get node NAME STATUS ROLES AGE VERSION 172.21.0.17 Ready &lt;none&gt; 75m v1.16.3-tke.3 可以看到我们的 k8s node 已经上线了。我一般习惯先配好 kubernetes-dashboard：
$ kubectl create -f https://raw.githubusercontent.com/cilium/cilium/v1.6/install/kubernetes/quick-install.yaml $ kubectl proxy &amp; $ kubectl -n kubernetes-dashboard describe secret (kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#39;{print \$1}&#39;) | tail -n1 | awk &#39;{print \$2}&#39; | pbcopy 然后在浏览器里访问 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/overview?
                    </p>
                    <p class="article-more-link">
                        <a href="/devops/2020/03/17/setup-k8s-tencentcloud/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/k8s">k8s
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/kubernetes">kubernetes
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/tencentcloud">tencentcloud
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/dashboard">dashboard
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/devops/2020/03/14/k8s-gitlab-runner/">在 Kubernetes 集群上部署 gitlab—runner</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/devops/2020/03/14/k8s-gitlab-runner/" class="article-date">
                        <time datetime='2020-03-14T23:05:00.000&#43;08:00' itemprop="datePublished">2020-03-14</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/devops/2020/03/14/k8s-gitlab-runner/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    按照 GitLab 上的教程试着把 gitlab-runner 部署到 k8s 集群上，发现异常地简单，所以简单做个笔记：
编辑 values.yaml
gitlabUrl: GITLAB_URL runnerRegistrationToken: &#34;REDACTED&#34; rbac: create: true 此处的信息按照 &ldquo;Set up a specific Runner manually&rdquo; 下面的提示填写。然后用 Helm 进行安装：
$ helm repo add gitlab https://charts.gitlab.io $ kubectl create namespace gitlab-runner $ helm install --namespace gitlab-runner gitlab-runner -f values.yaml gitlab/gitlab-runner 然后去 Kubernetes Dashboard 就可以看到部署的情况，回到 GitLab 也可以看到出现了“Runners activated for this project” ，表示配置成功。
参考配置：https://docs.gitlab.com/runner/install/kubernetes.html
                    </p>
                    <p class="article-more-link">
                        <a href="/devops/2020/03/14/k8s-gitlab-runner/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/k8s">k8s
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/kubernetes">kubernetes
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gitlab">gitlab
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gitlab-runner">gitlab-runner
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/devops/2020/03/10/k8s-deploy-with-hpa/">用 Kubernetes 部署无状态服务</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/devops/2020/03/10/k8s-deploy-with-hpa/" class="article-date">
                        <time datetime='2020-03-10T13:57:00.000&#43;08:00' itemprop="datePublished">2020-03-10</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/devops/2020/03/10/k8s-deploy-with-hpa/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    背景 最近需要部署一个用来跑编译的服务，服务从 MQ 取任务，编译完以后提交任务。最初的做法是包装成 docker，然后用 docker-compose 来 scale up。但既然有 k8s 这么好的工具，就试着学习了一下，踩了很多坑，总结了一些需要用到的命令。
搭建 Docker Registry 首先搭建一个本地的 Docker Repository，首先设置密码：
$ mkdir auth $ htpasswd user pass &gt; auth/passwd 然后运行 registry：
$ docker run -d -p 5000:5000 \ --restart=always \ --name registry \ -v &#34;$(pwd)/registry&#34;:/var/lib/registry \ -v &#34;$(pwd)/auth&#34;:/auth \ -e &#34;REGISTRY_AUTH=htpasswd&#34; \ -e &#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&#34; \ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \ registry:2 简单起见没有配 tls。然后吧本地的 image push 上去：
$ docker tag $image localhost:5000/$image $ docker push localhost:5000/$image 这样就可以了。
                    </p>
                    <p class="article-more-link">
                        <a href="/devops/2020/03/10/k8s-deploy-with-hpa/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/k8s">k8s
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/kubernetes">kubernetes
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/docker">docker
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/devops/2020/03/09/use-jailkit-for-scp-only-user/">用 jailkit 限制用户仅 scp</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/devops/2020/03/09/use-jailkit-for-scp-only-user/" class="article-date">
                        <time datetime='2020-03-09T13:48:00.000&#43;08:00' itemprop="datePublished">2020-03-09</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/devops/2020/03/09/use-jailkit-for-scp-only-user/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    最近需要用 scp 部署到生产机器，但又不想出现安全问题，所以用了 jailkit 的方法。首先是创建单独的用户，然后生成 ssh key 来认证，不再赘述。此时是可以 scp 了，但用户依然可以获得 shell，不够安全。
然后找到了下面参考链接，大概摘录一下所需要的命令和配置：
mkdir /path/to/jail chown root:root /path/to/jail chmod 701 /path/to/jail jk_init -j /path/to/jail scp sftp jk_lsh jk_jailuser -m -j /path/to/jail jailed_user vim /path/to/jail/etc/jailkit/jk_lsh.ini # Add following lines [jailed_user] paths = /usr/bin, /usr/lib exectuables = /usr/bin/scp 之后可以发现该用户的 shell 已经更改 jk_chrootsh，并且只能用 scp。
参考：https://blog.tinned-software.net/restrict-linux-user-to-scp-to-his-home-directory/
                    </p>
                    <p class="article-more-link">
                        <a href="/devops/2020/03/09/use-jailkit-for-scp-only-user/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/jailkit">jailkit
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/chroot">chroot
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/scp">scp
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/misc/2020/02/28/weekly-sharing-56/">每周分享第 56 期</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/misc/2020/02/28/weekly-sharing-56/" class="article-date">
                        <time datetime='2020-02-28T15:56:00.000&#43;08:00' itemprop="datePublished">2020-02-28</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/misc/2020/02/28/weekly-sharing-56/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    咕咕咕
SystemVerilog linter https://github.com/dalance/svlint 东北方言编程语言 https://github.com/zhanyong-wan/dongbei JS LaTeX 渲染到 HTML https://github.com/michael-brade/LaTeX.js 一种对语音助手的攻击 https://surfingattack.github.io/ 在线打铃网站 http://thulpwan.net/timer/ 网络学堂 PC 端 App https://github.com/jiegec/learn_tsinghua_app/releases Rust 2020 roadmap https://github.com/rust-lang/rfcs/pull/2857/files 
                    </p>
                    <p class="article-more-link">
                        <a href="/misc/2020/02/28/weekly-sharing-56/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/weeklysharing">weeklysharing
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        
        <article class="article article-type-post" itemscope itemprop="blogPost">
            <div class="article-inner">
                
                
                <header class="article-header">
                    <h1 itemprop="name"><a class="article-title" href="/hardware/2020/02/10/simulate-chisel3-on-vivado/">在 Vivado 中对 chisel3 产生的 verilog 代码仿真</a></h1>
                </header>
                
                <div class="article-meta">
                    <a href="/hardware/2020/02/10/simulate-chisel3-on-vivado/" class="article-date">
                        <time datetime='2020-02-10T23:09:00.000&#43;08:00' itemprop="datePublished">2020-02-10</time>
                    </a>
                    
                    
                    
                    <div class="article-comment-link-wrap">
                        <a href="/hardware/2020/02/10/simulate-chisel3-on-vivado/#disqus_thread" class="article-comment-link">Comments</a>
                    </div>
                    
                </div>
                <div class="article-entry" itemprop="articleBody">
                    <p>
                        
                    默认情况下，chisel3 生成的 verilog 代码在 Vivado 中仿真会出现很多信号大面积变成 X。解决方法在一个不起眼的 Wiki 页面：Randomization flags：
`define RANDOMIZE_REG_INIT `define RANDOMIZE_MEM_INIT `define RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE_INVALID_ASSIGN 在生成的 verilog 前面加上这四句，就可以正常仿真了。
                    </p>
                    <p class="article-more-link">
                        <a href="/hardware/2020/02/10/simulate-chisel3-on-vivado/">Read More</a>
                    </p>
                </div>

                
                <footer class="article-footer">
                    <ul class="article-tag-list">
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/vivado">vivado
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/chisel">chisel
                            </a>
                        </li>
                        
                        <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/verilog">verilog
                            </a>
                        </li>
                        
                    </ul>
                </footer>
                
            </div>
        </article>
        

        

<nav id="page-nav">
    
    <a href="/page/10/" rel="prev" class="extend prev">&laquo; Prev</a>
    
    
    
    <a href="/">1</a>
    
    
    
    <a href="/page/2/">2</a>
    
    
    
    <a href="/page/3/">3</a>
    
    
    
    <a href="/page/4/">4</a>
    
    
    
    <a href="/page/5/">5</a>
    
    
    
    <a href="/page/6/">6</a>
    
    
    
    <a href="/page/7/">7</a>
    
    
    
    <a href="/page/8/">8</a>
    
    
    
    <a href="/page/9/">9</a>
    
    
    
    <a href="/page/10/">10</a>
    
    
    
    <span class="page-number current">11</span>
    
    
    
    <a href="/page/12/">12</a>
    
    
    
    <a href="/page/13/">13</a>
    
    
    
    <a href="/page/14/">14</a>
    
    
    
    <a href="/page/15/">15</a>
    
    
    
    <a href="/page/16/">16</a>
    
    
    
    <a href="/page/17/">17</a>
    
    
    
    <a href="/page/18/">18</a>
    
    
    
    <a href="/page/19/">19</a>
    
    
    
    <a href="/page/20/">20</a>
    
    
    
    <a href="/page/21/">21</a>
    
    
    
    <a href="/page/22/">22</a>
    
    
    
    <a href="/page/23/">23</a>
    
    
    
    <a href="/page/24/">24</a>
    
    
    
    <a href="/page/25/">25</a>
    
    
    
    <a href="/page/26/">26</a>
    
    
    
    <a href="/page/27/">27</a>
    
    
    
    <a href="/page/28/">28</a>
    
    
    
    <a href="/page/29/">29</a>
    
    
    
    <a href="/page/30/">30</a>
    
    
    
    <a href="/page/31/">31</a>
    
    
    
    <a href="/page/32/">32</a>
    
    
    
    <a href="/page/33/">33</a>
    
    

    
    <a href="/page/12/" rel="next" class="extend next">Next &raquo;</a>
    
</nav>


    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2022 杰哥的{运维,编程,调板子}小笔记
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3109FRSVTT"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3109FRSVTT', { 'anonymize_ip': false });
}
</script>


    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
        <script>renderMathInElement(document.body);</script>
    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>