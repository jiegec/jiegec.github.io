<!DOCTYPE html>
<html>
<head>
    <title>链接器的工作原理 // 杰哥的{运维,编程,调板子}小笔记</title>

    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    
    
    

        <meta property="og:title" content="链接器的工作原理" />
    <meta property="og:description" content="背景 最近和同学讨论一些比较复杂的链接问题，遇到一些比较复杂的情况，因此复习一遍链接器的工作原理。
编译 编译器会把源文件编译成 obj，obj 里面有符号表，定义了不同的符号类型。常见的代码与符号的对应关系：
// global in .bss section if -fno-common // common symbol if -fcommon int uninitialized; // global in .bss section int initialized = 0; // global in .data section int initialized_one = 1; // global in .rodata section const int const_initialized = 0; // global in .rodata section const int const_initialized_one = 1; // global undefined symbol extern int external; // local in .bss section static int static_uninitialized; // local in ." />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en" />
    <meta property="og:url" content="https://jia.je/software/2023/05/06/linker/" />
    

    <link rel="shortcut icon" href="/favicon.ico">

    <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
    <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">

    <link rel="stylesheet" href="/css/style.css">
    
    <script src="/js/wavedrom/default.js" type="text/javascript"></script>
    <script src="/js/wavedrom/wavedrom.min.js" type="text/javascript" /></script>

    <meta name="generator" content="Hugo 0.112.3">
</head>


<body onload="WaveDrom.ProcessAll()">
<div id="container">
    <header id="header">
    <div id="header-outer" class="outer">
        <div id="header-inner" class="inner">
            <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
            <a id="logo" class="logo-text" href="/">杰哥的{运维,编程,调板子}小笔记</a>
            <nav id="main-nav">
                
                <a class="main-nav-link" href="/about/">关于</a>
                
                <a class="main-nav-link" href="/category/">分类</a>
                
                <a class="main-nav-link" href="/open-source-contributions/">开源</a>
                
                <a class="main-nav-link" href="/tags/">标签</a>
                
                <a class="main-nav-link" href="/kb/">知识库</a>
                
                <a class="main-nav-link" href="/series/">系列</a>
                
                <a class="main-nav-link" href="/feed.xml">订阅</a>
                
                <a class="main-nav-link" href="/projects/readme/">项目</a>
                
            </nav>
            <nav id="sub-nav">
                <div id="search-form-wrap">
                </div>
            </nav>
        </div>
    </div>
</header>

    <section id="main" class="outer">
        <article class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        <header class="article-header">
            <h1 class="article-title" itemprop="name">链接器的工作原理</h1>
        </header>
        
        <div class="article-meta">
            <a href="/software/2023/05/06/linker/" class="article-date">
                <time datetime='2023-05-06T12:09:00.000&#43;08:00' itemprop="datePublished">2023-05-06</time>
            </a>
            
            
            
            <div class="article-comment-link-wrap">
                <a href="/software/2023/05/06/linker/#disqus_thread" class="article-comment-link">Comments</a>
            </div>
            
        </div>
        <div class="article-entry" itemprop="articleBody">
            <h2 id="背景">背景</h2>
<p>最近和同学讨论一些比较复杂的链接问题，遇到一些比较复杂的情况，因此复习一遍链接器的工作原理。</p>
<h2 id="编译">编译</h2>
<p>编译器会把源文件编译成 obj，obj 里面有符号表，定义了不同的符号类型。常见的代码与符号的对应关系：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// global in .bss section if -fno-common
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// common symbol if -fcommon
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> uninitialized;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .bss section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> initialized <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .data section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> initialized_one <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .rodata section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> const_initialized <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .rodata section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> const_initialized_one <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global undefined symbol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> external;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// local in .bss section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> static_uninitialized;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// local in .bss section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> static_initialized <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// local in .data section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> static_initialized_one <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// local in .rodata section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> const_static_initialized <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// local in .rodata section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> const_static_initialized_one <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .text section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">simple_function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// local in .bss section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> static_in_function <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .text section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">access_external</span>() { external <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; }
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global undefined symbol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">external_function</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .text section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">call_external</span>() { <span style="color:#a6e22e">external_function</span>(); }
</span></span><span style="display:flex;"><span><span style="color:#75715e">// local in .text section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">static_function</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// weak in .text section
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__attribute__</span> ((weak)) <span style="color:#66d9ef">float</span> <span style="color:#a6e22e">weak_function</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// global in .text section marked .hidden
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">__attribute__</span> ((<span style="color:#a6e22e">visibility</span> (<span style="color:#e6db74">&#34;hidden&#34;</span>))) <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hidden_function</span>() {}
</span></span></code></pre></div><p>使用 <code>readelf -s</code> 查看符号表：</p>
<pre tabindex="0"><code>   Num:    Value          Size Type    Bind   Vis      Ndx Name
     6: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    4 static_uninitialized
     7: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    4 static_initialized
     8: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_initializ[...]
     9: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    5 const_static_ini[...]
    10: 000000000000000c     4 OBJECT  LOCAL  DEFAULT    5 const_static_ini[...]
    11: 0000000000000029     7 FUNC    LOCAL  DEFAULT    1 static_function
    12: 0000000000000010     4 OBJECT  LOCAL  DEFAULT    4 static_in_function.0
    16: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 uninitialized
    17: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    4 initialized
    18: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 initialized_one
    19: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    5 const_initialized
    20: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    5 const_initialized_one
    21: 0000000000000000     7 FUNC    GLOBAL DEFAULT    1 simple_function
    22: 0000000000000007    17 FUNC    GLOBAL DEFAULT    1 access_external
    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND external
    24: 0000000000000018    17 FUNC    GLOBAL DEFAULT    1 call_external
    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND external_function
    27: 0000000000000030    11 FUNC    WEAK   DEFAULT    1 weak_function
    28: 000000000000003b     7 FUNC    GLOBAL HIDDEN     1 hidden_function
</code></pre><p>总结一下，每个符号有如下属性：</p>
<ol>
<li>Bind：Local（static）、Global（extern 或者非 static）、Weak（标记 <code>__attribute__ ((weak))</code>）</li>
<li>Vis(Visibility): Default、Hidden（标记 <code>__attribute__ ((visibility (&quot;hidden&quot;)))</code>）</li>
<li>Ndx：
<ol>
<li>COMMON：如果打开了 -fcommon，那么没有初始化的全局变量（上面的 <code>uninitialized</code>）会生成 COMMON 符号；如果打开了 -fno-common，则不会有 COMMON 符号</li>
<li>UNDEFINED：extern 符号</li>
</ol>
</li>
<li>Section:
<ol>
<li>const 变量放在 .rodata section</li>
<li>非 const 变量，如果没有初始化，如果开了 -fcommon，则生成 COMMON 符号；如果开了 -fno-common，则放在 .bss section</li>
<li>非 const 变量，如果初始化了，放在 .data section</li>
<li>函数放在 .text section</li>
</ol>
</li>
</ol>
<p>关于 COMMON 符号的详细内容，建议阅读 <a href="https://maskray.me/blog/2022-02-06-all-about-common-symbols">All about COMMON symbols - MaskRay</a> 和 <a href="/software/2022/07/11/archive-common-linking/">COMMON 符号</a>。</p>
<h2 id="链接">链接</h2>
<p>链接要做的是把多个 obj 合并成一个可执行文件或者动态库，主要目的是将一个 obj 中定义的符号与另一个 obj 中 undefined 的符号对应起来。</p>
<p>链接器运行时，传入若干个 obj 文件，然后按照下面的流程进行：</p>
<ol>
<li>维护一个全局的符号表</li>
<li>循环每个 obj 文件，循环其中的符号，找到其中的 GLOBAL/WEAK 符号</li>
<li>把 GLOBAL/WEAK 符号插入到符号表中，处理各种情况，例如：
<ol>
<li>如果出现两个 defined 符号冲突，报告 multiple definition 错误</li>
<li>如果出现重名的 weak 符号和 strong 符号，选择保留 strong 的符号</li>
</ol>
</li>
<li>如果存在没有找到匹配的 defined 符号的 undefined 符号，报告 undefined reference 错误</li>
</ol>
<p>符号表是在解析 obj 文件的同时动态更新的，因此，如果 A 使用了 B 的符号，那么应该把 A 放在前面，这样链接器解析 A 的时候会在符号表中创建 undefined 符号，然后 B 在后面，当链接器解析 B 的时候，就可以把 B 的 defined 符号与 A 的 undefined 符号进行匹配。</p>
<h2 id="静态库">静态库</h2>
<p>静态库将多个 .o 合并为一个 .a，并且创建了索引。具体来说，创建一个静态库的时候：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ar rcs libxxx.a obj1.o obj2.o obj3.o ...
</span></span></code></pre></div><p>生成的 .a 会包括所有的 .o，然后创建索引（<code>ar rcs</code> 中的 <code>s</code>，会运行 <code>ranlib</code> 命令），索引的内容是一个符号到 .o 文件的映射：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ nm -s /lib/x86_64-linux-gnu/libc.a
</span></span><span style="display:flex;"><span>Archive index:
</span></span><span style="display:flex;"><span>__printf in printf.o
</span></span><span style="display:flex;"><span>_IO_printf in printf.o
</span></span><span style="display:flex;"><span>printf in printf.o
</span></span><span style="display:flex;"><span>__scanf in scanf.o
</span></span><span style="display:flex;"><span>scanf in scanf.o
</span></span></code></pre></div><p>因此，链接器在遇到参数是 .a 的静态库的时候，不会查看里面的每个 .o 文件，而是从 Archive index 入手，如果当前的符号表依赖了 Archive index 中的符号，那就加载相应的 .o 文件。</p>
<h2 id="动态库">动态库</h2>
<p>生成动态库的方法是，编译的时候添加 <code>-fPIC</code> 选项，链接的时候添加 <code>-shared</code> 编译参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>gcc -fPIC -c source1.c -o source1.o
</span></span><span style="display:flex;"><span>gcc -shared source1.o -o libtest.so.0.0.0
</span></span><span style="display:flex;"><span><span style="color:#75715e"># oneliner:</span>
</span></span><span style="display:flex;"><span>gcc -fPIC -shared source1.c -o libtest.so.0.0.0
</span></span></code></pre></div><p>此时代码中定义的函数会出现在 Dynamic Symbol Table 中，可以用 <code>objdump -T</code> 命令查看：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat source1.c
</span></span><span style="display:flex;"><span>int simple_function<span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
</span></span><span style="display:flex;"><span>$ objdump -T libtest.so.0.0.0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>libtest.so.0.0.0:     file format elf64-x86-64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DYNAMIC SYMBOL TABLE:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span> __cxa_finalize
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span> _ITM_registerTMCloneTable
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span> _ITM_deregisterTMCloneTable
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span> __gmon_start__
</span></span><span style="display:flex;"><span>00000000000010f9 g    DF .text  <span style="color:#ae81ff">0000000000000007</span> simple_function
</span></span></code></pre></div><p>如果代码中用了 libc 的一些函数，那么这些函数则会以 undefined symbol 的形式出现在 Dynamic Symbol Table 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat source1.c
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdio.h&gt;</span>
</span></span><span style="display:flex;"><span>int simple_function<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Simple function&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>$ objdump -T libtest.so.0.0.0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>libtest.so.0.0.0:     file format elf64-x86-64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DYNAMIC SYMBOL TABLE:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span>  Base        _ITM_deregisterTMCloneTable
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>      DF *UND*  <span style="color:#ae81ff">0000000000000000</span> <span style="color:#f92672">(</span>GLIBC_2.2.5<span style="color:#f92672">)</span> printf
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span>  Base        __gmon_start__
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   D  *UND*  <span style="color:#ae81ff">0000000000000000</span>  Base        _ITM_registerTMCloneTable
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>  w   DF *UND*  <span style="color:#ae81ff">0000000000000000</span> <span style="color:#f92672">(</span>GLIBC_2.2.5<span style="color:#f92672">)</span> __cxa_finalize
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000001109</span> g    DF .text  000000000000001b  Base        simple_function
</span></span></code></pre></div><h3 id="符号版本">符号版本</h3>
<p>中间出现的 Base 或者 GLIBC_2.2.5 是符号的版本号，这样做的目的是为了兼容性：假如某天 glibc 想要给一个函数添加一个新的参数，但是现有的程序编译的时候动态链接了旧版本的 glibc，新旧两个版本的函数名字一样，但是功能却不一样，如果直接让旧程序用新 glibc 的函数，就会出现问题。即使参数不变，如果函数的语义变了，也可能带来不兼容的问题。</p>
<p>解决办法是给符号添加版本号，这样旧版本的程序会继续找到旧版本的符号，解决了兼容性的问题。例如 memcpy 在 glibc 中就有两个版本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ objdump -T /lib/x86_64-linux-gnu/libc.so.6 | grep memcpy
</span></span><span style="display:flex;"><span>00000000000a2b70 g    DF .text  <span style="color:#ae81ff">0000000000000028</span> <span style="color:#f92672">(</span>GLIBC_2.2.5<span style="color:#f92672">)</span> memcpy
</span></span><span style="display:flex;"><span>000000000009bc50 g   iD  .text  <span style="color:#ae81ff">0000000000000109</span>  GLIBC_2.14  memcpy
</span></span></code></pre></div><p>在 <a href="https://github.com/bminor/glibc/blob/a363f7075125fa654342c69331e6c075518ec28c/sysdeps/x86_64/multiarch/memcpy.c#LL38C11-L38C11">glibc 代码</a>中，通过 <code>versioned_symbol</code> 宏来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">versioned_symbol</span> (libc, __new_memcpy, memcpy, GLIBC_2_14);
</span></span></code></pre></div><p>更多关于符号版本的内容，可以阅读 <a href="https://maskray.me/blog/2020-11-26-all-about-symbol-versioning">All about symbol versioning</a>。</p>
<h3 id="动态链接">动态链接</h3>
<p>编译好动态链接库以后，可以在链接的时候，作为参数引入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cat main.c
</span></span><span style="display:flex;"><span>extern void simple_function<span style="color:#f92672">()</span>;
</span></span><span style="display:flex;"><span>int main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> simple_function<span style="color:#f92672">()</span>; <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>$ gcc main.c libtest.so.0.0.0 -o main
</span></span><span style="display:flex;"><span>$ LD_LIRBARY_PATH<span style="color:#f92672">=</span>$PWD ./main
</span></span><span style="display:flex;"><span>Simple <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>可以观察一下发生了什么事情：首先，链接的时候，会找到 <code>libtest.so.0.0.0</code> 导出的符号表，发现它定义了 <code>main.c</code> 缺少的 <code>simple_function</code> 函数，因此链接不会出错。但是，函数本身没有被链接到 <code>main</code> 里面，需要在运行时去加载动态库，这样 <code>main</code> 才可以调用函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ objdump -t main
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>       F *UND*  <span style="color:#ae81ff">0000000000000000</span>              simple_function
</span></span><span style="display:flex;"><span>$ objdump -T main
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>      DF *UND*  <span style="color:#ae81ff">0000000000000000</span>  Base        simple_function
</span></span><span style="display:flex;"><span>$ readelf -d ./main
</span></span><span style="display:flex;"><span>Dynamic section at offset 0x2dd0 contains <span style="color:#ae81ff">27</span> entries:
</span></span><span style="display:flex;"><span>  Tag        Type                         Name/Value
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libtest.so.0.0.0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libc.so.6<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>$ ./main
</span></span><span style="display:flex;"><span>./main: error <span style="color:#66d9ef">while</span> loading shared libraries: libtest.so.0.0.0: cannot open shared object file: No such file or directory
</span></span><span style="display:flex;"><span>$ ldd ./main
</span></span><span style="display:flex;"><span>        linux-vdso.so.1 <span style="color:#f92672">(</span>0x00007ffe07dbc000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libtest.so.0.0.0 <span style="color:#f92672">=</span>&gt; not found
</span></span><span style="display:flex;"><span>        libc.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style="color:#f92672">(</span>0x00007f83ee3fb000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        /lib64/ld-linux-x86-64.so.2 <span style="color:#f92672">(</span>0x00007f83ee602000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>$ LD_LIBRARY_PATH<span style="color:#f92672">=</span>$PWD ldd ./main
</span></span><span style="display:flex;"><span>        linux-vdso.so.1 <span style="color:#f92672">(</span>0x00007fffb0bd5000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libtest.so.0.0.0 <span style="color:#f92672">=</span>&gt; /tmp/libtest.so.0.0.0 <span style="color:#f92672">(</span>0x00007f985b3db000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libc.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style="color:#f92672">(</span>0x00007f985b1db000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        /lib64/ld-linux-x86-64.so.2 <span style="color:#f92672">(</span>0x00007f985b3e7000<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>首先可以看到，二进制里面 <code>simple_function</code> 依然属于 undefined 状态。但 <code>main</code> 也指定了 NEEDED libtest.so.0.0.0，那么在运行的时候，ld.so 就会去寻找这个动态库。由于当前路径不在系统默认路径中，直接运行是找不到的（<code>not found</code>），这里的解决办法是添加动态库的路径到 <code>LD_LIBRARY_PATH</code> 中。</p>
<h3 id="soname">soname</h3>
<p>上述例子中，编译出来的动态库名称带有完整的版本号：<code>major.minor.patch=0.0.0</code>，但一般认为，如果 <code>major</code> 版本号没有变，可以认为是 ABI 兼容的，可以更新动态库的版本，而不用重新编译程序。但是，上面的例子里，<code>readelf -d main</code> 显示 NEEDED 的动态库名字里也包括了完整的版本号，那就没有办法寻找到同 major 的不同版本了。</p>
<p>解决办法是让同 major 的不同版本共享同一个 soname，常见的做法就是只保留 major 版本号：<code>libtest.so.0</code>，而不是 <code>libtest.so.0.0.0</code>。在编译动态库的时候，通过 <code>-Wl,-soname,libtest.so.0</code> 参数来指定 soname：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc -fPIC -shared source1.c -Wl,-soname,libtest.so.0 -o libtest.so.0.0.0
</span></span><span style="display:flex;"><span>$ gcc main.c libtest.so.0.0.0 -o main
</span></span><span style="display:flex;"><span>$ readelf -d main
</span></span><span style="display:flex;"><span>  Tag        Type                         Name/Value
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libtest.so.0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libc.so.6<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>此时可以看到 NEEDED 的动态库名字已经是预期的 <code>libtest.so.0</code>，这意味着 <code>main</code> 函数在动态加载的时候，不考虑小版本，只指定了 <code>major</code> 版本为 0 的 libtest 动态库。但单是这样还不能运行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ LD_LIBRARY_PATH<span style="color:#f92672">=</span>$PWD ./main
</span></span><span style="display:flex;"><span>./main: error <span style="color:#66d9ef">while</span> loading shared libraries: libtest.so.0: cannot open shared object file: No such file or directory
</span></span></code></pre></div><p>毕竟 ld.so 要找的是 <code>libtest.so.0</code>，但是文件系统里只有 <code>libtest.so.0.0.0</code>，最后的这一步用符号链接来实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ln -s libtest.so.0.0.0 libtest.so.0
</span></span><span style="display:flex;"><span>$ LD_LIBRARY_PATH<span style="color:#f92672">=</span>$PWD ./main
</span></span><span style="display:flex;"><span>Simple <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>这样，如果哪天发布了 libtest.so 的 0.0.1 版本，只需要修改符号链接 <code>libtest.so.0 -&gt; libtest.so.0.0.1</code> 即可，不需要重新编译 <code>main</code> 程序。</p>
<p>想要查看动态库的 soname，可以用 <code>readelf -d</code> 查看：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ readelf -d libtest.so.0.0.0
</span></span><span style="display:flex;"><span>  Tag        Type                         Name/Value
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libc.so.6<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x000000000000000e <span style="color:#f92672">(</span>SONAME<span style="color:#f92672">)</span>             Library soname: <span style="color:#f92672">[</span>libtest.so.0<span style="color:#f92672">]</span>
</span></span></code></pre></div><h3 id="cuda">cuda</h3>
<p>在 CUDA 中，如果程序需要访问 NVML 或者一些底层的 CUDA 函数，会链接到 libcuda（而不是 libcudart），但是如果在 CUDA 目录下寻找 libcuda，只会找到一个 <code>targets/x86_64-linux/lib/stubs/libcuda.so</code>，里面的函数都是空的，只有一个 <code>retq</code> 指令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ objdump -S ./targets/x86_64-linux/lib/stubs/libcuda.so
</span></span><span style="display:flex;"><span>./targets/x86_64-linux/lib/stubs/libcuda.so:     file format elf64-x86-64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000007370</span> &lt;cuGetErrorString&gt;:
</span></span><span style="display:flex;"><span>    7370:       b8 <span style="color:#ae81ff">22</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          mov    $0x22,%eax
</span></span><span style="display:flex;"><span>    7375:       c3                      retq
</span></span><span style="display:flex;"><span>    7376:       <span style="color:#ae81ff">66</span> 2e 0f 1f <span style="color:#ae81ff">84</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>    nopw   %cs:0x0<span style="color:#f92672">(</span>%rax,%rax,1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    737d:       <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000007380</span> &lt;cuGetErrorName&gt;:
</span></span><span style="display:flex;"><span>    7380:       b8 <span style="color:#ae81ff">22</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          mov    $0x22,%eax
</span></span><span style="display:flex;"><span>    7385:       c3                      retq
</span></span><span style="display:flex;"><span>    7386:       <span style="color:#ae81ff">66</span> 2e 0f 1f <span style="color:#ae81ff">84</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>    nopw   %cs:0x0<span style="color:#f92672">(</span>%rax,%rax,1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    738d:       <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
</span></span></code></pre></div><p>这个 <code>libcuda.so</code> 用途就是导出了所有可能会用到的符号，并且设置 <code>soname</code> 为 <code>libcuda.so.1</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ readelf -d ./targets/x86_64-linux/lib/stubs/libcuda.so
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Dynamic section at offset 0xdf30 contains <span style="color:#ae81ff">8</span> entries:
</span></span><span style="display:flex;"><span>  Tag        Type                         Name/Value
</span></span><span style="display:flex;"><span> 0x000000000000000e <span style="color:#f92672">(</span>SONAME<span style="color:#f92672">)</span>             Library soname: <span style="color:#f92672">[</span>libcuda.so.1<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>这就意味着，<code>ld.so</code> 会去寻找 <code>libcuda.so.1</code>，而不是 <code>libcuda</code>。前者才是真正实现了 CUDA Driver 的动态库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ dpkg -S libcuda.so.1
</span></span><span style="display:flex;"><span>libnvidia-compute-470:amd64: /usr/lib/x86_64-linux-gnu/libcuda.so.1
</span></span><span style="display:flex;"><span>$ ls -alh /usr/lib/x86_64-linux-gnu/libcuda.so.1
</span></span><span style="display:flex;"><span>lrwxrwxrwx <span style="color:#ae81ff">1</span> root root <span style="color:#ae81ff">21</span> May <span style="color:#ae81ff">13</span>  <span style="color:#ae81ff">2022</span> /usr/lib/x86_64-linux-gnu/libcuda.so.1 -&gt; libcuda.so.470.129.06
</span></span></code></pre></div><p>而 CUDA Driver 的实现和 NVIDIA Driver 的版本是绑定的，因此 <code>libcuda.so.1</code> 是软链接，软链接到对应驱动版本的 <code>libcuda.so</code>。这样做的好处就是，编译 CUDA 的机器，不需要安装 NVIDIA Driver，CUDA 也不需要自己带一份 CUDA Driver 进来，节省了空间。</p>
<p>像 pytorch 这种支持 CUDA 的程序，不会在链接的时候链接到 <code>libcuda</code> 上，而是在用户需要的时候，去 <code>dlopen</code>。这样即使用户的电脑上没有装 NVIDIA Driver，也可以运行支持 CUDA 的 pytorch。</p>
<h3 id="dynamic-linkerloader">dynamic linker/loader</h3>
<p>前文讲到，动态链接库参与链接的时候，实际上函数本身没有链接进可执行程序，最后的加载是由 dynamic linker/loader 完成的，在 linux 上是 ld.so，在 macOS 上是 dyld。它在程序启动的时候，负责根据 NEEDED 信息，知道程序要加载哪些动态库，然后去文件系统里找，如果找到了，就把相应的动态库加载到内存中，然后把可执行程序中对动态链接库的函数调用，变成真实的地址。相当于把原来静态链接的时候，链接器做的事情，挪到了程序运行开始时，即 linking at run time。</p>
<p>那么这里就涉及到一个问题了：NEEDED 只记录了文件名，但是却没有路径。这意味着动态库也需要用类似 PATH 的机制，在一些路径里去寻找一个想要的动态库。例如前文修改 <code>LD_LIBRARY_PATH</code>，实际上就是告诉 ld.so，可以在这个环境变量指向的路径中寻找动态库的文件。</p>
<p>而用系统包管理器安装的动态库，一般不需要修改 <code>LD_LIBRARY_PATH</code> 也可以用。这是靠 <code>/etc/ld.so.cache</code> 文件实现的。在动态库相关的问题里，经常会看到运行 <code>ldconfig</code> 命令。这个命令的用途是，收集系统目录里的动态库，建立一个索引，保存在 <code>/etc/ld.so.cache</code> 文件中。然后 ld.so 直接去 <code>/etc/ld.so.cache</code> 中寻找 NEEDED 的动态库对应的文件系统中的路径，不需要再重新扫描一遍目录了。所以 <code>/etc/ld.so.cache</code> 就是一个文件系统中动态库的缓存，这也就是为啥叫做 <code>ld.so.cache</code>。</p>
<p>既然是缓存，就要考虑缓存和实际对不上的情况，这就是为啥要运行 <code>ldconfig</code> 命令更新缓存。当然了，包管理器会自动运行 <code>ldconfig</code>，只有自己 <code>make install</code> 一些库的时候，才需要手动进行 <code>ldconfig</code>。</p>
<p><code>ldconfig</code> 会从 <code>/etc/ld.so.conf</code> 中配置的路径中扫描动态链接库，常见的路径包括：</p>
<ul>
<li>/lib/x86_64-linux-gnu</li>
<li>/usr/lib/x86_64-linux-gnu</li>
<li>/usr/local/lib</li>
<li>/usr/local/lib/x86_64-linux-gnu</li>
</ul>
<p>包管理器安装的动态库基本都在这些目录中。可以用 <code>ldconfig -p</code> 来查看缓存 <code>ld.so.cache</code> 的内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ /sbin/ldconfig -p
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1967</span> libs found in cache <span style="color:#e6db74">`</span>/etc/ld.so.cache<span style="color:#960050;background-color:#1e0010">&#39;</span>
</span></span><span style="display:flex;"><span>        libz3.so.4 <span style="color:#f92672">(</span>libc6,x86-64<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libz3.so.4
</span></span><span style="display:flex;"><span>        libz3.so <span style="color:#f92672">(</span>libc6,x86-64<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libz3.so
</span></span><span style="display:flex;"><span>        ld-linux.so.2 <span style="color:#f92672">(</span>ELF<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /lib/i386-linux-gnu/ld-linux.so.2
</span></span><span style="display:flex;"><span>        ld-linux.so.2 <span style="color:#f92672">(</span>ELF<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /lib32/ld-linux.so.2
</span></span><span style="display:flex;"><span>        ld-linux.so.2 <span style="color:#f92672">(</span>ELF<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /lib/ld-linux.so.2
</span></span><span style="display:flex;"><span>        ld-linux-x86-64.so.2 <span style="color:#f92672">(</span>libc6,x86-64<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
</span></span><span style="display:flex;"><span>        ld-linux-x32.so.2 <span style="color:#f92672">(</span>libc6,x32<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>&gt; /libx32/ld-linux-x32.so.2
</span></span></code></pre></div><p>维护了 soname 到文件系统中动态库文件的映射。并且添加了一些属性来帮助 ld.so 进行过滤和选择。</p>
<h3 id="rpath">rpath</h3>
<p>除了 LD_LIBRARY_PATH 和 <code>/etc/ld.so.cache</code>，ld.so 还可以通过 rpath 来寻找动态库。设想要打包一个 Qt 程序，希望在别人的机器上可以直接跑，但是别人的机器上不一定有 Qt，因此需要把程序和 Qt 的各种动态库打包在一起。但是，这时候 Qt 的动态库不会在系统路径中，不会被 <code>ldconfig</code> 索引。一种办法就是写一个脚本，设置一下 <code>LD_LIBRARY_PATH</code>，再启动 Qt 程序。另一种办法，就是利用 rpath：在程序中就告诉 ld.so 去哪里找它依赖（NEEDED）的动态库。这个路径可以是相对于可执行文件的路径。</p>
<p>设置 <code>rpath</code> 的方法是，编译的时候添加 <code>-Wl,-rpath,RPATH</code> 选项，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc main.c libtest.so.0.0.0 -o main
</span></span><span style="display:flex;"><span>$ ./main
</span></span><span style="display:flex;"><span>./main: error <span style="color:#66d9ef">while</span> loading shared libraries: libtest.so.0: cannot open shared object file: No such file or directory
</span></span><span style="display:flex;"><span>$ gcc main.c libtest.so.0.0.0 -Wl,-rpath,$PWD -o main
</span></span><span style="display:flex;"><span>$ ./main
</span></span><span style="display:flex;"><span>Simple <span style="color:#66d9ef">function</span>
</span></span><span style="display:flex;"><span>$ readelf -d main
</span></span><span style="display:flex;"><span>  Tag        Type                         Name/Value
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libtest.so.0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libc.so.6<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x000000000000001d <span style="color:#f92672">(</span>RUNPATH<span style="color:#f92672">)</span>            Library runpath: <span style="color:#f92672">[</span>/tmp<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>$ gcc main.c libtest.so.0.0.0 -Wl,-rpath,<span style="color:#e6db74">&#39;$ORIGIN&#39;</span> -o main
</span></span><span style="display:flex;"><span>$ ./main
</span></span><span style="display:flex;"><span>Simple <span style="color:#66d9ef">function</span>
</span></span><span style="display:flex;"><span>$ readelf -d main
</span></span><span style="display:flex;"><span>  Tag        Type                         Name/Value
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libtest.so.0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x0000000000000001 <span style="color:#f92672">(</span>NEEDED<span style="color:#f92672">)</span>             Shared library: <span style="color:#f92672">[</span>libc.so.6<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> 0x000000000000001d <span style="color:#f92672">(</span>RUNPATH<span style="color:#f92672">)</span>            Library runpath: <span style="color:#f92672">[</span>$ORIGIN<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>第一个编译命令不带 <code>rpath</code>，因此 ld.so 会找不到动态库，可以添加 LD_LIBRARY_PATH 的办法来解决。第二个和第三个编译命令带 <code>rpath</code>，其中第二个使用了绝对路径，第三个使用了相对路径（<code>$ORIGIN</code> 表示可执行文件所在的目录）。那么，ld.so 在寻找 libtest.so.0 的时候，会在 RUNPATH 中进行寻找。</p>
<h3 id="调试">调试</h3>
<p>动态链接经常会遇到各种找不到动态库的问题，需要使用一些工具来帮助找到问题。最常用的就是 <code>ldd</code> 命令，显示一个程序依赖的动态库以及路径：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ ldd <span style="color:#66d9ef">$(</span>which vim<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>        linux-vdso.so.1 <span style="color:#f92672">(</span>0x00007fff599a4000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libm.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libm.so.6 <span style="color:#f92672">(</span>0x00007f0504dfc000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libtinfo.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libtinfo.so.6 <span style="color:#f92672">(</span>0x00007f0504dc9000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libselinux.so.1 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libselinux.so.1 <span style="color:#f92672">(</span>0x00007f0504d9b000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libsodium.so.23 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libsodium.so.23 <span style="color:#f92672">(</span>0x00007f05049a6000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libacl.so.1 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libacl.so.1 <span style="color:#f92672">(</span>0x00007f0504d90000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libgpm.so.2 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libgpm.so.2 <span style="color:#f92672">(</span>0x00007f050499e000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libc.so.6 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libc.so.6 <span style="color:#f92672">(</span>0x00007f05047bd000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        /lib64/ld-linux-x86-64.so.2 <span style="color:#f92672">(</span>0x00007f0504f07000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libpcre2-8.so.0 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libpcre2-8.so.0 <span style="color:#f92672">(</span>0x00007f0504723000<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        libpthread.so.0 <span style="color:#f92672">=</span>&gt; /lib/x86_64-linux-gnu/libpthread.so.0 <span style="color:#f92672">(</span>0x00007f0504d89000<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>当然了，<code>ldd</code> 有一定的风险，不建议在不信任的程序上运行 <code>ldd</code>，详情见 <a href="https://man7.org/linux/man-pages/man1/ldd.1.html">ldd.1</a>。更稳妥的方法是用 <code>objdump -p</code> 或者 <code>readelf -d</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ objdump -p <span style="color:#66d9ef">$(</span>which vim<span style="color:#66d9ef">)</span> | grep NEEDED
</span></span><span style="display:flex;"><span>$ readelf -d <span style="color:#66d9ef">$(</span>which vim<span style="color:#66d9ef">)</span> | grep NEEDED
</span></span></code></pre></div><p>但是 ldd 可以打印出动态库依赖的动态库，而 objdump 和 readelf 只会打印直接依赖。也可以设置环境变量，让 ld.so 打印出加载的动态库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ export LD_DEBUG<span style="color:#f92672">=</span>files
</span></span><span style="display:flex;"><span>$ ./main
</span></span><span style="display:flex;"><span>   2243766:     file<span style="color:#f92672">=</span>libtest.so.0 <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;  needed by ./main <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>   2243766:     file<span style="color:#f92672">=</span>libtest.so.0 <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;  generating link map
</span></span><span style="display:flex;"><span>   2243766:       dynamic: 0x00007fcd57c23df8  base: 0x00007fcd57c20000   size: 0x0000000000004018
</span></span><span style="display:flex;"><span>   2243766:         entry: 0x00007fcd57c20000  phdr: 0x00007fcd57c20040  phnum:                  <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>   2243766:
</span></span><span style="display:flex;"><span>   2243766:     file<span style="color:#f92672">=</span>libc.so.6 <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;  needed by ./main <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>   2243766:     file<span style="color:#f92672">=</span>libc.so.6 <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;  generating link map
</span></span><span style="display:flex;"><span>   2243766:       dynamic: 0x00007fcd57bf1b60  base: 0x00007fcd57a20000   size: 0x00000000001e0f50
</span></span><span style="display:flex;"><span>   2243766:         entry: 0x00007fcd57a47350  phdr: 0x00007fcd57a20040  phnum:                 <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>   2243766:
</span></span><span style="display:flex;"><span>   2243766:     calling init: /lib64/ld-linux-x86-64.so.2
</span></span><span style="display:flex;"><span>   2243766:     calling init: /lib/x86_64-linux-gnu/libc.so.6
</span></span><span style="display:flex;"><span>   2243766:     calling init: /tmp/libtest.so.0
</span></span><span style="display:flex;"><span>   2243766:     initialize program: ./main
</span></span><span style="display:flex;"><span>   2243766:     transferring control: ./main
</span></span><span style="display:flex;"><span>   2243766:     calling fini: ./main <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>   2243766:     calling fini: /tmp/libtest.so.0 <span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Simple <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><h3 id="macos">macOS</h3>
<p>macOS 与 Linux 下动态库的使用方法基本类似，但有一些细微的差别。首先是 macOS 上的动态库的后缀用的是 dylib 而不是 so：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ gcc -fPIC -shared source1.c -o libtest.dylib
</span></span><span style="display:flex;"><span>$ gcc main.c libtest.dylib -o main
</span></span><span style="display:flex;"><span>$ objdump -t libtest.dylib
</span></span><span style="display:flex;"><span>libtest.dylib:  file format mach-o arm64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SYMBOL TABLE:
</span></span><span style="display:flex;"><span>0000000000003f7c g     F __TEXT,__text _simple_function
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>         *UND* _printf
</span></span><span style="display:flex;"><span>$ objdump -t main
</span></span><span style="display:flex;"><span>main:   file format mach-o arm64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SYMBOL TABLE:
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000100000000</span> g     F __TEXT,__text __mh_execute_header
</span></span><span style="display:flex;"><span>0000000100003f94 g     F __TEXT,__text _main
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span>         *UND* _simple_function
</span></span></code></pre></div><p>虽然这里用的是 gcc 命令，但实际上 macOS 上的 gcc 命令是 clang。这里直接用 clang 命令也是一样的。可以看到，这里的可执行文件中 <code>simple_function</code> 函数也是处于 undefined 状态，需要在运行时由 <code>libtest.dylib</code> 提供。</p>
<p>macOS 下的动态链接器是 dyld，它会解析 MachO 的 Load command 去加载动态库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ objdump -p main
</span></span><span style="display:flex;"><span>Load command <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>          cmd LC_LOAD_DYLIB
</span></span><span style="display:flex;"><span>      cmdsize <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>         name libtest.dylib <span style="color:#f92672">(</span>offset 24<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   time stamp <span style="color:#ae81ff">2</span> Thu Jan  <span style="color:#ae81ff">1</span> 08:00:02 <span style="color:#ae81ff">1970</span>
</span></span><span style="display:flex;"><span>      current version 0.0.0
</span></span><span style="display:flex;"><span>compatibility version 0.0.0
</span></span><span style="display:flex;"><span>Load command <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>          cmd LC_LOAD_DYLIB
</span></span><span style="display:flex;"><span>      cmdsize <span style="color:#ae81ff">56</span>
</span></span><span style="display:flex;"><span>         name /usr/lib/libSystem.B.dylib <span style="color:#f92672">(</span>offset 24<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   time stamp <span style="color:#ae81ff">2</span> Thu Jan  <span style="color:#ae81ff">1</span> 08:00:02 <span style="color:#ae81ff">1970</span>
</span></span><span style="display:flex;"><span>      current version 1319.100.3
</span></span><span style="display:flex;"><span>compatibility version 1.0.0
</span></span></code></pre></div><p>这就相当于 Linux 中的 NEEDED，告诉动态链接器要加载哪些动态库。可以用 <code>otool -L</code> 或者 <code>dyld_info</code> 命令列出可执行文件所有依赖的动态库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ otool -L main
</span></span><span style="display:flex;"><span>main:
</span></span><span style="display:flex;"><span>        libtest.dylib <span style="color:#f92672">(</span>compatibility version 0.0.0, current version 0.0.0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        /usr/lib/libSystem.B.dylib <span style="color:#f92672">(</span>compatibility version 1.0.0, current version 1319.100.3<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>$ dyld_info -dependents main
</span></span><span style="display:flex;"><span>main <span style="color:#f92672">[</span>arm64<span style="color:#f92672">]</span>:
</span></span><span style="display:flex;"><span>    -dependents:
</span></span><span style="display:flex;"><span>        attributes     load path
</span></span><span style="display:flex;"><span>                       libtest.dylib
</span></span><span style="display:flex;"><span>                       /usr/lib/libSystem.B.dylib
</span></span></code></pre></div><p>macOS 也提供了 rpath 的机制，在 <code>LC_LOAD_DYLIB</code> 中指定 <code>@rpath</code>，然后通过 <code>LC_RPATH</code> 指定有哪些 rpath，那么动态链接器就可以根据可执行文件的相对路径去寻找动态库：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ objdump -p /Applications/Visual<span style="color:#ae81ff">\ </span>Studio<span style="color:#ae81ff">\ </span>Code.app/Contents/MacOS/Electron
</span></span><span style="display:flex;"><span>Load command <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>          cmd LC_RPATH
</span></span><span style="display:flex;"><span>      cmdsize <span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span>         path @executable_path/../Frameworks <span style="color:#f92672">(</span>offset 12<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Load command <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>          cmd LC_LOAD_DYLIB
</span></span><span style="display:flex;"><span>      cmdsize <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>         name @rpath/Electron Framework.framework/Electron Framework <span style="color:#f92672">(</span>offset 24<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   time stamp <span style="color:#ae81ff">0</span> Thu Jan  <span style="color:#ae81ff">1</span> 08:00:00 <span style="color:#ae81ff">1970</span>
</span></span><span style="display:flex;"><span>      current version 22.5.2
</span></span><span style="display:flex;"><span>compatibility version 0.0.0
</span></span><span style="display:flex;"><span>Load command <span style="color:#ae81ff">14</span>
</span></span><span style="display:flex;"><span>          cmd LC_LOAD_DYLIB
</span></span><span style="display:flex;"><span>      cmdsize <span style="color:#ae81ff">56</span>
</span></span><span style="display:flex;"><span>         name /usr/lib/libSystem.B.dylib <span style="color:#f92672">(</span>offset 24<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   time stamp <span style="color:#ae81ff">0</span> Thu Jan  <span style="color:#ae81ff">1</span> 08:00:00 <span style="color:#ae81ff">1970</span>
</span></span><span style="display:flex;"><span>      current version 1311.100.3
</span></span><span style="display:flex;"><span>$ otool -L /Applications/Visual<span style="color:#ae81ff">\ </span>Studio<span style="color:#ae81ff">\ </span>Code.app/Contents/MacOS/Electron
</span></span><span style="display:flex;"><span>/Applications/Visual Studio Code.app/Contents/MacOS/Electron:
</span></span><span style="display:flex;"><span>        @rpath/Electron Framework.framework/Electron Framework <span style="color:#f92672">(</span>compatibility version 0.0.0, current version 22.5.2<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        /usr/lib/libSystem.B.dylib <span style="color:#f92672">(</span>compatibility version 1.0.0, current version 1311.100.3<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>也可以让 dyld 动态打印日志：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ export DYLD_PRINT_LIBRARIES<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$ ./main
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;F4E9A9E0-E958-3D0C-8D5A-7DC3ABA8E8C4&gt; /Volumes/Data/temp/main
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;DD5E30FB-753D-3746-8034-50C56971C47B&gt; /Volumes/Data/temp/libtest.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;4BEBCD61-9E62-39BE-BFD2-C7D0689A826D&gt; /usr/lib/libSystem.B.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;FEA038BA-CC59-3085-93B0-AB8437AA6CE2&gt; /usr/lib/system/libcache.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;34AC4B05-E145-3C58-8C24-1190770EAB31&gt; /usr/lib/system/libcommonCrypto.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;1D6552C4-49C4-374F-8371-198BCFC4174D&gt; /usr/lib/system/libcompiler_rt.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;E61C2838-9EA2-33CE-B96B-85FF38DB7744&gt; /usr/lib/system/libcopyfile.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;4A9F9101-A1B1-3FB7-89EA-746CFCE95099&gt; /usr/lib/system/libcorecrypto.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;C2FD3094-B465-39A4-B774-16583FF53C4B&gt; /usr/lib/system/libdispatch.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;A2947B47-B494-36D4-96C6-95977FFB51FB&gt; /usr/lib/system/libdyld.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;C4512BA5-7CA3-30AE-9793-5CC5417F0FC3&gt; /usr/lib/system/libkeymgr.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;91A88FDF-FD27-32AF-A2CE-70F7E4065C3B&gt; /usr/lib/system/libmacho.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;A2D17FF6-CBC6-3D19-89E1-F5E57191E8A3&gt; /usr/lib/system/libquarantine.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;2213EE66-253B-3234-AA4D-B46F07C3540E&gt; /usr/lib/system/libremovefile.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;68D76774-F8B4-36EA-AA35-0AB4044D56C7&gt; /usr/lib/system/libsystem_asl.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;5541DF62-A795-3F57-A54C-1AEC4DD3E44C&gt; /usr/lib/system/libsystem_blocks.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;95A70E20-1DF3-3DDF-900C-315ED0B2C067&gt; /usr/lib/system/libsystem_c.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;BEB9DE52-6F49-370A-B45B-CBE6780E7083&gt; /usr/lib/system/libsystem_collections.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;121F8B4D-3939-300D-BE22-979D6B476361&gt; /usr/lib/system/libsystem_configuration.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;7CE9526A-B673-363A-8905-71D080974C0E&gt; /usr/lib/system/libsystem_containermanager.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;54BF691A-0908-3548-95F2-34CFD58E5617&gt; /usr/lib/system/libsystem_coreservices.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;579733C7-851D-3B3E-83B5-FD203BA50D02&gt; /usr/lib/system/libsystem_darwin.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;4EFF0147-928F-3321-8268-655FE71DC209&gt; /usr/lib/system/libsystem_dnssd.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;5068382F-DC0F-3824-8ED5-18A24B35FEF9&gt; /usr/lib/system/libsystem_featureflags.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;4448FB99-7B1D-3E15-B7EE-3340FF0DA88D&gt; /usr/lib/system/libsystem_info.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;82E529F5-C4DF-3D42-9113-3A4F87FEF1A0&gt; /usr/lib/system/libsystem_m.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;0AC99C6E-CB01-30E5-AB10-65AB990652A5&gt; /usr/lib/system/libsystem_malloc.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;3B2CC4A9-A5EE-3627-8293-4AF4D891074E&gt; /usr/lib/system/libsystem_networkextension.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;E4AA6E5F-2501-3382-BFB3-64464E6D8254&gt; /usr/lib/system/libsystem_notify.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;99FDEFF2-36F1-3436-B8B2-DE0003B5A4BF&gt; /usr/lib/system/libsystem_sandbox.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;E529D1AC-D20A-3308-9033-E1712A9C655E&gt; /usr/lib/system/libsystem_secinit.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;42F503E2-9273-360A-A086-C1B19BBD3962&gt; /usr/lib/system/libsystem_kernel.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;F80C6971-C080-31F5-AB6E-BE01311154AF&gt; /usr/lib/system/libsystem_platform.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;46D35233-A051-3F4F-BBA4-BA56DDDC4D1A&gt; /usr/lib/system/libsystem_pthread.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;F9F1F4BE-D97F-37A7-8382-552C22DF1BB4&gt; /usr/lib/system/libsystem_symptoms.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;3F3E75B7-F0A7-30BB-9FD7-FD1307FE6055&gt; /usr/lib/system/libsystem_trace.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;E3BF7A76-2CBE-3DB9-8496-8BB6DBBE0CFC&gt; /usr/lib/system/libunwind.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;F3F19227-FF8F-389C-A094-6F4C16E458AF&gt; /usr/lib/system/libxpc.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;52AA13E2-567C-36C2-9494-7B892FDBF245&gt; /usr/lib/libc++abi.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;5BEAFA2B-3AF4-3ED2-B054-1F58A7C851EF&gt; /usr/lib/libobjc.A.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;FB664621-26AE-3F46-8F5A-DD5D890A5CE7&gt; /usr/lib/liboah.dylib
</span></span><span style="display:flex;"><span>dyld<span style="color:#f92672">[</span>17486<span style="color:#f92672">]</span>: &lt;54E8FBE1-DF0D-33A2-B8FA-356565C12929&gt; /usr/lib/libc++.1.dylib
</span></span><span style="display:flex;"><span>Simple <span style="color:#66d9ef">function</span>
</span></span></code></pre></div><p>与 Linux 上的 <code>/etc/ld.so.cache</code> 类似，macOS 也针对动态库的加载做了优化，但是 macOS 做的更彻底：由于 macOS 的系统库是只读的，于是直接把所有系统库打包成一个文件，这个文件就是 dyld shared cache。可以用 <a href="https://github.com/keith/dyld-shared-cache-extractor">keith/dyld-shared-cache-extractor</a> 来还原出内部的 dylib。在 macOS Ventura 13.4 中，可以解出 2499 个动态库。</p>
<h2 id="relocation">relocation</h2>
<p>链接器找到符号以后，就需要进行 relocation。在编译的时候，为了准备未来链接时的需要，提前做了一些准备：因为符号的地址还不知道，所以生成一条指令，指令的立即数内包括了符号的地址的信息，但此时还不知道立即数应该是多少，所以编译器把指令的立即数填充为 0，同时生成一个 relocation。当链接器看到 relocation 的时候，在已经排好所有符号的地址的时候，就可以按照 relocation 更新代码。</p>
<p>由于动态链接库可能会被加载到不同的基地址上，所以为了解决动态链接库内部的符号链接问题，采用 PIC 的方法，即通过指令本身的地址进行相对运算，计算出另一个符号的地址。这样动态链接库加载到不同地址的时候，内部的符号之间都可以正常引用，不需要修改指令，使得动态库可以在不同的进程间共享。</p>
<p>但是还需要考虑动态链接库使用了其他动态链接库的符号（全局变量）。这个时候，PIC 的方法失效了，因为无法确定其他动态链接库会加载到什么地址。此时的解决办法是用 GOT，程序在引用符号的时候，去 GOT 里查找实际的地址。动态链接器负责填 GOT 表的内容，这样动态库本身还是不会修改，只会修改 GOT。</p>
<p>如果动态链接库调用了其他动态链接库的函数，也可以用类似的方法，但是实践起来稍有不同。函数也在 GOT 表的 PLT 表里有实际的地址，但动态链接库不会自动替换，而是让编译器生成一个 PLT stub。PLT stub 做的事情是：</p>
<ol>
<li>如果初始化过，那么直接跳转到实际的函数</li>
<li>如果没有初始化过，调用 ld.so 提供的函数，函数会找到实际的函数，并且对 PLT 进行初始化</li>
</ol>
<p>这一系列的做法都是为了让动态库的大部分内容保持不变，只修改少部分数据使得 relocation 可以工作。完整的内容建议阅读<a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">PLT and GOT - the key to code sharing and dynamic libraries</a>。</p>
<h3 id="relocation-truncated-to-fit">relocation truncated to fit</h3>
<p>常见的 <code>relocation truncated to fit</code> 错误的意思是，链接器在进行 relocation 的时候，无法把想要的值填入到编译器预留的立即数里面。这是因为，编译器在编译的时候，其实不知道偏移具体是多少，那么这时候就可以选择用不同的指令序列，有的指令序列比较短，但是立即数位数也比较少；有的指令序列比较长，但是可以访问更大范围的偏移。如果编译器选择了比较小的范围，但是链接器链接的时候，发现放不下，就会出现 <code>relocation truncated to fit</code> 的错误。</p>
<p>解决方法，一是查看是否真的有那么大的偏移，例如是否不小心分配了一个超级大的全局数组，是的话是否砍掉一些大小；二是修改 Code Model，也就是让编译器选择更大的 Code Model，以更长的指令的代价，支持更大范围的 relocation。完整内容推荐阅读 <a href="https://maskray.me/blog/2023-05-14-relocation-overflow-and-code-models">Relocation overflow and code models by MaskRay</a>。</p>

        </div>

        
        
        <div class="article-toc" style="display:none;">
            <h3>Contents</h3>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#背景">背景</a></li>
    <li><a href="#编译">编译</a></li>
    <li><a href="#链接">链接</a></li>
    <li><a href="#静态库">静态库</a></li>
    <li><a href="#动态库">动态库</a>
      <ul>
        <li><a href="#符号版本">符号版本</a></li>
        <li><a href="#动态链接">动态链接</a></li>
        <li><a href="#soname">soname</a></li>
        <li><a href="#cuda">cuda</a></li>
        <li><a href="#dynamic-linkerloader">dynamic linker/loader</a></li>
        <li><a href="#rpath">rpath</a></li>
        <li><a href="#调试">调试</a></li>
        <li><a href="#macos">macOS</a></li>
      </ul>
    </li>
    <li><a href="#relocation">relocation</a>
      <ul>
        <li><a href="#relocation-truncated-to-fit">relocation truncated to fit</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
        
        

        

        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
        <script>
            (function() {
                var $toc = $('#TableOfContents');
                if ($toc.length > 0) {
                    var $window = $(window);

                    function onScroll(){
                        var currentScroll = $window.scrollTop();
                        var h = $('.article-entry h1, .article-entry h2, .article-entry h3, .article-entry h4, .article-entry h5, .article-entry h6');
                        var id = "";
                        h.each(function (i, e) {
                            e = $(e);
                            if (e.offset().top - 10 <= currentScroll) {
                                id = e.attr('id');
                            }
                        });
                        var active = $toc.find('a.active');
                        if (active.length == 1 && active.eq(0).attr('href') == '#' + id) return true;

                        active.each(function (i, e) {
                            $(e).removeClass('active').siblings('ul').hide();
                        });
                        $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                            $(e).children('a').addClass('active').siblings('ul').show();
                        });
                    }

                    $window.on('scroll', onScroll);
                    $(document).ready(function() {
                        $toc.find('a').parent('li').find('ul').hide();
                        onScroll();
                        document.getElementsByClassName('article-toc')[0].style.display = '';
                    });
                }
            })();
        </script>
        


        
        <footer class="article-footer">
            <ul class="article-tag-list">
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/linker">linker
                    </a>
                </li>
                
                <li class="article-tag-list-item">
                    <a class="article-tag-list-link" href="/tags/ld">ld
                    </a>
                </li>
                
            </ul>
        </footer>
        
    </div>
    
<nav id="article-nav">
    
    <a href="/software/2023/05/06/linux-regression-vivado/" id="article-nav-newer" class="article-nav-link-wrap">
        <div class="article-nav-title"><span>&lt;</span>&nbsp;
            Linux 6.2.13 引入的 BUG 导致 Vivado 无法识别 FPGA
        </div>
    </a>
    
    
    <a href="/hardware/2023/05/03/i2c/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">I2C 协议&nbsp;<span>&gt;</span></div>
    </a>
    
</nav>


</article>

        
            <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "jiegec" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
    </section>
    <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2023 杰哥的{运维,编程,调板子}小笔记
            <br />
            Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/carsonip/hugo-theme-minos" target="_blank">Minos</a>
        </div>
    </div>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3109FRSVTT"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-3109FRSVTT', { 'anonymize_ip': false });
}
</script>


    
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
        <script>renderMathInElement(document.body);</script>
    
    <script>
        document.getElementById('main-nav-toggle').addEventListener('click', function () {
            var header = document.getElementById('header');
            if (header.classList.contains('mobile-on')) {
                header.classList.remove('mobile-on');
            } else {
                header.classList.add('mobile-on');
            }
        });
    </script>
</footer>

</div>
</body>
</html>
