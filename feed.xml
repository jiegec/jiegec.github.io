<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jiajie Chen's blog</title>
    <description>This is the personal blog of Jiajie Chen, a NANO(uNix hAcker aNd lOver).
</description>
    <link>https://jiegec.github.io/</link>
    <atom:link href="https://jiegec.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 06 May 2018 14:40:28 +0800</pubDate>
    <lastBuildDate>Sun, 06 May 2018 14:40:28 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>使用 iptables 和策略路由进行带源地址的 forwarding</title>
        <description>&lt;p&gt;陈老师打开他的服务器，突然发现 CPU 莫名高负载，然后发现是有一个用户被远程登录拿来挖矿了。但是这台机器在 NAT 后，所以登录的源地址全是 NAT 路由，所以不知道对方的地址是什么。我们为了能使用 fail2ban 来禁用多次尝试失败的 IP ，但又不想因为别人把 NAT 路由的地址给禁了，这样我们自己也用不了了。所以必须要让这台机器能够知道 ssh 的源地址，我们现在简单的 socat 方案不能满足这个需求。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以在外网连 NAT 路由的高端口（如2222）来访问这台机器。&lt;/li&gt;
  &lt;li&gt;在内网中，既可以直接连它的内网地址，也可以连 NAT 路由的高端口来访问这台服务器。此时，由于连 ssh 的机器就在同一个子网中，如果保留了源地址，服务器发的包会直接回来不经过 NAT 。所以我们还是保留了 socat 的方案。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现方法：&lt;/p&gt;

&lt;p&gt;在 NAT Router 上配置 DNAT ，这样发到 NAT Router 上的包就可以转发到服务器上：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; nat &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; external_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 2222 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; internal_server_ip:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，从服务器回来的包到了 NAT Router 上后，由于路由表的配置问题，默认的路由并不能把包送达对方。所以，我们首先给包打上 mark：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; mangle &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; internal_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--sport&lt;/span&gt; 22 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; MARK &lt;span class=&quot;nt&quot;&gt;--set-mark&lt;/span&gt; 0x2222
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后配置策略路由：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip rule add fwmark 0x2222 table 2222
ip route add table 2222 default via gateway_address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以保证 ssh 的回包可以原路返回了。&lt;/p&gt;

&lt;p&gt;由于前面提到的原因，上面我们配置的 DNAT 规则只对外网过来的包有效。为了内网的访问，我们仍然采用了 socat 的方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socat TCP-LISTEN:2222,reuseaddr,fork TCP:internal_server_ip:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从不同的机器测试，都可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;who&lt;/code&gt; 看到，地址确实是我们想看到的源地址。接下来配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;fail2ban &lt;/code&gt;即可。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 May 2018 14:07:00 +0800</pubDate>
        <link>https://jiegec.github.io/networking/2018/05/06/nat-forwarding-with-src-address/</link>
        <guid isPermaLink="true">https://jiegec.github.io/networking/2018/05/06/nat-forwarding-with-src-address/</guid>
        
        <category>linux</category>
        
        <category>nat</category>
        
        <category>forwarding</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>利用 UPnP 协议进行 mosh NAT 穿透的研究</title>
        <description>&lt;p&gt;由于经常要从宿舍、教室等不同的 Wi-Fi 之间切换，但是 ssh 连接又总是断，所以想用 mosh 代替 ssh 。但是 mosh 也有它的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不能滚动。这个可以在 mosh 中嵌套一层 tmux 解决。我目前写了一些自动 mosh 后打开 tmux 并且开启鼠标支持的脚本，但还是有缺陷。&lt;/li&gt;
  &lt;li&gt;在高端口 60000+ 监听 UDP ，这使得 NAT 后的服务器难以直接通过端口转发。如果直接转发到 NAT 后的机器，那么 NAT 后面如果有多台机器，这又失效了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是找了找网上的 NAT 穿透的一些文章，看到了 UPnP 的方法。大致就是，用户可以向路由器注册一个临时的转发规则，路由会自动在 iptables 上配置转发。但是，这样也会遇到一个问题：路由上的 mosh-server 不知道这个转发的存在，所以它可能会尝试监听同样的端口。解决方案下面会提到。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server &amp;lt;---&amp;gt; NAT Router &amp;lt;---&amp;gt; My Laptop
On NAT Router, port 8022 is forwarded to Server:22
1. mosh router # works
2. mosh --ssh=&quot;ssh -p 8022&quot; router # works
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先在 NAT Router 上配置 miniupnpd （以 Debian 为例）&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install miniupnpd
&lt;span class=&quot;c&quot;&gt;# you will get a dialog upon installation&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# input your wan interface and listening ip accordingly&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim /etc/default/miniupnpd
&lt;span class=&quot;c&quot;&gt;# edit START_DAEMON=0 to START_DAEMON=1&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim /etc/miniupnpd/miniupnpd.conf
&lt;span class=&quot;c&quot;&gt;# edit ext_ifname, listening_ip accordingly&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# set secure_mode=yes&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# add 'allow 60000-60023 internal_ip/prefix 60000-60023'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# before the last line 'deny 0-65535 0.0.0.0/0 0-65535'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; miniupnpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，复制 &lt;a href=&quot;https://github.com/jiegec/mosh-upnp-hole-puncher/blob/master/mosh-wrapper.js&quot;&gt;我修改的mosh-wrapper.js&lt;/a&gt; 到用户的 home 目录下，在 Server 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpc&lt;/code&gt; 然后通过：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mosh &lt;span class=&quot;nt&quot;&gt;--ssh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ssh -p 8022&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/mosh-wrapper.js user@router
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样， mosh 首先会通过 ssh 和 Server 协商一个 AES 的密钥和 UDP 端口（如 60001 ），之后的通信都通过 UDP 端口走加密后的流量。我的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-wrapper.js&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpc&lt;/code&gt; 向路由器请求把该 UDP 端口转发到 Server 上，这样， &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 就能通过 NAT 路由穿透到后面的 Server 上。&lt;/p&gt;

&lt;p&gt;等会！问题来了：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 默认的 IP 范围是 &lt;code class=&quot;highlighter-rouge&quot;&gt;60000-61000&lt;/code&gt; ，根据我的观察，它会从 60001 开始尝试监听本机地址，如果已经被占用，则 60002, 60003, … 但是！Router 和 Server 实际上占用了相同的端口空间，并且 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 只知道本机哪些端口被占用了，而不知道 Router 和 Server 共同占用了多少端口。&lt;/p&gt;

&lt;p&gt;我想到了一些可能的解决方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 Router 上让 miniupnpd 监听对应的端口，占住这个坑。这样，Router 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 就不会用和 Server 相同的端口&lt;/li&gt;
  &lt;li&gt;如果有多个 Server ，则会出现抢夺相同端口的情况。我目前的想法是，让 &lt;code class=&quot;highlighter-rouge&quot;&gt;upnpc&lt;/code&gt; 去询问 Router 找空闲的端口，然后再传给 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 使用。另一种方法则是，给不同的 Server 划分不同的端口范围，比如 Router 用 60001-60005, 然后 Server1 用 60006-60010, Server2 用 60011-60015 如此下去。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后，新的问题又发现了：&lt;/p&gt;

&lt;p&gt;当我在和 Server 同一个子网的时候，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpd&lt;/code&gt; 配置的 &lt;code class=&quot;highlighter-rouge&quot;&gt;iptables&lt;/code&gt; 规则中来源只有 WAN interface ，所以我在内网发的包是不会被转发的。当然，既然在内网了，为啥不直接用内网 IP 呢，不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 有没有提供设置备用 IP 的功能。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 May 2018 20:25:00 +0800</pubDate>
        <link>https://jiegec.github.io/networking/2018/05/05/mosh-behind-nat-with-upnp/</link>
        <guid isPermaLink="true">https://jiegec.github.io/networking/2018/05/05/mosh-behind-nat-with-upnp/</guid>
        
        <category>nat</category>
        
        <category>mosh</category>
        
        <category>upnp</category>
        
        <category>miniupnpd</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>在 Archlinux 上用 winbind 配合 pam 配置 Windows AD 认证登录</title>
        <description>&lt;p&gt;作为不清真的网络管理员，为了配置一套完整的统一认证系统，陈老师采用了 Windows AD 的方法给这里配置统一认证。重装了系统，自然要把之前的统一认证再配到新装的 Archlinux 上。&lt;/p&gt;

&lt;p&gt;参考资料： &lt;a href=&quot;https://wiki.archlinux.org/index.php/Active_Directory_Integration&quot;&gt;Active Directory Integration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先安装相应的包：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pacman &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; samba
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们还没有配好 Kerberos，所以跳过。&lt;/p&gt;

&lt;p&gt;然后配置 /etc/samba/smb.conf ，以下是一个例子。可以根据文档微调。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[global]
        security = ads
        realm = YOUR-AD-HERE
        workgroup = YOUR-GROUP-HERE
        idmap uid = 10000-20000
        idmap gid = 10000-20000
        winbind enum users = yes
        winbind enum groups = yes
        template homedir = /home/%D/%U
        template shell = /bin/bash
        client use spnego = yes
        client ntlmv2 auth = yes
        encrypt passwords = yes
        winbind use default domain = yes
        restrict anonymous = 2

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，域上的用户 user 会拿到 home 目录为 /home/YOUR-DOMAIN-HERE/user ，uid 在 10000-2000范围内的用户。在一会经过配置之后，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;getent passwd&lt;/code&gt; 验证。&lt;/p&gt;

&lt;p&gt;接下来，需要把本机的 samba 登入到域的管理员，并且启动服务。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net ads join &lt;span class=&quot;nt&quot;&gt;-U&lt;/span&gt; your-user-name
systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; smb
systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; nmb
systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; winbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;更改 /etc/nsswitch.conf ，在 passwd, shadow 和 group 都增添 winbind ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;passwd: files mymachines systemd winbind
group: files mymachines systemd winbind
shadow: files winbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来，可以进一步验证配置是否正确：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wbinfo &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;
wbinfo &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;
getent passwd
getent group
net ads info
net ads lookup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来可以配置 PAM 了。这一部分踩到了一些坑，现在终于做得差不多了。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果一个用户名既有本地用户也有域上的用户，选择前者&lt;/li&gt;
  &lt;li&gt;用户要修改密码的话，如果是域用户，则要求走 Windows AD 那套方法改密码；否则仅修改本地用户密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;修改 /etc/pam.d/system-auth:&lt;/p&gt;

&lt;p&gt;第一部分： auth&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auth [success=1 default=ignore]         pam_localuser.so
auth [success=2 default=die]            pam_winbind.so krb5_auth krb5_ccache_type=FILE cached_login try_first_pass
auth [success=1 default=die]            pam_unix.so nullok_secure
auth requisite                          pam_deny.so
auth optional                           pam_permit.so
auth required                           pam_env.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先利用 pam_localuser.so 匹配用户名和 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt; ，如果有， &lt;code class=&quot;highlighter-rouge&quot;&gt;success=1&lt;/code&gt; 代表跳过下面一条规则，故会跳到 pam_unix.so 这一行。如果失败，&lt;code class=&quot;highlighter-rouge&quot;&gt;default=ignore&lt;/code&gt; 表示忽略它的结果。如果是本地用户，匹配 pam_localuser.so 成功后跳到 pam_unix.so ，如果成功了则跳到第五行， pam_permit.so 代表通过，最后由 pam_env.so 配置环境变量。如果是域用户，则由 pam_winbind.so 处理，如果成功，同样跳到第 5 条。如果本地用户和域用户都失败，就 pam_deny.so 认证失败。&lt;/p&gt;

&lt;p&gt;第二部分：account&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;account required                        pam_unix.so
account [success=1 default=ignore]      pam_localuser.so
account required                        pam_winbind.so
account optional                        pam_permit.so
account required                        pam_time.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这一部分仍有疑问。留待以后来补充。&lt;/p&gt;

&lt;p&gt;第三部分：password&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;password [success=1 default=ignore]     pam_localuser.so
password [default=die]                  pam_echo.so file=/etc/pam.d/messages/ad_reject_change_passwd.txt
password optional                       pam_echo.so file=/etc/pam.d/messages/local_user_passwd.txt
password [success=1 default=die]        pam_unix.so sha512 shadow
password requisite                      pam_deny.so
password optional                       pam_permit.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里实现了我们的需求：如果是本地用户，提醒用户当前要修改的是本地用户的密码；如果是域用户，则输出信息后直接拒绝。&lt;/p&gt;

&lt;p&gt;这里的 /etc/pam.d/messages/ad_reject_change_passwd.txt 内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi %u, please go to xxxxxxx to change your Active Directory password!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第四部分：session&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-int&quot;&gt;session   required                      pam_limits.so
session   required                      pam_mkhomedir.so skel=/etc/skel/ umask=0022
session   required                      pam_unix.so
session   [success=1 default=ignore]    pam_localuser.so
session   required                      pam_winbind.so
session   optional                      pam_permit.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里与 Wiki 上内容无异。&lt;/p&gt;

&lt;p&gt;然后修改 /etc/pam.d/passwd :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;password        required        pam_cracklib.so difok=2 minlen=8 dcredit=2 ocredit=2 retry=3
password        include         system-auth
#password       requisite       pam_deny.so
#password       required        pam_unix.so sha512 shadow nullok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先判断密码强度。通过后则直接用刚才更改的 system-auth 中的 password 部分规则。&lt;/p&gt;

&lt;p&gt;这样就配好了认证。自己对这套东西的理解还不够深，以后遇到了要继续钻研。&lt;/p&gt;

&lt;p&gt;扩展阅读： &lt;a href=&quot;https://innull.com/pam-configuration-how-to/&quot;&gt;PAM 配置简介 - 王邈&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 05 May 2018 15:39:00 +0800</pubDate>
        <link>https://jiegec.github.io/system/2018/05/05/windows-ad-linux-pam/</link>
        <guid isPermaLink="true">https://jiegec.github.io/system/2018/05/05/windows-ad-linux-pam/</guid>
        
        <category>windows</category>
        
        <category>ad</category>
        
        <category>pam</category>
        
        <category>winbind</category>
        
        <category>samba</category>
        
        
        <category>system</category>
        
      </item>
    
      <item>
        <title>在服务器上安装 Archlinux 记录</title>
        <description>&lt;p&gt;有一台服务器的 Ubuntu 挂了，我们想在上面重装一个 Archlinux 。我们首先下载了 archlinux-2018.04.01 的 ISO, 直接 dd 到 U 盘上，但是遇到了问题。&lt;/p&gt;

&lt;p&gt;首先遇到的问题是，一启动之后就会花屏。我们一开始怀疑是 NVIDIA 驱动的问题，于是想改 kernel param 但是发现，这个 ISO 是 hybrid 的，我们在 macOS 和 Windows 上都不能 mount 上这种类型的盘。于是我们选择自己搞分区表。我们把 U 盘插到电脑上，然后在 Linux 虚拟机内重新分区为 GPT ，然后 mount 到 /mnt/usb ，再重新下载 archlinux iso ，不过此时刚好上游更新了 archlinux-2018.05.01 的影响。我们把 ISO 中根分区 mount 到 /mnt/iso 上来，然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;cp -a /mnt/iso/* /mnt/usb&lt;/code&gt; 。调整了 grub 中的内核参数，仍然无果。我们认为问题可能在显卡上，就把那张显卡拔下来了，果然显示就正常了，但是新的问题就来了。&lt;/p&gt;

&lt;p&gt;一启动， fstab 尝试把 LABEL=ARCHISO_201805 挂在上来，但是失败。于是我们把 U 盘插到 mac 上，用 Disk Utility 给分区命了名，再插回去，然后这个 Live CD 的 Systemd 就成功起来了。接下来就是根据官方的 Installation Guide 进行安装各种东西。安装完后，在 /boot/EFI 的操作上也出现了一些问题，一开始忘记调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;grub-mkconfig&lt;/code&gt; ，导致重启以后进入 grub-rescue ，所以又回到 Live CD 重新 &lt;code class=&quot;highlighter-rouge&quot;&gt;grub-mkconfig&lt;/code&gt;  。同时对 systemd-networkd 也进行了相应的调整，这样开机以后可以配好网络。主要就是在网卡上配上两个 VLAN 和相应的 DHCP 和静态地址。&lt;/p&gt;

&lt;p&gt;接下来对以前的东西进行迁移。主要就是按照十分详细的 Arch Wiki 进行相应的配置。由于空间所限，我们把原来的 home 目录直接 mount –bind 到 /home ，但是不可避免地，会出现用户 id 不对应的问题。于是我们把需要用到的用户的 /etc/{passwd,group,shadow} 统统拷贝到新的系统的相应地方。然后是配置 winbind ，就是按部就班地按照 Arch Wiki 和以前的配置进行更新，然后成功地把 AD 上的用户获取到。此时再次出现了 uid 不对应的问题，此时我们使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;chown -R user:user /home/user&lt;/code&gt; 的方法。&lt;/p&gt;

&lt;p&gt;剩下的工作就是琐碎的安装各种常用软件。不必多说。&lt;/p&gt;

&lt;p&gt;P.S. 我研究出了一个很好用的 mosh + tmux 的 fish function: (但是有时工作有时不工作，不明白什么回事)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function tmosh
    mosh $argv -- bash -c 'tmux new-session fish -C \'tmux set -g mouse on\' -C \'tmux setw -g mode-keys vi\''
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 01 May 2018 16:46:00 +0800</pubDate>
        <link>https://jiegec.github.io/system/2018/05/01/installing-arch-experience/</link>
        <guid isPermaLink="true">https://jiegec.github.io/system/2018/05/01/installing-arch-experience/</guid>
        
        <category>arch</category>
        
        <category>boot</category>
        
        <category>EFI</category>
        
        <category>fat32</category>
        
        
        <category>system</category>
        
      </item>
    
      <item>
        <title>使用 Cisco AC + AP 组合搭建网络实践</title>
        <description>&lt;p&gt;有一台已配置好直接可用的 AC 在地址 ac-address 。我们需要搭建交换机 + AP 的网络，并且用一台 Linux 服务器进行 DHCP 从而给 AP 分发 AC 的地址。这里以 systemd-networkd 为例。&lt;/p&gt;

&lt;p&gt;我们约定，vlan 2 上联外网， vlan 3 为 Linux 服务器和 AP 的内部网络。&lt;/p&gt;

&lt;p&gt;接下来，配置交换机给 Linux 服务器的端口为 trunk 口，然后将下联 Cisco AP 的端口都设为 access vlan 3 模式。接下来在 Linux 服务器上配置 DHCP 服务器和 NAT 。&lt;/p&gt;

&lt;p&gt;如果 Linux 服务器的 interface 名称为 eno1 :&lt;/p&gt;

&lt;p&gt;配置两个 VLAN interface:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.network
[Match]
Name=eno1

[Network]
VLAN=eno1.2
VLAN=eno1.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相应添加 VLAN 配置：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.2.network
[NetDev]
Name=eno1.2

[VLAN]
Id=2
$ cat /etc/systemd/network/eno1.3.network
[NetDev]
Name=eno1.3

[VLAN]
Id=3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置上行的 eno1.2 interface 的静态地址：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.2.network
[Match]
Name=eno1.2

[Network]
Address=123.123.123.123/24
Gateway=123.123.123.1
DNS=1.2.4.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置内部网络 eno1.3 interface:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.3.network
[Match]
Name=eno1.3

[Network]
Address=192.168.1.1/24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置 dhcpd (isc-dhcp-server):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/dhcpd.conf
option space Cisco_LWAPP_AP;
option Cisco_LWAPP_AP.server-address code 241 = array of ip-address;

subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.100 192.168.1.200;
  option routers 192.168.1.1;
  vendor-option-space Cisco_LWAPP_AP;
  option Cisco_LWAPP_AP.server-address $ac-address;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置 iptables 做NAT:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -o eno1.2 -j MASQUERADE
iptables-save &amp;gt; /etc/iptables/iptables.rules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打开 ipv4 forwarding:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo 'net.ipv4.conf.all.forwarding=1' &amp;gt;&amp;gt; /etc/sysctl.d/99-ipv4-forwarding.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 28 Apr 2018 21:58:00 +0800</pubDate>
        <link>https://jiegec.github.io/networking/2018/04/28/wifi-with-cisco-ac-and-ap/</link>
        <guid isPermaLink="true">https://jiegec.github.io/networking/2018/04/28/wifi-with-cisco-ac-and-ap/</guid>
        
        <category>cisco</category>
        
        <category>wifi</category>
        
        <category>vlan</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>把 GDB 降级到 8.0.1</title>
        <description>&lt;p&gt;在 macOS 上使用 GDB 需要 codesigning 。但是在 GDB 升级到 8.1 后这种方法不知道为何失效了。所以我安装回了 GDB 8.0.1 并且重新 codesigning ，现在又可以正常升级了。&lt;/p&gt;

&lt;p&gt;对 Formula 进行 patch：&lt;/p&gt;

&lt;div class=&quot;language-patch highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/Formula/gdb.rb b/Formula/gdb.rb
index 29a1c590..25360893 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/Formula/gdb.rb
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/Formula/gdb.rb
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -1,14 +1,15 @@
&lt;/span&gt; class Gdb &amp;lt; Formula
   desc &quot;GNU debugger&quot;
   homepage &quot;https://www.gnu.org/software/gdb/&quot;
&lt;span class=&quot;gd&quot;&gt;-  url &quot;https://ftp.gnu.org/gnu/gdb/gdb-8.1.tar.xz&quot;
-  mirror &quot;https://ftpmirror.gnu.org/gdb/gdb-8.1.tar.xz&quot;
-  sha256 &quot;af61a0263858e69c5dce51eab26662ff3d2ad9aa68da9583e8143b5426be4b34&quot;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  url &quot;https://ftp.gnu.org/gnu/gdb/gdb-8.0.1.tar.xz&quot;
+  mirror &quot;https://ftpmirror.gnu.org/gdb/gdb-8.0.1.tar.xz&quot;
+  sha256 &quot;3dbd5f93e36ba2815ad0efab030dcd0c7b211d7b353a40a53f4c02d7d56295e3&quot;
&lt;/span&gt; 
   bottle do
&lt;span class=&quot;gd&quot;&gt;-    sha256 &quot;43a6d6cca157ef70d13848f35c04e11d832dc0c96f5bcf53a43330f524b3ac40&quot; =&amp;gt; :high_sierra
-    sha256 &quot;fe7c6261f9164e7a744c9c512ba7e5afff0e74e373ece9b5aa19d5da6443bfc2&quot; =&amp;gt; :sierra
-    sha256 &quot;cd89001bcf8c93b5d6425ab91a400aeffe0cd5bbb0eccd8ab38c719ab5ca34ba&quot; =&amp;gt; :el_capitan
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    sha256 &quot;e98ad847402592bd48a9b1468fefb2fac32aff1fa19c2681c3cea7fb457baaa0&quot; =&amp;gt; :high_sierra
+    sha256 &quot;0fdd20562170c520cfb16e63d902c13a01ec468cb39a85851412e7515b6241e9&quot; =&amp;gt; :sierra
+    sha256 &quot;f51136c70cff44167dfb8c76b679292d911bd134c2de3fef40777da5f1f308a0&quot; =&amp;gt; :el_capitan
+    sha256 &quot;2b32a51703f6e254572c55575f08f1e0c7bc2f4e96778cb1fa6582eddfb1d113&quot; =&amp;gt; :yosemite
&lt;/span&gt;   end
 
   deprecated_option &quot;with-brewed-python&quot; =&amp;gt; &quot;with-python@2&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 17 Apr 2018 13:08:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/04/17/downgrade-gdb/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/04/17/downgrade-gdb/</guid>
        
        <category>macOS</category>
        
        <category>gdb</category>
        
        <category>homebrew</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（8）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/04/07/thoughts-on-stanford-cs140e-7/&quot;&gt;上一篇文章&lt;/a&gt;之后，我其实还是很忙，但是一直心理惦记着这件事，毕竟只剩最后的一点点就可以做完了，不做完总是觉得心痒。&lt;/p&gt;

&lt;p&gt;今天做的部分是调度。我们目前只在 EL0 运行了一个 shell ，每当触发 exception 时回到 kernel 进行处理，再回到原来的地方。但现在，我要实现一个 preemtive round-robin scheduler ，就需要管理当前的所有进程，并且维护当前的进程状态，当时钟中断到来的时候，决定下一个 time slice 要执行的进程，再切换过去。这个过程当然会遇到不少的坑。&lt;/p&gt;

&lt;p&gt;首先，我们需要判断一个进程是否可以执行了。考虑到阻塞的 IO ，作者提供了一个优雅的方法：如果这个进程阻塞在 IO 上，那么，提供一个函数，在 scheduler 中调用，判断所需要的数据是否到达。这样，我们就可以一个循环把下一个 time slice 要执行的线程找到。如果找不到，就等待 interrupt 再尝试。&lt;/p&gt;

&lt;p&gt;困难的地方在于，在启动的时候，切换到一个起始线程。并且在上下文切换的时候，在 process 1 -&amp;gt; kernel -&amp;gt; process 2 这两步过程中，有许多寄存器都需要仔细考虑如何实现。并且在这个过程中，我也发现了之前写的代码中的问题，最终修复了（目前来看是 working 了）。&lt;/p&gt;

&lt;p&gt;我的代码实现在 &lt;a href=&quot;https://github.com/jiegec/cs140e/commit/977f179a9b28e88e85f4ba9577a0682bf2b6c57b&quot;&gt;这里&lt;/a&gt; 。下一步就要写 syscall 了。希望能在期中前抽时间赶紧把这个做完。&lt;/p&gt;

&lt;p&gt;18:54 PM Update: 刚实现完了 sleep 的 syscall 。比预想中要简单。果然找到了自己实现的调度器的 BUG 。此系列大概是完结了。&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Apr 2018 17:27:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/04/10/thoughts-on-stanford-cs140e-8/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/04/10/thoughts-on-stanford-cs140e-8/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>aarch64</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（7）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/05/thoughts-on-stanford-cs140e-6/&quot;&gt;上一篇文章&lt;/a&gt;之后，我很长时间都没有在继续我这个项目，清明节刚好闲下来了我就回来继续啃它。Stanford那边已经结课，最后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;3-spawn&lt;/code&gt; 也只有一部分，剩下的部分不知道什么时候作者才会填上去了。&lt;/p&gt;

&lt;p&gt;这次主要要写的代码就是，对异常的处理。这里的异常并不是我们编程语言中的 catch/throw ，而是硬件的异常。AArch64 和 x86 一样，也有不同的特权级别的区分，前者是 EL0~EL3 ，后者则是 RING0 和 RING3 。特权级别高可以往特权级别低转换，但是反过来，只能通过异常的方式提高特权等级，并且切换特权等级后只有固定的一些代码可能会跳转，这就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception handler/vectors&lt;/code&gt; 。这些函数可以知道是什么原因调用了他们，根据硬件规定好的文档，我们可以知道发生了什么事情，是对齐出错了呢，还是用户调用了 syscall 呢，等等。根据不同的情况，我们需要进行不同的处理。当处理完之后，我们需要考虑，跳转回用户代码的时候，回到哪里，提供什么值，不提供什么。&lt;/p&gt;

&lt;p&gt;实现的话，需要很多步骤。首先是构造好 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception vector&lt;/code&gt; ，这里作者已经写好了一个宏（这里 @BenYip 遇到了一个 assembler 的 BUG ），直接用宏就可以把它写出来。然后，我们需要把它加载到当前 EL 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;VBAR_ELx&lt;/code&gt; 寄存器中，当 CPU 抛出异常的时候，就会找到这里相应的处理器进行处理。进到这里以后，我们首先先不考虑太多上下文保存的事情–我们先保证能处理异常，恢复也是个有很多坑的步骤，作者也是在这里分成了两个 Subphase 。首先还是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ESR_ELx&lt;/code&gt; 中解析到错误的来源的具体内容，如果是我们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 中自己调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 指令，我们就自己新开一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，修改了提示符以示区别。这样，我们就成功地捕捉到了这个异常。由于我们还无法恢复回去，所以我们直接死循环。&lt;/p&gt;

&lt;p&gt;接下来我们要做的是，从异常中恢复出来。由于用户代码可能在各种地方抛出异常，异常也分同步和异步两种情况，这里有许多需要考虑的问题。为了简化，我们目前只考虑同步的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 导致的 Brk 异常。为了能恢复之后能够正常运行，我们需要把所有的寄存器都保存下来，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;TrapFrame&lt;/code&gt; 。保存的时候需要讲究 AArch64 平台下 SP 寄存器的对齐问题。我们也要把一些特殊的寄存器保存下来。还有一点，就是，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception handler&lt;/code&gt; 中调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;context_save&lt;/code&gt; 函数，所以此时的 lr 本身也需要进行保存，这个地方也卡了我很久。最后，再把这些一个一个地恢复到原来的样子，调整 &lt;code class=&quot;highlighter-rouge&quot;&gt;ELR_EL1&lt;/code&gt; 使得退回到原来的状态时，会跳过当前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 指令，调用它的下一调指令。这样，我们就成功地在遇到异常时，弹出一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，而且还可以回退回来。&lt;/p&gt;

&lt;p&gt;学到了很多很多。之后大三，我们可能需要做自己的 CPU ，在自己的 CPU 上跑自己的操作系统，在自己的操作系统中跑自己的编译器，在自己的编译器中编译一个数据库。希望到时我还活着吧。#flag&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Apr 2018 14:05:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/04/07/thoughts-on-stanford-cs140e-7/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/04/07/thoughts-on-stanford-cs140e-7/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>aarch64</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>最近比较忙</title>
        <description>&lt;p&gt;最近一直没有更新我的 CS140e 系列文章，是因为最近一直忙于各种事情。等有空了再更新吧。&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Mar 2018 15:05:00 +0800</pubDate>
        <link>https://jiegec.github.io/others/2018/03/26/busy-these-days/</link>
        <guid isPermaLink="true">https://jiegec.github.io/others/2018/03/26/busy-these-days/</guid>
        
        
        <category>others</category>
        
      </item>
    
      <item>
        <title>偶遇清华吴文虎教授</title>
        <description>&lt;p&gt;今天百团大战，正准备收摊的时候，天空工场那边来了一位长者，在和他们聊着什么。我很感兴趣，就上去听。老人大概已有八十高龄（后来查，是1936年生），但依然精神矍铄，首先和我们讲，作为工科的学生，一定在理解原理的基础上，多多去实践。他举了他自己的例子，他首先在电机系学习，后来，计算机系成立（当时还是自动控制系），他转到了计算机系，重新学起了计算机，说计算机编程学起来并没有什么难的。当年，苹果公司送过来了中国第一台 Apple-2 ，他们就把电脑拆了下来研究原理，又装上去继续工作。后来，他就在计算机系任教，教的正是《程序设计基础》这门课程。他十分重视实践，在第一年开课的时候就说，最关键的就是实践，安排了一些编程实验课，期中期末就是大作业。一开始有一些同学不重视实践，结果期末就挂科了。后来同学们就明白了实践的重要性，实践起来发现并没有那么难，最后就说，“吴老师，你说得对”。他又谈到了他的体育，他当年是北京长跑代表队的集训队选手，擅长一千五百米项目，他三千米只需要九分钟就能跑完。我们都感到自愧不如。我们说，现在的《程序设计基础》是徐明星老师在教，他说徐明星是他的博士生，邬晓钧也是他的博士生，他另外还有一个高徒我记不清楚了。他还是IOI中国队的前教练，听到我们有过一些OI基础，表示了赞许和鼓励。还有一些细节记不清楚了，记起来了再补充吧。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Mar 2018 17:47:50 +0800</pubDate>
        <link>https://jiegec.github.io/others/2018/03/08/encountering-wu-wenhu/</link>
        <guid isPermaLink="true">https://jiegec.github.io/others/2018/03/08/encountering-wu-wenhu/</guid>
        
        <category>百团大战</category>
        
        <category>吴文虎</category>
        
        
        <category>others</category>
        
      </item>
    
  </channel>
</rss>
