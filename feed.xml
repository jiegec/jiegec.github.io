<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杰哥的{运维,编程,调板子}小笔记</title>
    <link>https://jiege.ch/</link>
    <description>Recent content on 杰哥的{运维,编程,调板子}小笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Sep 2019 10:04:00 +0800</lastBuildDate>
    
	<atom:link href="https://jiege.ch/feed.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>每周分享第 43 期</title>
      <link>https://jiege.ch/misc/2019/09/28/weekly-sharing-43/</link>
      <pubDate>Sat, 28 Sep 2019 10:04:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/09/28/weekly-sharing-43/</guid>
      <description> Async in C https://github.com/naasking/async.h Mozilla 的 QUIC 实现 https://github.com/mozilla/neqo/ 在PCI上做的攻击 https://github.com/ufrisk/pcileech 对 X 的原理介绍 https://magcius.github.io/xplain/article/index.html Ethernet 物理层的介绍 https://www.analog.com/media/en/technical-documentation/application-notes/EE-269.pdf Overleaf 更新了 TeX Live 版本 https://www.overleaf.com/blog/tex-live-upgrade-september-2019 下一代 proc macro ？ https://github.com/alexcrichton/proc-macro2 iOS 13 API 变化 https://nshipster.com/ios-13/ iOS 13.1.1 发布 Rust 编译期 HashMap https://github.com/sfackler/rust-phf V8 加入顶层 Await 支持 https://chromium.googlesource.com/v8/v8.git/+/0ceee9ad28c21bc4971fb237cf87eb742fc787b8%5E%21/ ASCII 码表的一种理解 https://garbagecollected.org/2017/01/31/four-column-ascii/ Cloudflare 启用 HTTP/3 https://blog.cloudflare.com/http3-the-past-present-and-future/ ZFS 发布 0.8.2 https://github.com/zfsonlinux/zfs/releases/tag/zfs-0.8.2  </description>
    </item>
    
    <item>
      <title>每周分享第 42 期</title>
      <link>https://jiege.ch/misc/2019/09/21/weekly-sharing-42/</link>
      <pubDate>Sat, 21 Sep 2019 09:50:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/09/21/weekly-sharing-42/</guid>
      <description>Dart 2.5 发布 Rust USB device 库 https://github.com/mvirkkunen/usb-device 同步视频的 timecode https://github.com/cnbeining/autotimecode xv6 今年换到了 riscv https://github.com/mit-pdos/xv6-riscv-fall19 pdf 文本搜索 https://pdfgrep.org/ iOS 13 正式版发布 exFAT 驱动进入 Linux 5.4 Microsoft exFAT File-System Mailed In For Linux 5.4 Along With Promoted EROFS &amp;amp; Greybus Bash 详细教程 https://github.com/dylanaraps/pure-bash-bible Rust 编译到 iOS bitcode https://github.com/getditto/rust-bitcode JS 运行时间 in V8 https://v8.dev/blog/cost-of-javascript-2019#json USB3.0 PIPE 接口实现 https://github.com/enjoy-digital/usb3_pipe LLVM 9.0 发布 https://lists.llvm.org/pipermail/llvm-dev/2019-September/135304.html Safari 13.0 发布 Rust 模板引擎 https://github.com/botika/yarte systemd 开始掌握 home 目录 https://www.</description>
    </item>
    
    <item>
      <title>在 macOS 上创建 ESP 镜像文件</title>
      <link>https://jiege.ch/software/create-esp-partition-macos/</link>
      <pubDate>Sat, 14 Sep 2019 16:07:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/create-esp-partition-macos/</guid>
      <description>最近 rCore 添加了 UEFI 支持，在 QEMU 里跑自然是没有问题，然后尝试放到 VMWare 虚拟机里跑，这时候问题就来了：需要一个带有 ESP 盘的 vmdk 虚拟盘。搜索了一下网络，找到了解决方案：
hdiutil create -fs fat32 -ov -size 60m -volname ESP -format UDTO -srcfolder esp uefi.cdr  其中 60m esp 和 uefi.cdr 都可以按照实际情况修改。它会把 esp 目录下的文件放到 ESP 分区中，然后得到一个镜像文件：
uefi.cdr: DOS/MBR boot sector; partition 1 : ID=0xb, start-CHS (0x3ff,254,63), end-CHS (0x3ff,254,63), startsector 1, 122879 sectors, extended partition table (last)  接着转换为 vmdk ：
qemu-img convert -O vmdk uefi.cdr uefi.vmdk  这样就可以了。</description>
    </item>
    
    <item>
      <title>每周分享第 41 期</title>
      <link>https://jiege.ch/misc/2019/09/14/weekly-sharing-41/</link>
      <pubDate>Sat, 14 Sep 2019 07:50:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/09/14/weekly-sharing-41/</guid>
      <description> Wget2 1.99.2 beta 发布 https://lists.gnu.org/archive/html/info-gnu/2019-09/msg00001.html 独立的 printf 实现 https://github.com/mpaland/printf Unicode 字符串长度统计 https://hsivonen.fi/string-length/ C 类型推断 https://github.com/ltcmelo/psychec#generic-programming Clang 9.0 支持 Linux 内核编译 The New Features Of LLVM 9.0 &amp;amp; Clang 9.0 - Includes Building The Linux x86_64 Kernel 可控制的 USB 设备 https://github.com/usb-tools/Facedancer USB 监听器 https://github.com/openvizsla/ov_ftdi 修复一个截断的视频 https://github.com/ponchio/untrunc  </description>
    </item>
    
    <item>
      <title>每周分享第 40 期</title>
      <link>https://jiege.ch/misc/2019/09/06/weekly-sharing-40/</link>
      <pubDate>Fri, 06 Sep 2019 20:41:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/09/06/weekly-sharing-40/</guid>
      <description> TeX Typesetting Game https://texnique.xyz/ Writing Linux Kernel Module in Rust https://github.com/fishinabarrel/linux-kernel-module-rust Sipeed Longan Nano RISC-V 开发板 https://readhacker.news/s/48EBG Systemd 加载 BPF 防火墙 https://kailueke.gitlab.io/systemd-bpf-firewall-loader/ 方舟编译器 https://code.opensource.huaweicloud.com/HarmonyOS/OpenArkCompiler.git XLOOKUP 函数 https://techcommunity.microsoft.com/t5/Excel-Blog/Announcing-XLOOKUP/ba-p/811376 SystemVerilog to Verilog 转译 https://github.com/zachjs/sv2v USB 4.0 发布 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=USB-4.0-Specification-Published Android 10 发布 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Android-10-Released iOS 13.1 beta 2 发布 对 iOS 设备抓包 http://blog.imaou.com/opensource/2014/12/14/pcapd_diagnostic_packet_capture.html Google 的差分隐私库 https://developers.googleblog.com/2019/09/enabling-developers-and-organizations.html Apple Music 第三方 App https://github.com/Musish/Musish  </description>
    </item>
    
    <item>
      <title>每周分享第 39 期</title>
      <link>https://jiege.ch/misc/2019/08/30/weekly-sharing-39/</link>
      <pubDate>Fri, 30 Aug 2019 10:08:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/08/30/weekly-sharing-39/</guid>
      <description> 另一个 Pattern Matching in C++ 库 https://github.com/mpark/patterns Rust 编写的一个 shell http://www.jonathanturner.org/2019/08/introducing-nushell.html Vim 的游戏教程 https://readhacker.news/s/48nbJ 在 throw 的时候同时抓取 SO 信息 https://github.com/shobrook/rebound/ 颜色生成工具 https://github.com/sharkdp/pastel 转换 Escape Code 到 HTML https://github.com/theZiz/aha iOS 13.1 beta 发布 苹果特别活动定于 9.11 日 exFAT 规范发布 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Microsoft-exFAT-Specification 可视化的 5 阶段流水线 RISC-V 模拟器 https://github.com/mortbopet/Ripes  </description>
    </item>
    
    <item>
      <title>每周分享第 38 期</title>
      <link>https://jiege.ch/misc/2019/08/23/weekly-sharing-38/</link>
      <pubDate>Fri, 23 Aug 2019 19:51:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/08/23/weekly-sharing-38/</guid>
      <description> 针对部分 HTTP/2 实现的新漏洞 https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md 只读 tmux 加魔改 https://brianmckenna.org/blog/guest_tmux Rust 编译期断言 https://github.com/nvzqz/static-assertions-rs Rust 运行时解压版的 include_bytes https://github.com/SOF3/include-flate 把 Rust 标准库进行 async 化的尝试 https://async.rs/blog/announcing-async-std/# git 添加 switch/restore 命令 https://github.blog/2019-08-16-highlights-from-git-2-23/ Flash Player in Rust https://github.com/ruffle-rs/ruffle Matplotlib Cheatsheet https://github.com/rougier/matplotlib-cheatsheet macOS Catalina 10.15 beta 6 发布 Flash Decompiler https://github.com/jindrapetrik/jpexs-decompiler Yubikey 发布 5Ci https://readhacker.news/s/489yu IBM 开放 Power 指令集 https://readhacker.news/s/48aiH iOS 13 beta 8 发布 GitHub 支持 WebAuthn https://readhacker.news/s/48dXM 编译器优化带来的安全漏洞 https://readhacker.news/s/48dke obscure C features https://multun.net/obscure-c-features.html  </description>
    </item>
    
    <item>
      <title>每周分享第 37 期</title>
      <link>https://jiege.ch/misc/2019/08/16/weekly-sharing-37/</link>
      <pubDate>Fri, 16 Aug 2019 11:29:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/08/16/weekly-sharing-37/</guid>
      <description> Rust netlink 库 https://github.com/jbaublitz/neli Rust 处理 signal 进行配置的 reload https://vorner.github.io/2019/08/11/runtime-configuration-reloading.html macOS 添加了 VirtIO 驱动支持 https://passthroughpo.st/mac-os-adds-early-support-for-virtio-qemu/ 一个 GNU readline 替代品 https://github.com/AmokHuginnsson/replxx Rust 1.37.0 发布 https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html iOS 13 DB7 (17A5565b) 发布  </description>
    </item>
    
    <item>
      <title>macOS 下读取并解析 EDID</title>
      <link>https://jiege.ch/software/read-edid-decode-macos/</link>
      <pubDate>Wed, 14 Aug 2019 20:39:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/read-edid-decode-macos/</guid>
      <description>之前听说了 EDID 的存在，但是一直没有细究里面的格式和内容。今天了解了一下，发现其实非常简单，下面是方法：
首先获取所有显示器输出的 EDID ：
ioreg -lw0 | grep IODisplayEDID  输出里会出现 &amp;ldquo;IODisplayEDID&amp;rdquo; =  的内容，尖括号内的就是 EDID 的内容。接着，我们采用 edid-decode 进行解析：
git clone git://linuxtv.org/edid-decode.git cd edid-decode make ./edid-decode &amp;lt;Paste EDID here&amp;gt;  就可以看到很详细的 EDID 数据解析了。
ref: https://gist.github.com/OneSadCookie/641549 https://www.avsforum.com/forum/115-htpc-mac-chat/1466910-ability-dump-display-s-edid-mac.html</description>
    </item>
    
    <item>
      <title>在 Linux 下捕获 Framebuffer</title>
      <link>https://jiege.ch/software/framebuffer-capture/</link>
      <pubDate>Mon, 12 Aug 2019 20:18:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/framebuffer-capture/</guid>
      <description>最近需要在 linux 下抓取 Framebuffer 的内容，在网上找到了两种方法，在我这里只有第二、第三种可以成功，没有细究具体原因，可能与我的 Framebuffer 配置有关。方法如下：
 fbgrab ：命令就是 fbgrab image.png ，直接得到 png 文件，格式是对的，但是用软件打开就是一片空白。用 ImageMagick 转换为 jpg可以看到一些内容，但是和实际有些不一样。 fbdump ：命令就是 fbdump &amp;gt; image.ppm ，得到裸的 ppm 文件，图像是正确的，也可以转换为别的格式正常打开。 cat+脚本处理：直接 cat /dev/fb0 &amp;gt; image.rgb ，然后用下面的脚本转换为 png 。由于 Framebuffer 格式为 RGB ，本来 A 所在的 channel 都为 0 ，所以用一些软件直接打开都是空白，只好写了脚本直接跳过 Alpha Channel 。  Framebuffer 配置（ fbset 输出）：
mode &amp;quot;640x480-0&amp;quot; # D: 0.000 MHz, H: 0.000 kHz, V: 0.000 Hz geometry 640 480 1024 480 32 timings 0 0 0 0 0 0 0 accel false rgba 8/16,8/8,8/0,0/0 endmode  转换脚本（参考[Tips] 擷取framebuffer畫面）：</description>
    </item>
    
    <item>
      <title>每周分享第 36 期</title>
      <link>https://jiege.ch/misc/2019/08/10/weekly-sharing-36/</link>
      <pubDate>Sat, 10 Aug 2019 09:15:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/08/10/weekly-sharing-36/</guid>
      <description> QuickJS + libuv https://github.com/saghul/qjsuv Rust 实现的 Ruby https://github.com/artichoke/artichoke 类似 JSON 的数据格式 https://cbor.io/ rls 二代目 https://github.com/rust-analyzer/rust-analyzer 给 MacBook 添加触屏支持 https://github.com/bijection/sistine 用于 MBP with T2 的 Linux patch https://github.com/aunali1/linux-mbp-arch 在 tmux 中使用 Touch ID 认证 sudo https://blog.birkhoff.me/make-sudo-authenticate-with-touch-id-in-a-tmux/ iOS 13 beta 6 发布 Linux Journal 结束了它的使命 ssh 8.0 Add support for ECDSA keys in PKCS#11 tokens  </description>
    </item>
    
    <item>
      <title>用 PulseView 配合 DSLogic 调试 SPI Flash</title>
      <link>https://jiege.ch/hardware/pulseview-dslogic/</link>
      <pubDate>Fri, 02 Aug 2019 23:15:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/pulseview-dslogic/</guid>
      <description>最近需要用到逻辑分析仪来调试 SPI Flash，设备是 DreamSourceLab 的 DSLogic ，最开始用的是官方的 DSView ，确实能够抓到 SPI 的信号，也可以解析出一些 SPI Flash 的数据，但是很多是不完整的。
后来把源码下载下来，发现是基于 sigrok 和 PulseView 做的一个魔改版，然后 sigrok 官网上最新的版本已经支持了 DSLogic ，于是就用 PulseView 替代 DSView 。一开始遇到的问题是没有 firmware ，一番搜索找到了解决方案，按照脚本下载好文件即可。
进到 PulseView 以后，把 SPI 的四路信号接上，然后抓了一段信号，解析：
可以看到它正确地解析出来了 Fast Read 命令。由于 DSView 它 fork 自一个比较老的版本，所以它并不能正确解析出来。
P.S. Linux 下它界面显示比 macOS 下好看一些，估计是没有适配好。</description>
    </item>
    
    <item>
      <title>每周分享第 35 期</title>
      <link>https://jiege.ch/misc/2019/08/02/weekly-sharing-35/</link>
      <pubDate>Fri, 02 Aug 2019 14:26:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/08/02/weekly-sharing-35/</guid>
      <description> Apple Touch Bar 的 Windows 第三方支持 https://github.com/imbushuo/DFRDisplayKm WSL2 新的进展 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Windows-WSL2-Localhost-Plus Lightning 转接头里面居然跑 iBoot 和 Darwin https://readhacker.news/s/46Zde iOS 13 beta 5 发布 ES2019 前瞻 https://blog.tildeloop.com/posts/javascript-what%E2%80%99s-new-in-es2019 Rust 可持久化数据结构 https://github.com/orium/rpds Rust 不可变数据结构 https://github.com/bodil/im-rs macOS Catalina 10.15 beta 5 发布 Algebraic Effect https://overreacted.io/algebraic-effects-for-the-rest-of-us/ Donald Knuth 对于 Sensitivity Proof 证明的简化 https://readhacker.news/s/47fsA 真是老当益壮 TLS1.3 标准的简化版 https://readhacker.news/s/47eG9 iTerm 3.3 发布 https://iterm2.com/downloads/stable/iTerm2-3_3_0.changelog  </description>
    </item>
    
    <item>
      <title>每周分享第 34 期</title>
      <link>https://jiege.ch/misc/2019/07/27/weekly-sharing-34/</link>
      <pubDate>Sat, 27 Jul 2019 13:31:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/07/27/weekly-sharing-34/</guid>
      <description> macOS Mojave 10.14.6 iOS 12.4 正式版更新发布，还有老版本的更新 https://www.macrumors.com/2019/07/22/apple-releases-gps-bug-fix-older-iphones-ipads/ CLion 2019.2 添加了 GDB Server 的调试支持，可以用 OpenOCD 。  </description>
    </item>
    
    <item>
      <title>每周分享第 33 期</title>
      <link>https://jiege.ch/misc/2019/07/19/weekly-sharing-33/</link>
      <pubDate>Fri, 19 Jul 2019 21:28:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/07/19/weekly-sharing-33/</guid>
      <description> 一个讲 Rust 比较硬核的博客 http://system.joekain.com/ 利用 fzf 实现 shell 的 REPL https://github.com/pawelduda/fzf-live-repl 类似 Vue 的前端 Go 框架 https://www.vugu.org/doc/start iOS 13 beta 4 发布 14A5534f 针对 T2 NVMe 的 patch http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=NVMe-Patches-LKML-Apple-Mac 一个前端非对称加密的问卷网站 https://blog.fugoes.xyz/crypto-q/  </description>
    </item>
    
    <item>
      <title>前端解析上传的 CSV</title>
      <link>https://jiege.ch/programming/2019/07/17/parse-upload-csv-frontend/</link>
      <pubDate>Wed, 17 Jul 2019 13:05:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/07/17/parse-upload-csv-frontend/</guid>
      <description>之前做过一个在前端解析上传的 CSV 的功能，但是只能支持部分的 encoding，遇到 gbk 就傻眼了。一番研究以后，找到了比较科学的方案：
import * as Chardet from &#39;chardet&#39;; import * as Iconv from &#39;iconv-lite&#39;; const reader = new FileReader(); reader.onload = (e) =&amp;gt; { const data = e.target.result; const view = Buffer.from(data); // detect encoding and convert const encoding = Chardet.detect(view); const result = Iconv.decode(view, encoding); const csvData = Papa.parse(result).data; // do anything with it }; reader.readAsArrayBuffer(blob_here);  依赖了两个库：chardet 和 iconv-lite ，测试了一下，解析 UTF-8 GBK UTF-16BE 都没问题。</description>
    </item>
    
    <item>
      <title>每周分享第 32 期</title>
      <link>https://jiege.ch/misc/2019/07/12/weekly-sharing-32/</link>
      <pubDate>Fri, 12 Jul 2019 23:42:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/07/12/weekly-sharing-32/</guid>
      <description> Rpi4 的 Type-C 设计有问题 https://readhacker.news/s/45WYc Debian buster released USB Type-C Serial adapter with WCH/FTDI https://github.com/z4yx/USB-C-Serial Linux 5.2 Kernel released http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Linux-5.2-Released iOS/iPadOS PB2 发布，与 DB3 差了一个小版本号 Pacman in 512 bytes of x86 boot sector machine code https://readhacker.news/s/466Zm clang 的 use after move checker 使用 https://awesomekling.github.io/Catching-use-after-move-bugs-with-Clang-consumed-annotations/  </description>
    </item>
    
    <item>
      <title>每周分享第 31 期</title>
      <link>https://jiege.ch/misc/2019/07/05/weekly-sharing-31/</link>
      <pubDate>Fri, 05 Jul 2019 16:06:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/07/05/weekly-sharing-31/</guid>
      <description> 一个 Docker 的 TUI https://github.com/jesseduffield/lazydocker 在线 Git cheatsheet http://ndpsoftware.com/git-cheatsheet.html 带历史合并两个 Git 仓库 https://stackoverflow.com/a/10548919 iOS 13 Dev Beta 3 https://mp.weixin.qq.com/s/6cxLXOYgeP6QkDpa9kdoug iOS 13 FaceTime Attention Correction https://readhacker.news/s/45QX2  </description>
    </item>
    
    <item>
      <title>每周分享第 30 期</title>
      <link>https://jiege.ch/misc/2019/06/28/weekly-sharing-30/</link>
      <pubDate>Fri, 28 Jun 2019 19:19:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/06/28/weekly-sharing-30/</guid>
      <description> 一个可参考的防止 side channel attack 的方法 https://www.undeadly.org/cgi?action=article;sid=20190621081455
 物理上镜像百兆的方法 实测可用 https://greatscottgadgets.com/throwingstar/
 微软员工写的 malloc https://github.com/microsoft/mimalloc
 超标量乱序执行的 x86 软核 https://tspace.library.utoronto.ca/bitstream/1807/80713/1/Wong_Henry_T_201711_PhD_thesis.pdf
 Rust 的 wireshark 替代 https://github.com/kpcyrd/sniffglue
 Rpi 4 发布 https://readhacker.news/s/45nK9
 iOS/macOS Catalina PB1 发布（= DB2）
 dbg! 移植到了 C++ https://github.com/sharkdp/dbg-macro
 类似于 Elm 的 Rust 前端框架 https://github.com/David-OConnor/seed
 访问 VMware 虚拟机串口的方法 https://thewayeye.net/2009/december/4/connecting-virtual-machines-serial-console-os-x-and-vmware-fusion/
  </description>
    </item>
    
    <item>
      <title>IP 前缀转换上意外遇到的 Undefined Behavior</title>
      <link>https://jiege.ch/programming/2019/06/21/ip-prefix-unexpected-undefined-behavior/</link>
      <pubDate>Fri, 21 Jun 2019 21:23:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/06/21/ip-prefix-unexpected-undefined-behavior/</guid>
      <description>最近发现了两个很神奇的 Undefined Behavior ，出现在 Prefix Len 和 Netmask 的转换的问题下。一个简单思路可能是：
#define PREFIX_BIN2DEC(bin) (32 - __builtin_ctz((bin))) #define PREFIX_DEC2BIN(hex) (((~0) &amp;gt;&amp;gt; (32 - (hex))) &amp;lt;&amp;lt; (32 - (hex))  乍一看，似乎没有什么问题。但是，在一些平台下，可能会出现这样的结果：
PREFIX_BIN2DEC(0x00000000) = 33 PREFIX_DEC2BIN(0) = 0xFFFFFFFF  而且只能在一些平台上不确定地复现，最后发现其实是 Undefined Behavior，在 C 的标准中：
In any case, the behavior is undefined if rhs is negative or is greater or equal the number of bits in the promoted lhs.  意味着， 0xFFFFFFFF &amp;gt;&amp;gt; 32 是一个 UB ，所以出现了上面的问题。</description>
    </item>
    
    <item>
      <title>每周分享第 29 期</title>
      <link>https://jiege.ch/misc/2019/06/21/weekly-sharing-29/</link>
      <pubDate>Fri, 21 Jun 2019 21:18:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/06/21/weekly-sharing-29/</guid>
      <description> ZFS on Linux 发布 0.8.1 https://github.com/zfsonlinux/zfs/releases/tag/zfs-0.8.1 slim: Dockerfile to VM image https://github.com/ottomatica/slim Rust 重写的 du 替代物 确实很快 https://github.com/Byron/dua-cli iOS 13/macOS Catalina beta 2 出了 并且可以 OTA 相关信息 https://9to5mac.com/2019/06/17/ios-13-beta-2-features/ https://developer.apple.com/documentation/macos_release_notes/macos_catalina_10_15_beta_2_release_notes https://mp.weixin.qq.com/s/Ae1SIcK9ho4Mh0g_UsbAyA Steam 已经解决了 Catalina 上 32 位程序不能运行的问题 https://www.reddit.com/r/MacOS/comments/c17lh8/steam_and_macos_catalina 在一些老的 Mac 上 Sidecar 是默认关闭的，但是可以开启 https://github.com/pookjw/SidecarPatcher/blob/master/README.md 虽然效果不会很好  </description>
    </item>
    
    <item>
      <title>每周分享第 28 期</title>
      <link>https://jiege.ch/misc/2019/06/15/weekly-sharing-28/</link>
      <pubDate>Sat, 15 Jun 2019 08:13:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/06/15/weekly-sharing-28/</guid>
      <description> Rust Sec https://github.com/RustSec/advisory-db opendrop 开源的 AirDrop 实现 https://github.com/seemoo-lab/opendrop 代码内嵌图片 https://javl.github.io/image2cpp/ RAMBleed 攻击 https://readhacker.news/s/44MHD WSL2 可以体验了 https://devblogs.microsoft.com/commandline/wsl-2-is-now-available-in-windows-insiders/ Rust 2019 生态报告 https://www.jetbrains.com/lp/devecosystem-2019/rust/  </description>
    </item>
    
    <item>
      <title>每周分享第 27 期</title>
      <link>https://jiege.ch/misc/2019/06/07/weekly-sharing-27/</link>
      <pubDate>Fri, 07 Jun 2019 14:05:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/06/07/weekly-sharing-27/</guid>
      <description>高考加油！
 Fallout 漏洞 https://arxiv.org/abs/1905.12701 PageRank 专利到期 https://patents.google.com/patent/US6285999B1/en 终端电量可视化 https://github.com/svartalf/rust-battop 查找 DB 的 DB https://dbdb.io 在 Rust 里写 GPU 程序 https://github.com/calebwin/emu WWDC 2019 挺不错的 Alfred 4 发布 https://www.alfredapp.com/blog/announcements/alfred-4-is-here/ Mac Pro AR https://www.apple.com/105/media/us/mac-pro/2019/36178e80-30fd-441c-9a5b-349c6365bb36/quick-look/case-on.usdz VSCode 稳定版也可以 Remote 了 https://code.visualstudio.com/docs/remote/ssh 2019 高考语文作文 https://mp.weixin.qq.com/s/2NwkbbMlAUJpOKKuln1T4g  </description>
    </item>
    
    <item>
      <title>在 FPGA 上实现路由器（3）</title>
      <link>https://jiege.ch/hardware/router-on-fpga-3/</link>
      <pubDate>Sun, 02 Jun 2019 09:24:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/router-on-fpga-3/</guid>
      <description>前言 又半个月过去了，在写了上篇系列博文之后也是做了很多新的更改。上次做的主要是关于性能方面的提升，怎么提高频率，从而达到比较大的流量，而这段时间做的则是功能，做实现 RIP 协议和转发表的动态更新。
软件部分 软件部分目前是用 C 代码写的，用 Xilinx SDK 提供的各个 AXI 外设的驱动和PS自己的驱动，实现了所需要的，RIP协议的处理，转发表的更新和统计信息的读取。
实际上做的时候比较粗暴，主要是通过三种 AXI 外设与硬件部分进行交互：AXI Stream FIFO，AXI GPIO 和 AXI BRAM Controller 。其中 AXI Stream FIFO 是用来接收和发送需要CPU处理的以太网帧的，AXI GPIO则是用来读取统计的信息，AXI BRAM Controller 是用来读写转发表的。最后在顶层设计中把这些外设连接起来。
硬件部分 硬件部分还是继续之前的部分往下写，添加了统计信息，直接暴露出去，让 CPU 走 AXI GPIO 读，因为不需要很高的精确度；转发表本身，一开始想的是自己写一些接口转换，后来发现，直接用 True Dual Port RAM 然后把一个 port 暴露给 AXI BRAM Controller 即可，免去了各种麻烦，PS可以直接进行修改，不需要额外的工作。
最终效果 为了测试这套东西是否正常工作，就开了两个 Arch Linux 的虚拟机，分别 Bridge 到两个千兆的 USB 网卡上，都连到 FPGA 上。然后在两边都配上了 BIRD ，配置 RIP 和一些路由，确实能更新硬件的转发表，并两边的 RIP 可以学习到对方的路由。</description>
    </item>
    
    <item>
      <title>每周分享第 26 期</title>
      <link>https://jiege.ch/misc/2019/05/31/weekly-sharing-26/</link>
      <pubDate>Fri, 31 May 2019 18:38:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/05/31/weekly-sharing-26/</guid>
      <description> Grafana 6.2 发布 https://grafana.com/blog/2019/05/22/grafana-v6.2-released/ Program Synthesis Talk by Paul Zhu https://paulz.me/talk/program-synthesis/ VSCode 摸鱼插件 https://github.com/cteams/Thief-Book 编译期 C++ 计算器 https://www.zhihu.com/question/28582706/answer/691444859 一个在线的 tomasulo 算法实现 https://tomasulo.harrychen.xyz/ Safari Technology Preview 83 发布，含 WebAuthN 支持 https://webkit.org/blog/8967/release-notes-for-safari-technology-preview-83/ Markdown -&amp;gt; 微信 https://github.com/lyricat/wechat-format Rust 的 Code Coverage 库 https://github.com/xd009642/tarpaulin  </description>
    </item>
    
    <item>
      <title>IP 和 UDP Checksum 的增量更新问题</title>
      <link>https://jiege.ch/networking/2019/05/30/ip-and-udp-checksum-incremental-update/</link>
      <pubDate>Thu, 30 May 2019 16:06:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2019/05/30/ip-and-udp-checksum-incremental-update/</guid>
      <description>之前在写 IP Checksum 的增量更新，就是当 TTL -= 1 的时候，Checksum 应该增加 0x0100 ，但是这样会有问题，在于，如果按照原来的 IP Checksum 计算方法，是不会出现 0xFFFF 的（求和，进位，然后取反写入），这种加法就有可能出现 0xFFFF 。于是翻阅了相关的RFC：
首先是 RFC 1141 相关部分：
unsigned long sum; ipptr-&amp;gt;ttl--; /* decrement ttl */ sum = ipptr-&amp;gt;Checksum + 0x100; /* increment checksum high byte*/ ipptr-&amp;gt;Checksum = (sum + (sum&amp;gt;&amp;gt;16)) /* add carry */  这也是比较直接能想到的一种方法，但是会出现刚才提到的问题。于是 RFC 1624 纠正了这个问题：
 Although this equation appears to work, there are boundary conditions under which it produces a result which differs from the one obtained by checksum computation from scratch.</description>
    </item>
    
    <item>
      <title>用 htpdate 替代 ntpdate 实现时间同步</title>
      <link>https://jiege.ch/devops/htpdate-for-time-sync/</link>
      <pubDate>Sat, 25 May 2019 07:54:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/htpdate-for-time-sync/</guid>
      <description>最近用 ntpdate 的时候遇到了一些麻烦，时间同步总是遇到各种问题。后来搜了搜，发现了一个解决方案： htpdate ，它通过 HTTP 头里的 Date 字段获取时间，虽然没有 ntp 那么精确，但是大多时候都够用。
用法见 htpdate(8) 。</description>
    </item>
    
    <item>
      <title>每周分享第 25 期</title>
      <link>https://jiege.ch/misc/2019/05/24/weekly-sharing-25/</link>
      <pubDate>Fri, 24 May 2019 20:32:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/05/24/weekly-sharing-25/</guid>
      <description> 关掉各种 Intel BUG 的 mitigation https://t.me/one_real_world/1517 GCC 10 支持用 MMX 模拟 SSE http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=GCC-10-Emulating-MMX-With-SSE Minecraft Earth 发布 https://www.minecraft.net/en-us/article/new-game--minecraft-earth# Python 官方 format 工具 https://github.com/python/black JS Binary AST Proposal https://github.com/tc39/proposal-binary-ast 用 Rust 实现的 ld https://github.com/aep/elfkit Verilog -&amp;gt; Minecraft https://github.com/itsFrank/MinecraftHDL Rust 实现的 光栅化输出 https://github.com/ecumene/rust-sloth/ Nokia 的 Rust 内存 profiler https://github.com/nokia/memory-profiler Linux 5.2 更新的 Logitech Wireless Device 驱动 正好能用上 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Better-Logitech-Linux-5.2  </description>
    </item>
    
    <item>
      <title>Nginx 反代到 HTTPS 上游</title>
      <link>https://jiege.ch/devops/nginx-ssl-upstream/</link>
      <pubDate>Wed, 22 May 2019 16:01:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/nginx-ssl-upstream/</guid>
      <description>这次遇到一个需求，要反代到不在内网的地址，为了保证安全，还是得上 HTTPS ，所以尝试了一下怎么给 upstream 配置自签名 HTTPS 证书的验证。
upstream subpath { server 4.3.2.1:4321; } server { listen 443 ssl; server_name test.example.com; location /abc { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_ssl_trusted_certificate /path/to/self_signed_cert.crt; proxy_ssl_name 1.2.3.4; // to override server name checking proxy_ssl_verify on; proxy_ssl_depth 2; proxy_ssl_reuse on; proxy_pass https://subpath; } }  可以用 openssl 获得自签名的 cert :
echo | openssl s_client -showcerts -connect 4.3.2.1:4321 2&amp;gt;/dev/null | \ openssl x509 -text &amp;gt; /path/to/self_signed_cert.crt  ref: https://stackoverflow.</description>
    </item>
    
    <item>
      <title>每周分享第 24 期</title>
      <link>https://jiege.ch/misc/2019/05/17/weekly-sharing-24/</link>
      <pubDate>Fri, 17 May 2019 20:04:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/05/17/weekly-sharing-24/</guid>
      <description> 在线波形绘制 https://wavedrom.com/editor.html Python 波形绘制 https://github.com/wallento/wavedrompy GDB 8.3 发布 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=GDB-8.3-Debugger-Released 命令行自动搜索 StackOverflow https://github.com/WindSoilder/hors 从 C 到 Rust 的翻译 https://github.com/immunant/c2rust SHA-1 碰撞攻击新进展 https://www.zdnet.com/article/sha-1-collision-attacks-are-now-actually-practical-and-a-looming-danger/ macOS 配置 AD 管理员组 https://derflounder.wordpress.com/2011/02/17/adding-groups-from-your-directory-service-to-your-macs-admin-group/ ssh 后自动安装并打开 code-server 同步配置 https://github.com/cdr/sshcode HTTP Sunset 头 https://tools.ietf.org/html/rfc8594  </description>
    </item>
    
    <item>
      <title>在 FPGA 上实现路由器（2）</title>
      <link>https://jiege.ch/hardware/router-on-fpga-2/</link>
      <pubDate>Wed, 15 May 2019 20:39:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/router-on-fpga-2/</guid>
      <description>前言 月初的时候，有了一个完整可用的路由器（上一篇系列博文），但当时测了一下速度，只有几十 Mb/s ，只要往上提就会失效，得 reset 才能继续。当时也先没管性能的事情，先把和 OS 交互的部分做了。现在又回头来做性能调优。
之前，逻辑部分的主频只有 10 MHz ，这自然不行，不提高肯定做不到千兆。于是试着把主频拉高， FIFO 加大，然后遇到了很多问题，慢慢修复了，学到了很多新知识，目前也接近千兆的水平了吧，贴图：
TCP 测速：
UDP 测速：
测试环境是 macOS 虚拟机外打虚拟机内，走网桥把虚拟机和一个 USB 网卡接起来，然后从另一个 USB 网卡打到路由器。
尝试 700Mb/s 接下来讲讲，在这个过程中遇到了什么问题，怎么解决的。第一个是速度过快就会挂，这肯定是丢包逻辑没写对，后来在仿真里开够了时间，于是就找到了一个 BUG ，其实就是一行的修复。接着就是提高主频，但大家也知道，CPU不能随便超频，由于各种延迟的原因，比如 Setup 时间，如果超了一个时钟周期的时间，本来应该下个周期就得到新数据的，结果到了下下周期才有，那有的状态可能就乱了，我目前遇到的也主要就是这个问题。
于是就对着 Timing 里汇报的各种问题修啊修，发现了很多以前没有注意到的问题，它们不影响功能，但是会让逻辑变慢。第一个问题是 High Fanout ，以上就是说一个输出接到了很多输入，这看起来没啥问题，但数设课上也讲过，每个门的输入输出电流是有限制的，例如按书上的数据，一个门输出只能带十个门，更多只能级联一层。级联的话，延迟自然就高了。后来发现，这里的原因是，开了一个大的数组，但是没有变成 RAM ，综合出了几千个逻辑单元，自然是出问题。解决方法很简单，用 xpm_memory_tpdram 即可。这样一搞，主频就能上 200MHz 了。
这个时候测了一下，发现 UDP 能打到 700Mb/s 了，TCP 由于丢包率比较高，只有 400Mb/s ，距离预期还有一段距离。于是继续进行优化。
向 900Mb/s 进发 要继续提速，自然要提高主频。下一个主频目标就是 250MHz 。随着提高主频，时序的要求也会更高，自然也出现了新的问题。
这次的问题主要在于，一个路径上逻辑门数过多，多的有7到10个，每一步零点几到一点几纳秒，叠起来4纳秒哪里够用。于是把一些不需要依赖条件的逻辑挪到条件外面，这样就减少了一些路径的依赖。
解决了这个以后，现在的 WNS （Worst Negative Slack）只剩下 0.6 ns 了。这时候的问题一部分还是来自于逻辑门过多，但这个时候就没这么简单了，只能继续细化流水线，打一拍，这样才能把延迟降下来。
虽然 Timing 没有完全解决，但还是写进了 FPGA 中。幸好工作一切正常，就得到了上面那个图片的结果，接近千兆的速度了。</description>
    </item>
    
    <item>
      <title>每周分享第 23 期</title>
      <link>https://jiege.ch/misc/2019/05/11/weekly-sharing-23/</link>
      <pubDate>Sat, 11 May 2019 09:00:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/05/11/weekly-sharing-23/</guid>
      <description> VS Code Remote https://code.visualstudio.com/blogs/2019/05/02/remote-development Rust 命令行看图片 https://github.com/atanunq/viu GCC 9.1 发布 https://readhacker.news/s/42Ruk Rust 的 Unikernel https://github.com/hermitcore/libhermit-rs Rust 的 QRCode 库 https://www.reddit.com/r/rust/comments/bk7z2x/announcing_bardecoder_a_qr_detector_and_decoder/ 鲁迅说过搜索引擎 http://cx.luxunmuseum.com.cn/ JIT 的 golang REPL https://github.com/gijit/gi Github 私有 Package Repo https://github.com/features/package-registry  </description>
    </item>
    
    <item>
      <title>给 Rocket Chip 挂接串口外设</title>
      <link>https://jiege.ch/os/2019/05/08/axi-uart-interrupt/</link>
      <pubDate>Wed, 08 May 2019 11:04:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2019/05/08/axi-uart-interrupt/</guid>
      <description>前沿 最近在给 rCore 添加 Rocket Chip 支持。下面讲讲最近做了哪些工作，遇到了哪些坑，都是怎么解决的。
踩坑过程 Rocket Chip 运行代码 首先分析了一下已有的代码和工作方式，这个 Rocket Chip （ucb-bar/fpga-zynq）的设计大概是这样的：在 PS 上通过 fesvr 向 Rocket Chip 写入程序。Rocket Chip 本身暴露出一个 TSI ，一个串口的调试接口，通过 Zynq Adapter 挂到了 PS 下的 AXI 总线，暴露出若干个寄存器，大概如下：
/** * Address Map * 0x00 - serial out FIFO data * 0x04 - serial out FIFO data available (words) * 0x08 - serial in FIFO data * 0x0C - serial in FIFO space available (words) * 0x10 - system reset * 0x20 - req FIFO data * 0x24 - req FIFO data available (words) * 0x28 - data FIFO data * 0x2C - data FIFO data available (words) * 0x30 - resp FIFO data * 0x34 - resp FIFO space available (words) * 0x38 - nsectors * 0x3C - max request length */  前面的是调试接口，后面的是 block device 和 network ，我们暂时还没有用到这些 UCB BAR 做的私货。在 Vivado 中，地址 Offset 是 0x43C00000 ，所以代码中就这样访问对应的物理地址：</description>
    </item>
    
    <item>
      <title>每周分享第 22 期</title>
      <link>https://jiege.ch/misc/2019/05/03/weekly-sharing-22/</link>
      <pubDate>Fri, 03 May 2019 07:38:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/05/03/weekly-sharing-22/</guid>
      <description> AXI-Stream Components https://github.com/alexforencich/verilog-axis go self update 库 https://github.com/rhysd/go-github-selfupdate Atomic Pi https://www.cnx-software.com/2019/04/26/buy-atomic-pi-cherry-trail-sbc/ 静态网站生成器 Hugo https://github.com/gohugoio/hugo C++ enum 的反射 https://github.com/Neargye/magic_enum 又一个开源的反编译器 https://github.com/BoomerangDecompiler/boomerang  </description>
    </item>
    
    <item>
      <title>把博客生成器从 Jekyll 迁移到 Hugo</title>
      <link>https://jiege.ch/meta/2019/05/02/migrate-from-jekyll-to-hugo/</link>
      <pubDate>Thu, 02 May 2019 12:15:00 +0800</pubDate>
      
      <guid>https://jiege.ch/meta/2019/05/02/migrate-from-jekyll-to-hugo/</guid>
      <description>Jekyll 生成一次实在太慢，忍受不了，于是换成了 Hugo 。为了保持链接不变，花了不少的时间在重命名上，不过目前似乎都完成了，希望没有导致 404 的问题。
新的主题还是好看很多的。Enjoy！</description>
    </item>
    
    <item>
      <title>在 Linux 中用 C 代码获取 DNS 服务器列表</title>
      <link>https://jiege.ch/software/get-resolvers-in-c/</link>
      <pubDate>Tue, 30 Apr 2019 17:39:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/get-resolvers-in-c/</guid>
      <description>最近在做一个作业的时候，发现里面有个步骤是获取 Linux 系统中的 DNS 服务器列表，它的方法很粗暴，直接 cat grep cut 再处理。我就在想有没有完全代码的实现，然后搜了一下，果然有：
#include &amp;lt;resolv.h&amp;gt; // ... res_init(); // _res.nsaddr_list is an array of resolvers  用到了全局变量 _res ，虽然很 hacky ，但是至少是工作的，不清楚兼容性几何。</description>
    </item>
    
    <item>
      <title>每周分享第 21 期</title>
      <link>https://jiege.ch/misc/2019/04/27/weekly-sharing-21/</link>
      <pubDate>Sat, 27 Apr 2019 08:34:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/04/27/weekly-sharing-21/</guid>
      <description>来了来了
 Rust stackful generator 库 https://github.com/Xudong-Huang/generator-rs wireshark tui https://termshark.io/ Pythonm 加 annotation 的调试 https://github.com/cool-RR/PySnooper Haskell 又一个教程 https://github.com/alpacaaa/zero-bullshit-haskell 直接在 Rust 中写 Python https://docs.rs/inline-python/0.2.0/inline_python/ 直接把 regex 捕捉到的 group 丢到 struct 里 https://crates.io/crates/recap XDP 层的抓包 https://github.com/cloudflare/xdpcap AWS 开始提供香港的云服务 https://www.allthingsdistributed.com/2019/04/aws-region-asia-pacific-hong-kong.html  </description>
    </item>
    
    <item>
      <title>在 FPGA 上实现路由器</title>
      <link>https://jiege.ch/hardware/router-on-fpga/</link>
      <pubDate>Wed, 24 Apr 2019 19:41:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/router-on-fpga/</guid>
      <description>最近在做 FPGA 上硬件的路由器，感觉接近一个基本可用的阶段了吧，大概谈一谈做这个的思路、过程和踩过的坑。
首先，做实验用的板子是 Alinx AX7021 ，FPGA 是 Xilinx xc7z020clg484-2 ，扩展板上有 4PL+1PS 个网口和千兆 KSZ9031RNX PHY ，采用的接口是 RGMII 。一开始做的自然是做 RGMII ，但是遇到了困难，RGMII在千兆模式下传输的是 DDR 信号，而时序和延迟就是个比较麻烦的事情。一开始先直接拿 Xilinx 的 AXI Ethernet IP 来用，然后上 ILA 看到了 IDDR 后的信号，第一次看到了完整的以太网帧，从 Preamble 和 SFD 到最后的 FCS 。于是就特别振奋，想着手写 RGMII ，先做收，再做发。确实，收很容易，很快就做出来了，但是写总是出问题，当时也不懂跨时钟域的一些问题，总之各种没调出来。于是就退而求其次，选择了 Xilinx 的 Tri Mode Ethernet IP 了。
Tri Mode Ethernet IP 有很多选项，为了简单，直接采用了 AXI-Stream 的接口，不要 AXI4-Lite 什么的，都不要，因为我需要直接写剩余的逻辑。其他东西能省也都省掉了。这个 IP 确实很给力，很快就可以完成收和发的操作了，这次终于知道了怎么处理跨时钟域的问题 — XPM FIFO ASYNC ，一下推进了很大的进度。
既然可以收，也可以发了，就扩展到多个网口。这个 IP 中可以选择 Shared Logic 在内部，也可以在外部，研究了一下发现，应该是一个放内部，其余选外部，然后接起来就可以了。不过目前为了简单，还是只用了俩端口。在这个基础上，就开始解析收进来的以太网帧了。
第一步自然是填 ARP 表，自然问题来了，如果多个网口同时进来数据，怎么保证 ARP 表读写的正确性？自然就想到总线上需要做仲裁，于是写了一个简单的总线仲裁，顺带学习到了 unique case(z) 和 priority case(z) 的语法。然后 ARP 表怎么实现呢，大概就是一个哈希表，然后表里维护了（IP，MAC，PORT）三元组，然后实现了一些冲突和覆盖的处理逻辑，做这些的同时也对各个模块编写相应的测试。有了 ARP 表，就可以在解析以太网帧的时候，拆解出里面的信息，然后请求 ARP 表总线，然后写入。</description>
    </item>
    
    <item>
      <title>jiegec.xyz 域名即将停用</title>
      <link>https://jiege.ch/misc/2019/04/22/jiegec-xyz-down/</link>
      <pubDate>Mon, 22 Apr 2019 11:42:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/04/22/jiegec-xyz-down/</guid>
      <description>最早买域名的时候，买的是 jiegec.xyz ，后来发现了更好的域名，于是这个老域名一直就是一个简单的网页转址。很快，它就要过期了，我也不打算续费了，大家继续用我的新域名吧。
P.S. 忽然发现我之前配的 acme.sh 没有配自动 nginx -s reload ，所以之前 ssl 证书时间凉了。</description>
    </item>
    
    <item>
      <title>每周分享第 20 期</title>
      <link>https://jiege.ch/misc/2019/04/20/weekly-sharing-20/</link>
      <pubDate>Sat, 20 Apr 2019 22:42:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/04/20/weekly-sharing-20/</guid>
      <description>写到了第 20 期了！最近几期总是在咕咕。
 Rust 的科学计算库 https://github.com/rust-ndarray/ndarray https://github.com/jturner314/ndarray-stats Rust Crate 生态可视化 https://rfdonnelly.github.io/crate-galaxy/ 在地址栏里做动画 http://matthewrayfield.com/articles/animating-urls-with-javascript-and-emojis/#%F0%9F%8C%92 Ruby 3 也要加类型了 https://twitter.com/darkdimius/status/1119115657776209920 verilog 的 MAC + 简易网络栈 https://github.com/alexforencich/verilog-ethernet  </description>
    </item>
    
    <item>
      <title>每周分享第 19 期</title>
      <link>https://jiege.ch/misc/2019/04/15/weekly-sharing-19/</link>
      <pubDate>Mon, 15 Apr 2019 01:03:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/04/15/weekly-sharing-19/</guid>
      <description>忽然想起来忘了这件事情两天。。
 Pock 在 Touchbar 中显示并控制 Dock https://pock.pigigaldi.com/ MacBook touchbar+keyboard+touchpad Linux 驱动 https://github.com/roadrunner2/macbook12-spi-driver Kendryte K210 上的 GBA 模拟器 https://github.com/44670/mgba-k210 Rust 生成 PDF 文件的库 https://github.com/J-F-Liu/lopdf 中科大用 Rust 编写 FreeRTOS 的实验 https://github.com/OSH-2019/x-rust-freertos Google 发布 Cloud Code 插件，直接在 k8s 上调试运行 https://cloud.google.com/blog/products/devops-sre/announcing-cloud-code-accelerating-cloud-native-application-development 通过 libusb 跨平台的 usbip server https://github.com/jwise/pyusbip Linux 下 BCM43602 Firmware 问题的不完美解决方法 https://bugzilla.kernel.org/show_bug.cgi?id=193121 给树莓派上电的新方法 https://youtu.be/X2vF9KAEJx8 Docker 里跑 Deepin Wechat 的镜像 https://github.com/bestwu/docker-wechat.git NS Switch 的包管理器 https://switchbrew.org/wiki/Main_Page  </description>
    </item>
    
    <item>
      <title>rCore 软路由实现</title>
      <link>https://jiege.ch/software/rcore-soft-router/</link>
      <pubDate>Sun, 07 Apr 2019 12:13:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/rcore-soft-router/</guid>
      <description>最近在研究软路由在 rCore 上的实现，但限于硬件限制，目前先在虚拟机里测试。软路由大概要做这些东西：
1. 抓包，解析包里的内容 2. 查路由表，找到下一跳在哪 3. 查ARP，知道下一跳的 MAC 地址 4. 减少TTL，更新 IP Checksum 5. 把包发出去  第一步直接拿 smoltcp 的 Raw Socket 即可，但是目前只能抓指定 IP Protocol 的包，我用的是 ICMP ，但其他的就还抓不了，需要继续改 Smoltcp 源代码。
第二步用的是之前刚修好的 treebitmap 库，它提供了路由表的查询功能，目前路由表还是写死的，之后会用已经部分实现好的 Netlink 接口读取出来。
第三步则是 ioctl 发请求，然后从 smoltcp 内部的 ARP cache 里读取。
第四步很简单，不用多说。
第五步则需要指定出端口，用了一个 index ，放在一个特定的 sockaddr 中。
最后的效果就是，能双向转发 ping 通。
网络拓扑：
可以，这很玄学。
后续在想在真机上实验，但是还缺一个网卡驱动，不然就可以用神奇的办法来做这个实验了。</description>
    </item>
    
    <item>
      <title>每周分享第 18 期</title>
      <link>https://jiege.ch/misc/2019/04/05/weekly-sharing-18/</link>
      <pubDate>Fri, 05 Apr 2019 23:35:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/04/05/weekly-sharing-18/</guid>
      <description>不咕不咕
 Alfred pwgen workflow https://github.com/deanishe/alfred-pwgen 魔改主板，在老主板上放 16GB 内存 https://readhacker.news/s/3Zty4 Mesalink TLS 库的 Rust 实现 https://github.com/mesalock-linux/mesalink 实测可用 Rust 写的 STM32 应用 https://github.com/lupyuen/stm32-blue-pill-rust 开源 PCIe 核 https://github.com/enjoy-digital/litepcie  欢迎投稿。</description>
    </item>
    
    <item>
      <title>高云 FPGA 踩坑</title>
      <link>https://jiege.ch/programming/2019/04/01/gowin-fpga/</link>
      <pubDate>Mon, 01 Apr 2019 09:00:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/04/01/gowin-fpga/</guid>
      <description>最近拿到了高云 FPGA GW2A-18 开发版，想在这上面做一些小工程。不过首先要配置好环境什么的。官方提供了 Linux 和 Windows 的两套工具，自然是拥抱 Linux 咯，但是由于官方适配的是 Redhat 系的操作系统，所以用 Debian 系的时候出现了若干问题，后面会谈到怎么解决的。
首先是官网下载了它的软件，大概有IDE，综合器，布线器和Programmer四个工具，然后开始跑，发现缺少了 libcrypt.so.1.0.0 。上网搜了一下解决方案，需要重新编译 openssl-1.0.0 ，于是下载并且编译了 openssl-1.0.0t 并且把 .so 的路径调好了，这时候就可以打开 IDE 了。然后发现需要 License ，这个很简单，去官网申请一下，一天邮件就下来了。
接下来配置 License， IDE 很容易，直接选择邮件里发下来的 node-locked License 即可。不过 Synplify Pro 的 Linux 版本不支持直接单文件 node-locked 的 License ，只允许跑 SCL … 不过高云也提供了 SCL 的下载，和 IDE 的 License Server 放在一起，安装完以后，在得到的 License 里加上两行：
SERVER ${hostname} ${hostid} ${port} VENDER snpslmd /path/to/scl/2018.06/linux64/bin/snpslmd  然后把 $LM_LICENSE_FILE 指向这个文件路径，就可以了。这一部分感谢 @Jackey-Huo。
随手写了一个简化版的点亮数字人生（没有数码管），得到了 bistream ，准备往板子里刷，然后问题出现了：</description>
    </item>
    
    <item>
      <title>每周分享第 17 期</title>
      <link>https://jiege.ch/misc/2019/03/31/weekly-sharing-17/</link>
      <pubDate>Sun, 31 Mar 2019 12:32:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/03/31/weekly-sharing-17/</guid>
      <description>对不起咕咕了两天。。
 关于 rel=&amp;ldquo;noopener&amp;rdquo; 的一些细节 https://mathiasbynens.github.io/rel-noopener Microsft Defender 推出 macOS 版 https://arstechnica.com/gadgets/2019/03/microsoft-ships-anti-virus-for-macos-as-windows-defender-becomes-microsoft-defender/ 基于 Docker 的快速启动在线 Linux box https://github.com/instantbox/instantbox rust 在窗口中显示 fb 的库 https://github.com/emoon/rust_minifb Vue 列表空间，为大量数据设计 https://github.com/tangbc/vue-virtual-scroll-list musl 各平台的交叉编译工具链 https://musl.cc/ 在线的 markdown 转 pdf https://md2pdf.netlify.com/ 一本关于 C64 的书 http://10print.org/ 转自 dram &amp;ldquo;haskutil tql，自动更新 import，自动 {-# LANGUAGE #-} ，自动填 hole&amp;rdquo; https://github.com/EduardSergeev/vscode-haskutil ZFS on Linux 加入 TRIM 支持 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=ZFS-On-Linux-TRIM-Lands 又一个体现 JS 玄学之处的网站 https://getify.github.io/coercions-grid/  </description>
    </item>
    
    <item>
      <title>静态编译 sqlite3</title>
      <link>https://jiege.ch/software/static-building-sqlite/</link>
      <pubDate>Sun, 24 Mar 2019 19:13:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/static-building-sqlite/</guid>
      <description>最近 rCore 支持了动态链接库，于是想着在测试 sqlite 的时候直接用动态的，不过出现了玄学的问题，它会访问一个不存在的地址，看代码也没看出个所以然来。所以研究了一下 sqlite 的静态编译。首先在 configure 的时候尝试了一下：
$ ./configure CC=x86_64-linux-musl-gcc --disable-shared --enabled-static  发现 libsqlite 确实是静态了，但是 sqlite3 并不是。一番研究以后，发现是 libtool 的原因，只要这样编译：
$ make LTLINK_EXTRAS=-all-static  就可以编译出静态的 sqlite3 ：
sqlite3: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped  </description>
    </item>
    
    <item>
      <title>每周分享第 16 期</title>
      <link>https://jiege.ch/misc/2019/03/22/weekly-sharing-16/</link>
      <pubDate>Fri, 22 Mar 2019 23:27:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/03/22/weekly-sharing-16/</guid>
      <description>继续沉迷写 OS +1
 C++ 的一个比较 fancy 的 format 库 https://github.com/fmtlib/fmt Rust 的 rsync 替代品 https://github.com/wchang22/lumins VirtIO 1.1 要发布了 https://github.com/oasis-tcs/virtio-docs/commit/3b4130f3a8910dad89b8166e06e58806b9c60943 向二维码嵌入图片的工具 http://cgv.cs.nthu.edu.tw/Projects/Recreational_Graphics/Halftone_QRCodes/ Google Chrome 发出奇怪的 DNS 请求的原因 https://unix.stackexchange.com/questions/363512/chrome-dns-requests-with-random-dns-names-malware 转换 .HEIC 到 .jpg 的批量方案：alias heic=&amp;quot;magick mogrify -monitor -format jpg *.HEIC&amp;quot; ref: Apple SE 以打代码来练打字的网站 https://typing.io/ VSCode 网页 server https://github.com/codercom/code-server 奇特的 Rust 网页栈实现 https://japaric.github.io/jnet/jnet/index.html H265 解析 gui https://github.com/virinext/hevcesbrowser 之前介绍过 H264 的 Awesome Rust Embedded https://github.com/rust-embedded/awesome-embedded-rust 新的 SiFive 产品 https://www.crowdsupply.com/sifive/hifive1-rev-b Wireshark 3.0.0 发布 https://www.</description>
    </item>
    
    <item>
      <title>交叉编译 Nginx 1.14.2 到 RISC-V</title>
      <link>https://jiege.ch/software/cross-compiling-nginx-to-riscv/</link>
      <pubDate>Fri, 22 Mar 2019 23:18:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/cross-compiling-nginx-to-riscv/</guid>
      <description>最近又把一定的精力放到了 RISC-V 64 上的 rCore 用户态程序的支持上，同时也借到了 HiFive Unleashed 板子，所以有真实硬件可以拿来跑了。在这之前先在 QEMU 上把能跑的都跑起来。
由于 rCore 对 glibc 的支持一直有问题，RISC-V 也不例外，所以还是选择用 musl 来做这件事情。一般搜索，终于找到了 Linux 下能用的 musl-riscv-toolchain 。编译好工具链以后，很多需要 libc 的用户态都能跑了，于是想着试一下 nginx 的编译。试着编译了一下，遇到了各种问题，最后搜到了交叉编译Hi3536上面使用的nginx，里面的方法解决了这个问题。最后总结出了这样的 patch :
diff --git a/nginx-1.14.2/auto/cc/name b/nginx-1.14.2/auto/cc/name index ded93f5..d6ab27a 100644 --- a/nginx-1.14.2/auto/cc/name +++ b/nginx-1.14.2/auto/cc/name @@ -7,7 +7,7 @@ if [ &amp;quot;$NGX_PLATFORM&amp;quot; != win32 ]; then ngx_feature=&amp;quot;C compiler&amp;quot; ngx_feature_name= - ngx_feature_run=yes + ngx_feature_run=no ngx_feature_incs= ngx_feature_path= ngx_feature_libs= diff --git a/nginx-1.14.2/auto/lib/openssl/make b/nginx-1.14.2/auto/lib/openssl/make index 126a238..7a0e768 100644 --- a/nginx-1.14.2/auto/lib/openssl/make +++ b/nginx-1.</description>
    </item>
    
    <item>
      <title>在古老的 OS 上运行一个干净的新的环境</title>
      <link>https://jiege.ch/devops/new-clean-env-on-old-os/</link>
      <pubDate>Thu, 21 Mar 2019 22:46:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/new-clean-env-on-old-os/</guid>
      <description>由于某些课程的原因，需要在一个 CentOS 7 上跑一些编译和运行代码。看到这么古老的软件，我心想不行，肯定要找新一些的软件来用。首先想到的是 tmux ，于是按照网上的脚本 很快装了一个 tmux 2.8 版本，果然好了很多。但是常用的很多软件依然是个问题。试了一下最近比较新的 code-server ，因为ABI问题跑不起来。
于是开始想玩骚操作。首先想到的是 Gentoo Prefix ，不过既然是别人的机器，还是算了。又找了 fakeroot 配合 alpine rootfs 的方案，但编译不过，估计是内核版本问题。又试了一下 fakechroot ，但它需要配合 fakeroot 使用，这就凉了。
然后又找了一些替代方案。一是 uchroot ，但由于 CMake 版本太老也编译不过。最后发现了 PRoot ，直接提供 prebuilt 然后很容易就可以跑起来：
$ ./proot -b /proc -b /dev -r $CHROOT /bin/busybox sh  于是就进到了 alpine 的 rootfs 中，下载地址。进去以后发现没有编辑器，于是出来把 apk 的源改了，加了 resolv.conf ，就成功地安装了很多很新的软件了。</description>
    </item>
    
    <item>
      <title>每周分享第 15 期</title>
      <link>https://jiege.ch/misc/2019/03/16/weekly-sharing-15/</link>
      <pubDate>Sat, 16 Mar 2019 01:04:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/03/16/weekly-sharing-15/</guid>
      <description>继续沉迷写 OS
 嵌入 graphics for rust 可以绘制 bmp 了 https://wapl.es/rust/2019/03/04/embedded-graphics-0.4.7-bmp-support.html rustup component history 方便 nightly 日期选择 https://rust-lang.github.io/rustup-components-history/index.html grpcurl 用于 grpc 调试 https://github.com/fullstorydev/grpcurl grafana 6.0 is out http://docs.grafana.org/guides/whats-new-in-v6-0/ 康哥推荐的写论文工具： https://github.com/stsewd/ieee-pandoc-template  </description>
    </item>
    
    <item>
      <title>每周分享第 14 期</title>
      <link>https://jiege.ch/misc/2019/03/08/weekly-sharing-14/</link>
      <pubDate>Fri, 08 Mar 2019 18:25:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/03/08/weekly-sharing-14/</guid>
      <description>最近沉迷写 OS ，没怎么搜罗新的东西（
 用 Docker 做交叉编译 https://github.com/dockcross/dockcross#dockcross tar inplace extraction 有意思的思路 https://gitlab.com/antonok/taro los 16.0 发布 基于 Android Pie https://lineageos.org/Changelog-22/ Rust 1.33.0 Pin 进入 stable https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html Rust 用于编写 cli 软件的工具库 https://rust-lang-nursery.github.io/cli-wg/index.html 自动使用 CI 发布二进制 prebuilt 的模板 https://github.com/japaric/trust 转换 gif 到 xlsx 很神奇 https://github.com/pugwonk/gif2xlsx/blob/master/README.md Go REPL https://github.com/cosmos72/gomacro 基于区块链的论坛海星 其实是区块链数据库 https://github.com/CovenantSQL/CovenantForum Rime emoji 嵌入输入法 https://github.com/rime/rime-emoji 一个神奇的数据库 https://github.com/mit-pdos/noria 一个讲内核的 gitbook https://richardweiyang.gitbooks.io/kernel-exploring/ 用 React 写桌面控件 http://tracesof.net/uebersicht/  </description>
    </item>
    
    <item>
      <title>在 rCore 上运行 nginx</title>
      <link>https://jiege.ch/programming/2019/03/08/running-nginx-on-rcore/</link>
      <pubDate>Fri, 08 Mar 2019 18:07:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/03/08/running-nginx-on-rcore/</guid>
      <description>阿 西 吧 nginx 终于能在 rCore 上跑了 orrrrrrrz
通过这半个多月来的大量开发，我和王润基 @wangrunji0408 学长算是终于完成了第一个 milestone：跑起来一个 nginx 。遇到了很多困难，大概有这些：
 syscall 实现不全。各种方面都缺，然后 nginx 在编译的时候又检测到比较新的 OS 版本，所以很多 syscall 都用了新的来替代老的，例如 readv/writev pread/pwrite accept4 等等，所以这方面做了一些工作。另外，还有很多新的 syscall 进来，太多了我就不细说了，基本上一个commit做一点一个commit做一点这个样子。 nginx 用到了 SSE 的寄存器 xmm ，但是之前是没有开的。所以把 sse 打开，然后切换上下文的时候把 sse 通过 fxsave 保存和 fxrstor 恢复（有意思的是，as居然不认这俩，只好手动写字节码），然后为了 16bit 的对齐又写了几行汇编代码。这块问题不大，今天一会就搞定了。但是如果要性能更高一些的话，可能需要在第一次使用 xmm 的时候再开始保存，大概就是加一个bit的事情。 文件系统有点崩。实现还是有很多 BUG ，表现就是需要经常重新 mksfs 一下，再重启加载完好的 fs ，有时候强制关机一下就又崩了。 内存管理做了一些改变。为了实现更加完整的 mmap mumap 和 mprotect ，又发现了一些新的 BUG 在里面，然后慢慢修复了。就是实现的有点粗暴。 死锁问题。这个其实现在还会出现，只是还没调出来，也不会百分百出现。我们计划在锁上面做一些死锁检测，例如记住是谁上锁的，等等。现在就遇到一个很玄学的死锁问题。  然后代码也是一边在写一边在重构吧，很多地方现在都写得很粗暴，FIXME和TODO留了很多，很多地方也写得不够优雅。以后再慢慢重构+优化吧。
截图留念：
再往前的话，还有很多小的问题，例如网卡的中断启用了但没有改 mask ，所以啥也没收到，靠 QEMU Tracing 找到问题。还有一个很有意思的现象，就是如果 elf 的 program header 没有 phdr 这个项的时候，我们发现，可以通过第一个load（如果加载了完整的 elf 头的话），我们可以从这里推断出 phdr 的地址（load的虚拟地址加偏移），然后丢到 auxv 里去让 musl 配置 tls。总之这些都解决了。也不用去考虑兼容 litc 了，已经全部向 linux 靠拢了，稳。</description>
    </item>
    
    <item>
      <title>实现网络的 syscall</title>
      <link>https://jiege.ch/programming/2019/03/04/implement-network-syscalls/</link>
      <pubDate>Mon, 04 Mar 2019 16:40:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/03/04/implement-network-syscalls/</guid>
      <description>有了网卡驱动，接下来要做的就做网络的 syscall 了。为了测试，首先在 busybox 里找可以用来测试的 applet ，由于没有实现 poll ，所以 nc telnet 啥的都用不了。最后选择到了 ping 和 pscan 上。
ping大家都很了解，pscan就是一个扫端口的，对一个ip连续的若干个端口发起 tcp 请求。这就要求我提供 raw socket和tcp socket状态的支持。由于网络栈本身是异步的，但 read connect 这些函数在不调 setsockopt 的前提下又是同步的，然而现在又没有 signal 可以用，要是 block 了就再也出不来了。于是就采用了 Condvar 的办法，拿一个全局的条件变量，当 poll 不到内容的时候，先把线程拿掉，等到网络栈更新了，再恢复。这样至少不会把 cpu 也 block 住。
然后就是把 socket 部分改了又改吧，数据结构的设计改了几次，为了解决 ownership 问题上锁啊也有点多，但是也更细了，虽然实际上可能没有必要，因为上面还有大的锁。不过性能还不是现在考虑的重点，关键还要先把 send recv accept bind listen 啥的写得差不多了，然后还有把 poll/select 实现了，这个很关键。
中间遇到的最大的坑就是，接收 pci interrupt 的时候总是啥也没有，然后靠万能的 qemu trace 发现，原来是 mask 掉了，所以啥也收不了，然后最后的解决方案就是用 MSI Interrupt #55 搞定了这个问题。至于为啥是 55 呢，因为 23 + 32 = 55 啊（误</description>
    </item>
    
    <item>
      <title>每周分享第 13 期</title>
      <link>https://jiege.ch/misc/2019/03/01/weekly-sharing-13/</link>
      <pubDate>Fri, 01 Mar 2019 08:39:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/03/01/weekly-sharing-13/</guid>
      <description>今天还是早点发吧
 Rust concurrent work-stealing queue 可能可以放到调度器里用 https://github.com/kinghajj/deque 支持信用卡/时间等格式信息的输入控件 https://github.com/nosir/cleave.js Rust 的简单 http server https://github.com/svenstaro/miniserve Coroutines &amp;amp; Modules Added For C++20 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Coroutines-Modules-CPP20 Implementing TCP in Rust (part 1) https://www.youtube.com/watch?v=bzja9fQWzdA 一个类似 Vuetify 的框架 https://buefy.org/ systemd tmpfiles.d 用于管理特定的临时文件夹 https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html 获取 ASN 信息的 API https://bgpview.docs.apiary.io/#reference/0/asn-prefixes/view-asn-prefixes Rust getter/setter generation https://github.com/Hoverbear/getset Golang 1.12 发布：TLS 1.3 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Golang-1.12-Released 一个笑话 https://redd.it/aux77g Rust 的 STM https://github.com/mtak-/swym 自动同步视频和字幕 https://github.com/smacke/subsync 用于快速开发的 http server https://zeroserver.io/ 一个自动加载的 http server https://github.com/tapio/live-server 用 markdown 写 presentation 在线版 https://github.</description>
    </item>
    
    <item>
      <title>使用 Rust 实现 e1000 驱动</title>
      <link>https://jiege.ch/programming/2019/02/26/network-driver-again/</link>
      <pubDate>Tue, 26 Feb 2019 20:30:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/02/26/network-driver-again/</guid>
      <description>是的。我又来了。上次做了使用 Rust 实现 VirtIO 驱动之后，继续往 rCore 加更多的驱动支持。由于现在工作重点是 x86_64 下的 syscall 实现，所以选了一个比较有代表性的驱动 e1000 来实现。其实如果只是为了在 qemu 下运行的话，其实只需要支持 virtio-pci 就可以了，原来的 virtio-net 直接拿来用就可以了。
为什么挑 e1000 呢，一方面是支持的设备多，有真实硬件可以测试，虽然不一定要裸机上跑，但是可以通过 PCI passthrough 来测试驱动的正确性。另一方面是网上的资料比较多，有现成的简单的代码可以借鉴。这次主要借鉴了三个来源：一是 Biscuit OS， 二是 Judge Duck OS ，三是 Linux 。
首先是实现了简单的 PCI 总线的枚举，然后找到对应的设备，激活，并且找到映射的内存地址，然后把原来 C 语言的实现搬运到 Rust 中。这个过程中遇到很多坑，例如一开始我以为内核里 pa 和 va 是一个固定的偏移，不过多次尝试后才发现这个假设只对 riscv 平台里的实现成立。
这个时候就可以收到外面给进来的以太网帧了。接着就是把它接入到 smoltcp 的 API 中。但是发包又不工作了，尝试了很多次，各种方法也不行。其中特别要提到的就是 qemu 的 tracing API ，它在帮助我调试之前的 virtio 驱动和这次的 e1000(e) 驱动中起到了很大的帮助。不过，遗憾的是，发包相关的代码里的 trace 不足以让我找到问题的所在，我只好采用了最后一招：
下载 QEMU ，自己改，然后自己编译。
这个方法果然很有效啊，经过简单的几个修改，很快就定位到问题所在了，原来就是一个简单的错误，把 4 写成了 8 。这个过程中我也发现 QEMU 在 incremental build 的时候似乎会 segfault ，我没管这么多，反正编译也不慢，次数也不多，每次 clean 再 build 问题也不大。</description>
    </item>
    
    <item>
      <title>每周分享第 12 期</title>
      <link>https://jiege.ch/misc/2019/02/23/weekly-sharing-12/</link>
      <pubDate>Sat, 23 Feb 2019 07:24:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/02/23/weekly-sharing-12/</guid>
      <description>看脑王迟到了（
 Rust Embedded Graphics 库 https://github.com/jamwaffles/embedded-graphics Wireguard for macOS https://lists.zx2c4.com/pipermail/wireguard/2019-February/003853.html Wireguard-go UI https://github.com/aequitas/macos-menubar-wireguard T2 逆向 https://duo.com/labs/research/apple-t2-xpc 脑王剪辑 https://www.bilibili.com/video/av43972717 dram 推荐的工具 notion.so 带授权和审计的 sudo https://github.com/square/sudo_pair rust 的 manpage 生成器 https://github.com/rust-cli/man 才发现 Github 有 Project 功能 https://help.github.com/en/articles/about-project-boards rust 的 elf/macho 生成 https://github.com/m4b/faerie rust 的 elf/macho/pe 读取 https://github.com/m4b/goblin rust 的 glob 实现 https://github.com/rust-lang-nursery/glob 基于 BoringSSL 的 rust 加密库 https://mundane.googlesource.com/mundane 从 linux 交叉编译到 macOS 的方法 https://github.com/tpoechtrager/osxcross cargo-deb 后又有了 cargo-rpm https://github.com/RustRPM/cargo-rpm 自带 diff 的 assert_eq 宏 https://github.</description>
    </item>
    
    <item>
      <title>预告 Learn-Project 4.0 版</title>
      <link>https://jiege.ch/misc/2019/02/17/learn-project-preview/</link>
      <pubDate>Sun, 17 Feb 2019 13:04:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/02/17/learn-project-preview/</guid>
      <description>不知道大家听没听说过 Google Chrome 有个插件，叫做 Learn Project ，是一个网络学堂的改良前端。不过，随着网络学堂的不断更（xia）新（gao），它已经不再适用于现在的版本。于是，哈利橙（@Harry_Chen）决定利用寒假时间，在今天（2.17）之前完成 Learn Project 4.0 的开发。为什么叫 4.0 呢，因为哈利橙课程的 GPA 众数是 4.0 。这个版本采用先进的 React 框架编写（Vue 塞高），使用了 Material Ui 作为界面框架（这我觉得可以），目前的一个参考图（图源哈利橙）：
看那满眼的高分数，希望 Learn Project 4.0 能在 flag 倒下之前完成。</description>
    </item>
    
    <item>
      <title>每周分享第 11 期</title>
      <link>https://jiege.ch/misc/2019/02/16/weekly-sharing-11/</link>
      <pubDate>Sat, 16 Feb 2019 00:42:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/02/16/weekly-sharing-11/</guid>
      <description>对不起迟到了（
 Google 的 fuzzing 家族又来了个新成员 太喜欢造轮子了 https://github.com/google/clusterfuzz 有趣的文本生成工具 https://github.com/TheBerkin/rant 又一个 side channel attack https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2019/february/downgrade-attack-on-tls-1.3-and-vulnerabilities-in-major-tls-libraries/ 来自 Prof Fan 的一个 cf dns 权限限制分发的工具 https://github.com/ProfFan/cloudflare-proxy-rs 部署到了我的博客的小工具 大家体会到了吗 https://instant.page/ 教育性质的 C on web https://vasyop.github.io/miniC-hosting/ 激活清华教育版 win10? &amp;ndash;&amp;gt; dig +short TXT win10.harrychen.xyz windows95 v2.0 发布（误 https://github.com/felixrieseberg/windows95/releases/tag/v2.0.0 已经部署到 tuna 的 rustup-mirror crate https://github.com/jiegec/rustup-mirror Forth 也能有 http 服务端框架 http://www.1-9-9-1.com/ bartender 的开源替代 实测可用 https://github.com/Mortennn/Dozer 给不支持 pac 的客户端在 http proxy 上套一层 https://github.com/williambailey/pacproxy  </description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（9）</title>
      <link>https://jiege.ch/programming/2019/02/12/thoughts-on-stanford-cs140e-9/</link>
      <pubDate>Tue, 12 Feb 2019 11:35:00 +0400</pubDate>
      
      <guid>https://jiege.ch/programming/2019/02/12/thoughts-on-stanford-cs140e-9/</guid>
      <description>距离上一篇 CS140e 系列文章已经过去了很久，距离第一篇文章过了一年零几天。在后来这一段时间内，CS140e 结束了课程，又开始了新一年的 winter 2019 课程，迎来的却是 C 版本的 CS140e ，不禁让人感到失望。还好，Sergio Benitez 放出了原来的 CS140e 的镜像，如果大家仍然想回去查看原版优质的 CS140e ，可以点进去参考。
后来因为机缘巧合参与到了清华的 Rust OS 课程，又想到回来把原来的 CS140e 进行更新，于是顺带把跑在 QEMU 下的一些需要的工作给做了，另外把 Rust nightly 版本更新了（一年前的 nightly 还能叫 nightly ？），才发现标准库变化还是蛮大的，由于 nightly 版本变了，而且原来是内嵌了一个阉割过的 std ，所以主要是从新的 std 里抄代码到内嵌的 std 中。另外，原来的 xargo 也不再维护了，转而使用 rust-xbuild 进行交叉编译。
然后又顺手实现了 backtrace 和从 backtrace 中配合 dward symbols 找函数名的功能，不过实践证明，这些东西还是 addr2line 做得更好，所以也就没有做下去，在 relocation 上也是遇到了各种问题。这个经验也是应用到了 rCore 那边。
再之后也就是寒假写驱动了，见之前的一个博文，我就没有在 CS140e 上去实现它了。有时间有兴趣的时候再考虑做一下 Raspberry Pi 的网卡驱动吧。
写于迪拜雨天。</description>
    </item>
    
    <item>
      <title>每周分享第 10 期</title>
      <link>https://jiege.ch/misc/2019/02/08/weekly-sharing-10/</link>
      <pubDate>Fri, 08 Feb 2019 15:52:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/02/08/weekly-sharing-10/</guid>
      <description>新年快乐！
 Haskell to WASM compiler https://github.com/tweag/asterius A ssh tarpit that sends endless banner https://github.com/skeeto/endlessh Use rust to write UEFI app https://github.com/rust-osdev/uefi-rs 神奇的小游戏 https://yeahpython.github.io/game/game.html 又一个后端 rust web 框架 https://github.com/seanmonstar/warp 挺酷的一个网站 https://github.com/pomber/github-history ws 调试工具 https://github.com/vi/websocat React Hooks 进入正式版 https://reactjs.org/blog/2019/02/06/react-v16.8.0.html 又一个关于硬件的 wiki https://wikidevi.com/wiki/Main_Page virtio-fs 项目 旨在替代 virtio-9p https://virtio-fs.gitlab.io/ SergioBenitez 镜像了一份去年的 CS140e https://cs140e.sergio.bz/  </description>
    </item>
    
    <item>
      <title>每周分享第 9 期</title>
      <link>https://jiege.ch/misc/2019/02/01/weekly-sharing-9/</link>
      <pubDate>Fri, 01 Feb 2019 19:16:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/02/01/weekly-sharing-9/</guid>
      <description>IDA Loader plugin for some Nintendo rom https://github.com/w4kfu/IDA_loader websocket daemon http://websocketd.com/ 实时的游戏开发器 https://script-8.github.io/ 硬核逆向 Leica 相机的固件 https://alexhude.github.io/2019/01/24/hacking-leica-m240.html 做 CTF 时遇到的整数溢出的 CVE https://www.anquanke.com/post/id/104182 发现一个 speedtest 的轮子 https://github.com/adolfintel/speedtest 西数的 RISCV 核实现 https://github.com/westerndigitalcorporation/swerv_eh1 iOS 12.2 会有更多的 PWA 兹瓷 https://twitter.com/mhartington/status/1089292031548145666 代替死去的 git-up: git config &amp;ndash;global alias.up &amp;lsquo;pull &amp;ndash;rebase &amp;ndash;autostash&amp;rsquo; 利用已知明文破解旧版加密 zip 的工具 https://github.com/kimci86/bkcrack 在线看 jwt 内容 https://jwt.io/ JS 的 Lua VM https://github.com/fengari-lua/fengari 鲁棒但不优雅的前端 KV https://github.com/gruns/ImmortalDB Emacs Modules doc https://phst.eu/emacs-modules 用 IPv6 的 Flow Label 实现类似 MPLS 的效果 https://github.</description>
    </item>
    
    <item>
      <title>使用 Rust 实现 VirtIO 驱动</title>
      <link>https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation/</link>
      <pubDate>Tue, 29 Jan 2019 17:23:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation/</guid>
      <description>背景 最近在给 rCore 添加驱动层的支持。一开始是想做网卡驱动，后来发现， qemu-system-riscv32 只支持如下的驱动：
# qemu-system-riscv32 -device help Storage devices: name &amp;quot;scsi-cd&amp;quot;, bus SCSI, desc &amp;quot;virtual SCSI CD-ROM&amp;quot; name &amp;quot;scsi-disk&amp;quot;, bus SCSI, desc &amp;quot;virtual SCSI disk or CD-ROM (legacy)&amp;quot; name &amp;quot;scsi-hd&amp;quot;, bus SCSI, desc &amp;quot;virtual SCSI disk&amp;quot; name &amp;quot;virtio-blk-device&amp;quot;, bus virtio-bus name &amp;quot;virtio-scsi-device&amp;quot;, bus virtio-bus Network devices: name &amp;quot;virtio-net-device&amp;quot;, bus virtio-bus Input devices: name &amp;quot;virtconsole&amp;quot;, bus virtio-serial-bus name &amp;quot;virtio-keyboard-device&amp;quot;, bus virtio-bus name &amp;quot;virtio-mouse-device&amp;quot;, bus virtio-bus name &amp;quot;virtio-serial-device&amp;quot;, bus virtio-bus name &amp;quot;virtio-tablet-device&amp;quot;, bus virtio-bus name &amp;quot;virtserialport&amp;quot;, bus virtio-serial-bus Display devices: name &amp;quot;virtio-gpu-device&amp;quot;, bus virtio-bus Misc devices: name &amp;quot;loader&amp;quot;, desc &amp;quot;Generic Loader&amp;quot; name &amp;quot;virtio-balloon-device&amp;quot;, bus virtio-bus name &amp;quot;virtio-crypto-device&amp;quot;, bus virtio-bus name &amp;quot;virtio-rng-device&amp;quot;, bus virtio-bus  所以要实现网卡的话，只能实现这里的 virtio-net-device ，而 VirtIO 驱动之间有很多共通的地方，于是顺带把 gpu mouse 和 blk 实现了。</description>
    </item>
    
    <item>
      <title>THUWC 2019 小记</title>
      <link>https://jiege.ch/misc/2019/01/25/thuwc-2019/</link>
      <pubDate>Fri, 25 Jan 2019 11:00:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/01/25/thuwc-2019/</guid>
      <description>前段时间，以工作人员的身份参加了在广州二中举办的 THUWC 2019 。作为一只菜鸡 OI 选手，我没想到过我会以另一种身份参与一个我本来没能参与的活动，就好像以暑校辅导员的身份参与清华暑校一样。
提早来到了赛场，布置场地，然后把机考的各个流程都过一遍，记住各个细节，各方面都有条不紊地进行，看着第一场前同学们特别激动地冲入考场，到最后一场同学们考完后的释放，在同学们身上看到了很多不成熟的样子，看到了兴奋想要和同伴分享的喜悦，也看到了不甘的眼泪。
希望各位强大的选手们可以来到九字班、零字班乃至一字班，享受课改的乐趣吧嘿嘿嘿</description>
    </item>
    
    <item>
      <title>每周分享第 8 期</title>
      <link>https://jiege.ch/misc/2019/01/25/weekly-sharing-8/</link>
      <pubDate>Fri, 25 Jan 2019 10:58:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/01/25/weekly-sharing-8/</guid>
      <description>这周更加忙了，所以内容不多。
 Rust 1.32.0 is out 其中 dbg macro 挺有意思 https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html 在线的 hex packet decoder https://hpd.gasmi.net/ Rust Cheatsheet https://www.breakdown-notes.com/make/load/rust_cs_canvas/true Rust tcp/ip stack https://github.com/m-labs/smoltcp 逆向 CAJ 的转换器 https://github.com/JeziL/caj2pdf  </description>
    </item>
    
    <item>
      <title>每周分享第 7 期</title>
      <link>https://jiege.ch/misc/2019/01/18/weekly-sharing-7/</link>
      <pubDate>Fri, 18 Jan 2019 21:10:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/01/18/weekly-sharing-7/</guid>
      <description>这周比较忙，所以内容不多。
 在嵌入式系统里跑 Lisp 可以在串口开个 repl 在线调试 http://www.ulisp.com/show?3J Pattern matching for C++ https://github.com/solodon4/Mach7 一个商业版的类似 ASan 的产品 不知道效果如何 https://stensal.com/ 用 Python 写 Cocoa 界面还行 https://dawes.wordpress.com/2017/08/17/python-with-a-cocoa-gui-on-macos/ Rust 实现的权威搜索引擎 https://github.com/toshi-search/Toshi Rust Embedonomicon 讲述 Rust 在 bare metal 下的一些神奇操作 https://docs.rust-embedded.org/embedonomicon/preface.html 发现另一个基于 Github 的 Disqus 替代品 https://utteranc.es/ 挺好的一部讲 Rust 生命周期的小书 http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html 跨平台的 Ctrl-C 处理 for Rust https://github.com/Detegr/rust-ctrlc 用 Rust 写 stm32 上程序所需要的库 https://github.com/stm32-rs/stm32-rs go 语言编写的基于 fuse 的加密文件系统 https://github.com/rfjakob/gocryptfs Rust 的图片解析库 https://github.com/PistonDevelopers/image 用 BPF 做 API 解析和过滤 https://github.</description>
    </item>
    
    <item>
      <title>实现 VSCodeVim 中支持中文分词的单词移动</title>
      <link>https://jiege.ch/software/vscode-vim-chinese-word-motion/</link>
      <pubDate>Wed, 16 Jan 2019 00:15:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/vscode-vim-chinese-word-motion/</guid>
      <description>最近用 VS Code 写中文 LaTeX 比较多，但是编辑起来总是比较麻烦，不能用各种带 w 的 motion ，不然整行都没了。于是 @xalanq 提出能不能拿一个 JS 的分词库，魔改一下 VSCode Vim 来得到同样效果？答案是可以的。
最后代码在 jiegec/VSCodeVimChinese 里，还没有合并到上游的打算。不定期根据上游发版本同步更新，在 Github Release 里发布 vsix 文件，目前版本为 v1.0.1。在 VS Code 里 Extensions: Install from VSIX... 即可安装。
经过对代码的研究，发现对 motion w 的处理都是通过 getWordLeft getWordRight 和 getCurrentWordEnd 完成的。于是我修改了这三个函数，根据原来的返回值把字符串喂给分词器，再返回的新的位置。一开始用的是 nodejieba ，但是因为需要用到 node-gyp 遇到了 Node 版本不兼容的问题，于是换了一个纯 Node 的实现 node-segment ，就完成了这个功能。</description>
    </item>
    
    <item>
      <title>Grafana 中可视化 Ping 时把 Timeout 显示为指定值</title>
      <link>https://jiege.ch/software/grafana-influxdb-visualize-ping/</link>
      <pubDate>Sun, 13 Jan 2019 18:36:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/grafana-influxdb-visualize-ping/</guid>
      <description>刚遇到一个需求，就是用 Telegraf 收集 ping 信息，然后在 Grafana 里可视化当前的延迟，如果超时了，就显示一个指定值，如 999 ，这样就可以放到一个 Gauge 里面可视化了。但是，问题在于，Telegraf 的 ping input 在超时的时候只会在 result_code 里写一个 2 ，其他项都是空的，因而如果直接用 GROUP BY time(interval) fill(999) 会导致最新的一个数据经常得到 999 。这意味着需要根据 &amp;ldquo;result_code&amp;rdquo; 来进行区分 Timeout 的情况。最后捣腾了很久，得到了这个方案：
 select &amp;quot;average_response_ms&amp;quot; * (2 - &amp;quot;result_code&amp;quot;) / 2 + &amp;quot;result_code&amp;quot; / 2 * 999 from (select &amp;quot;average_response_ms&amp;quot;, &amp;quot;result_code&amp;quot; from ping where $timeFilter fill(0))  最后的方法很粗糙：当 &amp;ldquo;result_code&amp;rdquo; 是 0 也就是成功的时候，得到延迟，而当 &amp;ldquo;result_code&amp;rdquo; 是 2 也就是超时的时候，直接得到 999 。这样就解决了这个问题。</description>
    </item>
    
    <item>
      <title>每周分享第 6 期</title>
      <link>https://jiege.ch/misc/2019/01/11/weekly-sharing-6/</link>
      <pubDate>Fri, 11 Jan 2019 17:41:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/01/11/weekly-sharing-6/</guid>
      <description>今天刚迁移了域名到 jiege.ch ，原来的 jiegec.me 会自动跳转过来，链接什么的都不用变。
 Rust 的 cfg! 宏只是返回 bool 而不会影响内部是否被编译 如果需要 if constexpr 的效果需要用 cfg-if 基于 HTML5 canvas 的图表库 Chart.js Endianness MATTERS! &amp;ndash; Harry Chen 各数据库的带补全的 CLI https://www.dbcli.com/ 边开发边测试 k8s 部署 tilt Github unlimited free private repos 于是称为了 PRO 用户 https://blog.github.com/2019-01-07-new-year-new-github/ Github 美食博主还行 https://github.com/hendricius/pizza-dough 一个用于本地化的库 https://github.com/dustin/go-humanize Vim Verilog 补全 https://github.com/vhda/verilog_systemverilog.vim homebridge 网页前端 https://github.com/oznu/homebridge-config-ui-x Zigbee 2 MQTT Bridge 需要额外的设备 https://github.com/Koenkk/zigbee2mqtt gdb 的网页 gui https://github.com/cs01/gdbgui Rust 一键 par iter https://github.com/rayon-rs/rayon 挺好看的 hex viewer https://github.</description>
    </item>
    
    <item>
      <title>域名已经迁移到 jiege.ch</title>
      <link>https://jiege.ch/meta/2019/01/11/blog-host-migration/</link>
      <pubDate>Fri, 11 Jan 2019 11:20:00 +0800</pubDate>
      
      <guid>https://jiege.ch/meta/2019/01/11/blog-host-migration/</guid>
      <description>从买新域名到迁移大概用了一个多小时，现在已经恢复访问。原有的地址也会直接 301 到新的域名上来。
仍然 Host 在 Github Pages 上。还会继续更新，不会跑路的（逃</description>
    </item>
    
    <item>
      <title>调整 Alacritty 的 Powerline 字体显示偏移</title>
      <link>https://jiege.ch/software/alacritty-powerline-font-offset/</link>
      <pubDate>Thu, 10 Jan 2019 20:19:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/alacritty-powerline-font-offset/</guid>
      <description>今天体验了一下 Alacritty ，以前一直在用 iTerm2 ，但是它的高级功能我都没用到。于是现在用了下 Alacritty ，把 Solarized Dark 配置了，发现 Inconsolata for Powerline 字体显示有点偏差，于是调整了一下：
# Font configuration (changes require restart) font: # Normal (roman) font face normal: family: Inconsolata for Powerline # The `style` can be specified to pick a specific face. #style: Regular # Bold font face bold: family: Inconsolata for Powerline # The `style` can be specified to pick a specific face. #style: Bold # Italic font face italic: family: Inconsolata for Powerline # The `style` can be specified to pick a specific face.</description>
    </item>
    
    <item>
      <title>Grafana Variable 的 regex 过滤方式</title>
      <link>https://jiege.ch/software/grafana-variable-regex-exclusion/</link>
      <pubDate>Thu, 10 Jan 2019 12:47:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/grafana-variable-regex-exclusion/</guid>
      <description>用 InfluxDB 收集到 Mountpoint 数据的时候，经常会掺杂一些不关心的，如 TimeMachine ，KSInstallAction 和 AppTranslocation 等等。所以，为了在 Variables 里过滤掉他们，需要用 Regex 进行处理。网上有人提供了方案，就是通过 Negative Lookahead 实现：
/^(?!.*TimeMachine)(?!.*KSInstallAction)(?!.*\/private)/  这样就可以把不想看到的这些 mountpoint 隐藏，节省页面空间了。当然了，这里其实也可以用白名单的方法进行处理，直接写 regex 就可以了。</description>
    </item>
    
    <item>
      <title>Rust 获取 Linker Script 中的地址</title>
      <link>https://jiege.ch/programming/2019/01/07/rust-access-linker-script-address/</link>
      <pubDate>Mon, 07 Jan 2019 11:57:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2019/01/07/rust-access-linker-script-address/</guid>
      <description>在 Linker Script 中可以记录下一个地址到一个变量中，大概这样：
.text: { PROVIDE(__text_start = .); *(.text .text.* .gnu.linkonce.t*) PROVIDE(__text_end = .); }  这里的 PROVIDE() 是可选的。这样，代码里就可以获取到 .text 段的地址了。在 C 中，直接 extern 一个同名的变量就可以了，但在 Rust 中，需要这样获取：
extern &amp;quot;C&amp;quot; { fn __text_start(); fn __text_end(); } // __text_start as usize // __text_end as usize  这样就可以拿到地址了。</description>
    </item>
    
    <item>
      <title>每周分享第 5 期</title>
      <link>https://jiege.ch/misc/2019/01/04/weekly-sharing-5/</link>
      <pubDate>Fri, 04 Jan 2019 21:12:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2019/01/04/weekly-sharing-5/</guid>
      <description>2019 年第一篇博文，祝大家新年快乐。最近忙于期末，没怎么搞事情，所以暂时没有关于别的内容的博文。
 发现一个很好看的 http web server index 就是不再更新了 h5ai 录制 DOM 变化并且重放 rrweb C++ 中的 Lazy Sequence 实现 lazyCode 来自 Berrysoft 的 Windows UWP 校园网认证解决方案 TsinghuaNetUWP 中科大老运维的笔记 ITTS Go 源码研究电子书 目测还在编写，不过读来挺有收获的 go-under-the-hood 第一次了解到 ELF Aux Vectors auxv 发现了 C99 的参数列表里 static 数组大小语法 static array indicies 发现一个有趣的包装了 socket 的消息库 支持一些消息分发方法 nanomsg 找到一个可视化 YUV 和视频解码的一些内部信息的工具 YUVView 通过动态 QRCode 传输数据 txqr qr-transfer 发现一些很好看的 CSS 动画 10-stunning-css-3d-effect-must-see 其中最神奇也最复杂的是 这个 Android runtime 中动态获取权限的库 Dexter 来自 Berrysoft 的 Stream operators in C++ CppLinq Squirrel (Rime for macOS) 在两年以后终于出了 0.</description>
    </item>
    
    <item>
      <title>每周分享第 4 期</title>
      <link>https://jiege.ch/misc/2018/12/29/weekly-sharing-4/</link>
      <pubDate>Sat, 29 Dec 2018 10:23:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2018/12/29/weekly-sharing-4/</guid>
      <description>咕了更长的时间。
 Header only JIT assembler https://github.com/herumi/xbyak 想找个时间玩玩 JIT Rust 实现的 Babel 转译 https://github.com/swc-project/swc 又一个瀑布流实现 https://github.com/e-oj/Magic-Grid 马上可以体验 HTTP/3 的库 https://github.com/djc/quinn Logitech Spotlight Presentation 挺好用的 配套软件的安装过程和使用都挺好的 Server side canvas https://github.com/Automattic/node-canvas 边看 youtube tutorial 边写代码 https://yourepl.tumblr.com/post/180936303347/announcing-yourepl 又一个 PostgreSQL 网页版客户端 https://github.com/sosedoff/pgweb 有趣的 CSS Layout 学习方法 http://cssgridgarden.com/#en http://flexboxfroggy.com/ pipenv 也有过 easter egg https://github.com/pypa/pipenv/issues/786 不过影比 antd 这个事情好多了 Web 太强了 啥都能做 https://whatwebcando.today/ 来自娄晨耀的清真 DNS 解决方案 https://github.com/Chenyao2333/freedns-go 快速的 tldr 实现 https://github.com/dbrgn/tealdeer MongoDB Data Source for Grafana 可以用 就是 aggregation 不大容易写对 https://github.</description>
    </item>
    
    <item>
      <title>《加速奔向2019》小程序编写和运营回顾</title>
      <link>https://jiege.ch/software/wxapp-recap/</link>
      <pubDate>Thu, 27 Dec 2018 19:56:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/wxapp-recap/</guid>
      <description>前言 关注清华的同学可能知道，昨天，“清华大学”公众号发了一篇名为《2018，我们共芳华丨@THUers 致相伴一年的你，请查收这份心意》的推送，内容大概就是，有那么100个新年台历礼品要送出去，大家如果想要的话，就扫描小程序。小程序模仿了火车抢票的病毒式营销的模式，要求大家分享到群聊或者朋友圈，让别人给自己加速，加速到 2019 的前 100 名即可填写信息领取奖品。
然后大家就在推送里看到了我。就酱。
开始 这件事情据说策划了有一段时间了，只是因为各种原因一直没有做，最后这个锅就路由到了我的头上。一开始说就是个加速小程序，逻辑很简单，但后来逐渐发现需求越来越多，主要是界面上的，动画上的，还有一些非技术因素的功能，嗯。这其实算是一个不大好的软件工程案例。
过程 线上的问题与解决方案 然后就是上线了。大概是昨天（2018-12-27）中午的时候推送发出去，很快流量就开始来了。很快，在朋友圈看到有同学在转发了，也有人反映说，网络有点卡，加载资源有点多。我去机器上用 iftop 看了下，流量大概是 250Mb/s ，没打到千兆。我一开始看了下，CPU 和内存占用都良好，以为是网络出口限制的问题，就想着没办法了，就这样吧，扛过去再说。不过，忽然有了转机。
TUNA 技术群里，忽然有人在讨论 SOMAXCONN 的问题，我想到，会不会是有些参数没开够大，导致了性能瓶颈，又受到啊荣的点拨，立马调整了这些变量：
net.core.somaxconn fs.file-max net.core.netdev_max_backlog net.ipv4.tcp_max_syn_backlog nginx: worker_rlimit_nofile nginx: event.worker_connections  很快带宽从 200Mb/s 左右打到了 400Mb/s 多，在 iftop 中看到的峰值接近 600Mb/s，见下图：
事后回来看，发现配置一套科学的监控系统真的很有用，如 TCP 连接的状态图：
这里最高的黄线代表的是 TIME_WAIT ，意味着很多的 TCP 连接都卡在了等待资源上，而一当我修改参数以后，立刻就降了下来，ESTBALISHED 的连接有了显著的提升。这个问题从另一个图也可以明地看出：
这个图是 TCP Handshake Issues ，可以看到无论是 activeopen 还是 passiveopen ，都很高，意味着这里无论是发还是收都遇到了问题。而修改参数以后，这些问题立马得到了很好的改善。
其实这些本应该在上线前做好的，但我低估了清华大学的影响力，没有做好相应的准备，还是在优秀的运维人员的指点下得到了较好的效果。
用户数据分析 当然了，除了 Grafana+InfluxDB+Telegraf 这一套监控系统，我们也部署了 ElasticSearch+Logstash+Kibana ，只不过我们还是用 Grafana 做了 ElasticSearch 的前端了。通过对 Nginx 日志的分析，我们得到了这些关键的数据（从12-26 12:00到12-27 12:00一天时间）：</description>
    </item>
    
    <item>
      <title>每周分享第 3 期</title>
      <link>https://jiege.ch/misc/2018/12/22/weekly-sharing-3/</link>
      <pubDate>Sat, 22 Dec 2018 00:19:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2018/12/22/weekly-sharing-3/</guid>
      <description>因为 DDL ，咕了一小会。
 被 Windows 保存为 Unicode 文件坑了 BOM 配上 UTF-16 太难受了 Github 最近添加了很多 Issue 方面的更新，如 Pin 和 Delete Grafana 真的很好看很好用 推荐大家自己配一套监控系统 Microsoft Remote Desktop Beta 新增了 AVC Codec 有意思 不知道啥时候上 HEVC 发现一个很好玩的用 Rust 写的网页游戏 https://sandspiel.club/# Python Pattern Matching https://github.com/santinic/pampy 大新闻：MIPS Open Source 了 https://www.eetimes.com/document.asp?doc_id=1334087 GRPC 调试的 GUI https://github.com/uw-labs/bloomrpc 对标 Postman 酷炫的屏幕保护 for Mac https://github.com/JohnCoates/Aerial WPF 开源了 不知道啥时候支持 *nix https://github.com/dotnet/wpf 分享欢乐 https://github.com/dotnet/wpf 分享欢乐x2 https://lore.kernel.org/patchwork/patch/628142/ 谷歌近日到处上线了 Material Design 2.0 感觉风格不大习惯 veonim/veonim 的 Tag 里有 #meme-driven-development 太好笑了 巨硬开源了自己的 UEFI 和 TianoCore EDK 竞争 https://blogs.</description>
    </item>
    
    <item>
      <title>每周分享第 2 期</title>
      <link>https://jiege.ch/misc/2018/12/14/weekly-sharing-2/</link>
      <pubDate>Fri, 14 Dec 2018 15:55:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2018/12/14/weekly-sharing-2/</guid>
      <description>继续，继续。
 用代码呈现硬件实现对性能的影响，值得一读 链接 发现了一个蛮少见的编码标准 AVS2 ，才发现是中国主导的 编码器 linux.org 的 DNS 被篡改了，认准 kernel.org 即可 一个处理器的电路的在线可视化 ARM1 visualized WASM 家庭现已加入 Nginx 链接 用 .bat 编写汇编语言 mnnip/BOOTSTRA Gitlab 挺香的，兹瓷 git-lfs ，还可以自己给自己的项目配一个 ci runner LaTeX 的 subfigure 之间如果有空行，就真的换了一行，所以同一行的 subfigure 不要换行 Rocket 4.0 出了，看起来不错，要是作者更新一下 CS140e 就好了 链接 装机必备，查询 Arch Wiki arch-wiki-man LaTeX 里 \newcommand 时，如果文件名有多个 &amp;lsquo;.&amp;rsquo; ，要特殊处理 链接 RunAsDate for *nix wolfcw/libfaketime 用数据库做数据分析似乎是个不错的选择 Canvas 配合 globalCompositionOperation 能做到不少东西 才知道有 Time Machine over SMB 这种操作 链接 mDNS repeater 把两个子网的 mDNS 打通 kennylevinsen/mdns-repeater Office 2019 for Mac 的 December 2018 release 添加了 Dark Mode ，并且也支持了 Continuity Camera ，直接从手机拍照导入 Gitlab serverless 发布，期待 链接 用 NAS 作为 Time Machine 备份盘的方法 链接 研究了一下，Time Machine over SMB 在 macOS 里的表现形式是 apfs 里写了一个 sparse bundle ，bundle 里面是 HFS+ 。  </description>
    </item>
    
    <item>
      <title>配置 homebridge-mi-aqara 并添加为 telegraf 的数据源</title>
      <link>https://jiege.ch/software/homebridge-mi-aqara-telegraf/</link>
      <pubDate>Thu, 13 Dec 2018 20:07:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/homebridge-mi-aqara-telegraf/</guid>
      <description>最近有了设备，想把设备拿到的数据都导一份存到 influxdb 里，但是目前找到的只有 homebridge-mi-aqara 可以访问并拿到数据，然后它又提供了 mqtt 的数据获取方案，于是自己写了个脚本去读取这些数据。
首先当然是配置一下 homebridge-mi-aqara ，按照网上的教程来，这个不难。然后本地开一个 MQTT Broker （如 mosquitto ），配置为本地监听，然后我编写了脚本 telegraf-mi-aqara.py ，使用前需要 pip install paho-mqtt，并且按照实际路径修改一下内容 。验证能够跑起来后，写一个 telegraf 配置：
[[inputs.exec]] commands = [&amp;quot;/usr/bin/python3 /path/to/telegraf-mi-aqara.py&amp;quot;] timeout = &amp;quot;5s&amp;quot; data_format = &amp;quot;influx&amp;quot;  现在就可以读取到各项信息，如温度，湿度，是否开门，开关用电情况等等。
2018-12-16 更新：
研究了一下绿米网关局域网通信协议，得到了第二个版本 telegraf-mi-aqara-v2.py，它与第一版的区别是，第一版是主动向网关读取信息，而这一版则是监听组播包，等待网关发消息。这个脚本负责把读取到的组播信息发送到 MQTT ，再让 telegraf 从 MQTT 里解析 JSON 消息，写入数据库。Telegraf 配置如下：
[[inputs.mqtt_consumer]] servers = [&amp;quot;tcp://127.0.0.1:1883&amp;quot;] qos = 0 connection_timeout = &amp;quot;30s&amp;quot; topics = [ &amp;quot;/telegraf-mi-aqara&amp;quot; ] persistent_session = true client_id = &amp;quot;Telegraf&amp;quot; data_format = &amp;quot;json&amp;quot; json_string_fields = [&amp;quot;model&amp;quot;, &amp;quot;sid&amp;quot;, &amp;quot;status&amp;quot;] tag_keys = [&amp;quot;model&amp;quot;, &amp;quot;sid&amp;quot;, &amp;quot;short_id&amp;quot;]  由于设备不全，有些字段可能不完整。如果大家自己要用的话，可能需要自行修改一下。</description>
    </item>
    
    <item>
      <title>Grafana 可视化实践：清华大学 2018 年度人物评选</title>
      <link>https://jiege.ch/software/grafana-visualize-vote18/</link>
      <pubDate>Fri, 07 Dec 2018 23:03:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/grafana-visualize-vote18/</guid>
      <description>最近这段时间，清华内部正在投票选出今年的年度人物，想到最近刚好在学习使用 Grafana+InfluxDB+Telegraf 全家桶，于是想着能不能写个爬虫把数据都拿下来，然后用 Grafana 画出来，就可以得到一个投票随时间变化的趋势。爬虫很简单，就是登录，获取页面信息，然后按照 InfluxDB 的输入格式进行输出即可。代码放在了 jiegec/student-tsinghua-vote18 下。
接着就是用 Grafana 进行可视化，大概得到了这样一个曲线：
为保护隐私，把名字隐去了。实际上的投票时间是从 12-3 号开始到 12-7号结束，但由于宿舍停电的原因所以采样的点在半夜的时候都没有，所以看起来有点奇怪，但还是能够反应总体的趋势的。比如可以看到前两名很早就一马当先，而后一直遥遥领先，下面的选手则排名变动很大，特别是截止前最后一段时间，大家都在拼命拉票，可见大家都是 DDL 选手啊。如果对上面这个图求个导，看看变化率的话：
这显现出了很有意思的一个趋势，就是每天十二点左右都有一个高峰期，然后在零点前大概熄灯附近的时间也是一个高峰期，另外就是截止前最后的抢票阶段，大家都在疯狂拉票，从中午拉到最后时刻。由于停电的原因，在零点附近的数据都比较的鬼畜，不过影响不大，趋势一目了然。
Grafana 真香！期望可以学到更多高端的查询语法和可视化的骚操作，现在有很多东西不知道该怎么可视化，比较苦恼，不知道大家有没有什么经验可以分享。</description>
    </item>
    
    <item>
      <title>每周分享第 1 期</title>
      <link>https://jiege.ch/misc/2018/12/07/weekly-sharing/</link>
      <pubDate>Fri, 07 Dec 2018 15:57:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2018/12/07/weekly-sharing/</guid>
      <description>向阮一峰学习，把自己在一周里看到的有趣的事情分享一下。不过形式就比较随意了。
 最近写 MongoDB + NodeJS 学到的新操作：$addToSet $nin $ne Mongoose 的 setDefaultsOnInsert Promise 真香，真好用 几天前惠老师还在说 &amp;ldquo;IE, The best Chrome Downloader Downloader, ever&amp;rdquo; 今天 EdgeHTML 就宣告死亡了 WPF, Windows Forms 和 WinUI 开源了，mono 这是要凉？ 链接 有人逆向了 FPGA 的 bitstream 格式，希望 FPGA 有朝一日可以进入 开源时代？ 链接 造机的 baseline 就决定是 它 了 根据 AST 炼丹判相似度还行，好奇它跨语言的预测水准 链接 可视化 h264 nalu 的软件 H264Naked （做的好糙啊，想交 pr） ffprobe -show_packets 和 ffprobe -show_frame 真好用 发现一个解决 ArchLinux 滚内核后无法 modprobe 的方案 010 Editor 和 Hex Fiend 是二进制分析的神器啊&amp;hellip; Kaitai 还有待加油 CSS-in-JS for ClojureScript 真香 有空可以试试用 ClojureScript 写前端 Safari Technology Preview 71 加入了 Web Authentication 这是要支持 U2F 的节奏？ Grafana+InfluxDB+Telegraf 真科学，随手写了一些简单的 Telegraf 的 input plugin 给 010 Editor 写了俩 .</description>
    </item>
    
    <item>
      <title>编写 010 Editor 的 FLV Template</title>
      <link>https://jiege.ch/software/010-editor-flv-parsing/</link>
      <pubDate>Thu, 06 Dec 2018 20:33:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/010-editor-flv-parsing/</guid>
      <description>最近在做 FLV 和 H264 方面的研究，研究了很多标准和文档，然后用 010 Editor 对着文件进行分析。这个软件真的很好用，对研究二进制结构用处特别大。不过它自带的 FLV.bt 功能不是很好，我对它加上了 H264(AVC) 的部分支持，放在了 myFLV.bt 里。我也写了 H264 的解析，不过效率不高，大文件要卡好一会。
除此之外，很多格式，010 editor 都有支持，特别好用，它的解析器语法也很好写。</description>
    </item>
    
    <item>
      <title>配置 Grafana&#43;InfluxDB&#43;Telegraf 并添加 MIIO 数据来源</title>
      <link>https://jiege.ch/software/grafana-influxdb-telegraf-miio/</link>
      <pubDate>Tue, 27 Nov 2018 20:33:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/grafana-influxdb-telegraf-miio/</guid>
      <description>之前一直想配一个监控系统，现在有机会了，就简单配了一下。发现真的特别简单，用 Homebrew 安装这三个软件并且都跑起来，然后稍微动一下配置，就可以得到可观的效果了。
然后想利用 miio 配置一下，把宿舍的空气净化器各项参数拿到，以 Telegraf 的插件形式定时上报，然后通过 Grafana 进行可视化。插件放在了 jiegec/tools 下，就是一个简单的 Python 脚本。配置方法如下：
编辑 /usr/local/etc/telegraf.d/miio.conf：
[[inputs.exec]] commands = [&amp;quot;/usr/local/bin/python3 /Volumes/Data/tools/telegraf/miio.py MIID_HERE&amp;quot;] timeout = &amp;quot;5s&amp;quot; data_format = &amp;quot;influx&amp;quot;  默认了 miio 路径为 /usr/local/bin/miio 。</description>
    </item>
    
    <item>
      <title>强制启用 Google Chrome 原生的 Dark Mode</title>
      <link>https://jiege.ch/software/enable-dark-mode-google-chrome/</link>
      <pubDate>Tue, 27 Nov 2018 00:17:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/enable-dark-mode-google-chrome/</guid>
      <description>Mojave 的 Dark Mode 真香，但是 Google Chrome 并不会随着系统的 Dark Mode 设置变化，所以 NightOwl 只能让部分软件按照时间变更 Dark/Light Mode 。一番搜索，发现其实 Google Chrome 其实已经支持了 Dark Mode，但只能设置，不能按照系统的状态自动切换，命令如下：
$ open -a Google\ Chrome --args --force-dark-mode  然后就可以看到 Google Chrome 已经是 Dark Mode 了。但可惜并不能自动切换。</description>
    </item>
    
    <item>
      <title>Mac 上安装 Arch Linux ， ZFS 真香</title>
      <link>https://jiege.ch/software/zfs-on-macos-and-linux/</link>
      <pubDate>Mon, 26 Nov 2018 20:51:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/zfs-on-macos-and-linux/</guid>
      <description>最近在 Mac 上装了 Arch Linux ，按照 Mac - Arch Linux Wiki 一路一路走，创建单独的一个 EFI 分区给 Arch Linux 放 GRUB 和内核，一个 ext4 作为根分区。由于 Arch ISO 不支持 Broadcom 的无线网卡，于是先拿 Apple Ethernet Adapter 连到路由器上装机。然后把一些需要的驱动装上了，桌面用的 KDE Plasma ，Trackpad 用的 xf86-input-mtrack-git ， HiDPI 设置为 2x Scale ，各种体验都还可以，就是 Wi-Fi 的 802.1X 没配置好，然后 kwalletd5 老是崩没找到原因。常见的应用除了微信基本都有，也终于可以体验 Steam Play ，利用 Proton 在 Linux 上跑一些只支持 Windows 的游戏，不过我已经很少玩游戏了。
然后我就想，怎么做 macOS 和 Linux 之间的文件共享。典型的操作可能是 exFAT ，但是作为数据盘的话，这还是不大适合。或者就直接用 ext4 ，配合 extFS For Mac by Paragon 使用，也可以，最后我选择了 ZFS 。</description>
    </item>
    
    <item>
      <title>USB/IP 实践</title>
      <link>https://jiege.ch/software/usb-ip/</link>
      <pubDate>Tue, 20 Nov 2018 18:50:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/usb-ip/</guid>
      <description>之前一直想玩 USB/IP ，但是一直没有找俩 Linux 设备然后共享，今天终于尝试了一下，没有什么大问题。这次采用的设备是 Raspberri Pi 3 和 SaltedFish Pi 。一开始尝试从后者向前者共享，但总是出现这个错误：
libusbip: error: udev_device_get_sysattr_value failed usbip: error: open vhci_driver  然后我反过来做就好了，比较神奇。
主要过程如下：
 pacman -S usbip 安装用户态软件 systemctl enable --now usbipd 启动 USB/IP 的端口监听 daemon usbip list -l 查看本地有哪些 USB 设备可以共享 usbip bind -b [BUS_ID] 把指定的 USB 设备共享出去，其中 BUS_ID 从上个命令中查看 usbip list -r [IP] 在另一个设备上查看这个设备共享的 USB 设备，可以看到许多信息 usbip attach -r [IP] -b [BUS_ID] 把对方共享的 USB 设备 attach 到本地  效果：把一个 U 盘成功映射到了本地：</description>
    </item>
    
    <item>
      <title>超过 100 篇博文了！</title>
      <link>https://jiege.ch/meta/2018/11/17/more-than-100-posts/</link>
      <pubDate>Sat, 17 Nov 2018 07:35:00 +0800</pubDate>
      
      <guid>https://jiege.ch/meta/2018/11/17/more-than-100-posts/</guid>
      <description>今天看了下，发现算上这一篇，这个博客已经有 103 篇文章了，这个数量还是蛮多的，特此庆祝一下。我也顺带做了一下简单的数据处理，得到这么一张图：
目测数量与干活的频率相关性很高啊。</description>
    </item>
    
    <item>
      <title>向咸鱼派写入 ArchlinuxARM</title>
      <link>https://jiege.ch/hardware/archlinuxarm-on-sfpi/</link>
      <pubDate>Tue, 06 Nov 2018 19:18:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/archlinuxarm-on-sfpi/</guid>
      <description>之前由于我的 macOS 上不知道为啥不能把我的 TF 卡设备放到我的虚拟机里，所以之前就没能刷 ArchLinuxARM 上去。今天我想到了一个方法，完成了这件时期：
$ wget https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/os/ArchLinuxARM-armv7-latest.tar.gz $ dd if=/dev/zero of=archlinuxarm.img bs=1M count=1024 $ mkfs.ext4 archlinuxarm.img $ sudo mkdir -p /mnt/archlinuxarm $ sudo mount -o loop archlinuxarm.img /mnt/archlinuxarm $ sudo bsdtar -xpf ArchLinuxARM-armv7-latest.tar.gz -C /mnt/archlinuxarm $ sudo umount /mnt/archlinuxarm  这样就获得了一个 ext4 的 ArchlinuxARM 镜像。刚好解压出来不到 1G ，所以开了 1G 的镜像刚好放得下。然后把 archlinuxarm.img 拷回 macOS ，然后用 dd 写进去：
$ sudo dd if=archlinuxarm.img of=/dev/rdisk4s2 bs=1048576  这时候可以确认，我们确实是得到了一个正确的 ext4fs ：
$ sudo /usr/local/opt/e2fsprogs/sbin/tune2fs -l /dev/disk4s2  不过，我们实际的分区大小可能不止 1G ，所以可以修改一下大小：</description>
    </item>
    
    <item>
      <title>咸鱼派的启动配置</title>
      <link>https://jiege.ch/hardware/salted-fish-pi/</link>
      <pubDate>Mon, 05 Nov 2018 22:17:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/salted-fish-pi/</guid>
      <description>最近刚拿到了一个咸鱼派的测试板子，准备自己把 U-Boot 和 Linux 内核这一套东西跑通，都用主线的东西，尽量减少魔改的部分。首先是编译 u-boot ，我用的是现在的 master 分支的最新版 99431c1c ：
$ # Archlinux $ sudo pacman -Sy arm-none-eabi-gcc $ make LicheePi_Zero_defconfig $ make ARCH=arm CROSS_COMPILE=arm-none-eabi- -j24  这时候会得到一个 u-boot-sunxi-with-spl.bin 的文件。我们只要把它写到 SD 卡的 8192 偏移处，就可以把 U-Boot 跑起来了：
$ diskutil unmountDisk /dev/disk4 $ sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/disk4 bs=1024 seek=8  接着我们做一下分区。我采用的是 MBR 分区，这样保证不会和 U-Boot 冲突。使用 fdisk进行分区，我从 1M 处开始分了一个 10M 的 FAT-32 分区作为启动分区，然后之后都是 EXT4 的系统盘分区。接着就是编译内核。
我用的是八月份时候的 4.18.2 内核，虽然不是很新但也足够新了。一番调整内核参数后，得到了一个可用的内核，然后把 zImage 和 sun8i-v3s-licheepi-zero.dtb 都复制到刚才创建的 FAT-32 启动分区，然后进入 U-Boot 进行启动：</description>
    </item>
    
    <item>
      <title>使用 HomeBridge 把小米空气净化器加入到 HomeKit 中</title>
      <link>https://jiege.ch/software/mi-air-purifier-homekit/</link>
      <pubDate>Sun, 04 Nov 2018 10:47:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/mi-air-purifier-homekit/</guid>
      <description>受 @NSBlink 安利，自己部署了一下 HomeBridge ，然后在 iOS 的家庭上就可以看到它。然后，通过 homebrdige-mi-airpurifier 和 miio 按照教程进行配置。然后就可以在家庭里看到小米空气净化器，包括空气质量，湿度，睡眠模式，温度，打开状态。然后我就可以做一些配置，如离开宿舍的时候自动关闭空气净化器，回来的时候自动打开。不过由于自己没有一个一直放在宿舍的 iPad、Apple TV 或者 HomePod ，失去了中枢，这个功能可能会打折扣。
后续想买一些智能的灯啊，然后就可以用 Siri 进行打开 / 关闭了。
此外，我又试了下，可以用 homebridge-camera-ffmpeg 把摄像头配置到 HomeKit 中。这样，就可以远程查看视频流了。</description>
    </item>
    
    <item>
      <title>部署 adminMongo 的 Docker 镜像</title>
      <link>https://jiege.ch/software/admin-mongo-docker/</link>
      <pubDate>Tue, 23 Oct 2018 20:08:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/admin-mongo-docker/</guid>
      <description>之前在软工的平台上部署了一个 MongoDB ，但是自然是仅内网访问，想要浏览内容只能通过网页上的 Console 进去看，体验特别不好。所以想着能不能找一个在线的 MongoDB 浏览器。由于软工平台只能部署 Docker 镜像，所以我找到了mongo-express和adicom/admin-mongo。但软工平台现在还没实现环境变量的配置，所以我选了后者。
首先本地创建一个 app.json ，让它监听 0.0.0.0:80 ，通过 deployer 传到平台上的配置，然后再把配置 mount 到 /app/config 路径上。现在就可以成功地在网页上浏览 MongoDB 了。</description>
    </item>
    
    <item>
      <title>OpenWRT 上配置 Gandi DDNS</title>
      <link>https://jiege.ch/networking/2018/10/22/ddns-openwrt-router/</link>
      <pubDate>Mon, 22 Oct 2018 09:53:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/10/22/ddns-openwrt-router/</guid>
      <description>一直想给自己的 OpenWRT 路由器添加 DDNS 功能，但 Gandi 不在官方的 ddns-scripts 列表中，自己在网上找了一些脚本，发现是 Python 写的，尝试把 Python 安装到路由器上又发现空间不够，虽然可以安装到 USB 上，但总归是麻烦。
最后找到了官方的一个脚本，非常适合我的需求。简单修改一下，然后安装一下支持 HTTPS 的 cURL ：
$ opkg update $ opkg install ca-bundle $ opkg install curl  然后把脚本添加到 crontab 即可。</description>
    </item>
    
    <item>
      <title>ETC 比赛无线网络搭建小记</title>
      <link>https://jiege.ch/networking/2018/10/20/etc-wireless-network/</link>
      <pubDate>Sat, 20 Oct 2018 23:44:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/10/20/etc-wireless-network/</guid>
      <description>正好上着李贺武老师的《无线移动网络技术》课，然后今天又给 ETC 比赛搭建无线网络，于是周二的时候找老师咨询了一下意见。我们大概给老师讲了一下场地的样子和尺寸（当时估计的大了），然后老师给我们提供了一个可以供参考的部署方案，包括几个 AP 分别放在哪，这些 AP 的 2.4GHz 都用哪个 channel ，然后都用多少功率。并且很友善地在周五的时候让助教来场地帮我们 survey 一下无线网络的状况。我们用 Fluke Networks 的 AirCheck Wi-Fi Tester 看了一下场地的各个频道的 AP 数量和信号强度，发现虽然 AP 挺多的，但是它们的信号都比我们的小不少，而且我们也都开到了 50mW ，所以干扰不大。
然后昨天下午一点半钟来到场地，用板车把设备都运到计算机开放实验室，然后开始部署无线网络。我们提前来踩过几次点，这边的网络是没有 DHCP 服务器的，通过一个指定的网关出去。我们发现可以利用已有的这些交换机从地下连到各个电脑上的网线，来连接我们的 AP 和交换机，这样我们就免去了走线的麻烦。于是我们先定下放 AP 的位置，然后用寻线器找到网线插到了交换机的哪一个端口上，标记好后换成连接到我们自己的交换机的网线上，从而可以通过 PoE 把我们的 AP 给启动起来。然后用我自己的路由器，把 LAN 口插到交换机上，给 AP 分发 DHCP 地址，然后把下发的默认网关配置为真实的网关（DHCP Option 3） ，没做但是也可以顺带做的是把 WLC 的地址分发下去 （DHCP Option 43 Type 241）。
当然，这个过程也遇到了一点小坑，就是交换机还保留了之前的配置，所以这次把新的几个端口划到了一个 VLAN 下，命令自然是记不住的要现查。然后起来以后还挺稳定的，也没出现什么问题，网络带宽也足够用，离千兆还有蛮多距离，一天也才跑了接近俩 TB 的流量。</description>
    </item>
    
    <item>
      <title>Unicode En Dash 小坑</title>
      <link>https://jiege.ch/misc/2018/10/13/unicode-en-dash-mistake/</link>
      <pubDate>Sat, 13 Oct 2018 22:51:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2018/10/13/unicode-en-dash-mistake/</guid>
      <description>今天有同学问到我这个问题：
$ gcc -o ph ph.c –lpthread  为啥不工作。我怎么看都觉得没啥问题，一开始以为是找不到 pthread ，但马上又排除了。想了下会不会是有隐藏的字符，于是让同学 pbpaste | xxd 一下，果然发现这里的 – 是 \xe2\x80\x93 ，查了下是 Unicode 里的 En Dash 。由于这是从 PDF 里直接拷贝出来的，所以凉了。改成正常的短横杠即可。</description>
    </item>
    
    <item>
      <title>软工平台踩坑记</title>
      <link>https://jiege.ch/software/secoder-platform-sucks/</link>
      <pubDate>Fri, 12 Oct 2018 00:09:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/secoder-platform-sucks/</guid>
      <description>老师要求我们搞 CI/CD ，CI 自然是很快就搞好了，不过 CD 还得配一下。今天研究了一下它的 Deployer 架构，发现了若干易用性问题：
 缺乏文档 只有样例配置没有讲解 已有的文档 语焉不详 官方对此回复：功能太多，还没忙过来写文档  于是只好经常戳助教然后尝试理解这个东西。。然后遇到了很多的 BUG ：
 容器没有重启功能。。。 容器死了还是活着看一个图的颜色。。。毫无说明 容器虽然有 Console ，但是输入过长后直接回到行首没有换行。。。 容器对外的域名里有下划线。。。 Django 上来就一句 Invalid HTTP_HOST header: &#39;xxxx_xxx.app.secoder.net&#39;. The domain name provided is not valid according to RFC 1034/1035. Express 直接就 Invalid Host header 放弃治疗。。。 助教对上一条的回复是，等我忙完 DDL 有空再做吧。。。也就是说现在要做只能自己再开一个 Nginx 容器然后自己在 proxy_set_header 上做手脚。。。  </description>
    </item>
    
    <item>
      <title>在荔枝糖（Lichee Tang）上初次体验 FPGA</title>
      <link>https://jiege.ch/hardware/my-first-fpga-experience-on-lichee-tang/</link>
      <pubDate>Sun, 07 Oct 2018 22:34:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/my-first-fpga-experience-on-lichee-tang/</guid>
      <description>今天从张宇翔学长那拿到了 荔枝糖（Lichee Tang） 的 FPGA 板子，于是立即开始把前段时间学到的Verilog应用上来。不过想到现在我手上没有多少外设，然后又必须远程到 Windows 电脑上去操作，于是先实现了一下 UART 通信。
在网上找到了 ben-marshall/uart 一个简易的实现，很快做到了一直在串口上打印 A 字符。接着我开始尝试实现一个简单的串口回显。一开始，我直接把 UART 读到的数据直接输出，果然可以了，但是一旦传输速率跟不上了，就会丢失数据。于是我添加了 FIFO IP 核，然后把读入的数据存入 FIFO ，又从 FIFO 中读取数据写入到 UART 中去。不过发现了一个小 BUG：每次打印的是倒数第二次输入的字符，即丢失了第一个字符。在张宇翔学长的帮助下找到了问题：当 FIFO 的读使能信号为高时，其数据在下一个时钟周期才来，于是解决方案就是等到数据来的时候再向 UART 中写数据：
always @ (posedge clk_in) begin uart_tx_en &amp;lt;= uart_fifo_re; end  这样就解决了这个问题。完整代码在 jiegec/learn_licheetang 中。</description>
    </item>
    
    <item>
      <title>使用 veth 实现 IPv6-only 的 Brouter 功能</title>
      <link>https://jiege.ch/networking/2018/10/07/use-veth-for-ipv6-brouter/</link>
      <pubDate>Sun, 07 Oct 2018 11:05:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/10/07/use-veth-for-ipv6-brouter/</guid>
      <description>最近从 @shankerwangmiao 学到了一个方法：通过 veth 把两个 bridge 的 IPv6 桥接起来。方法如下：
$ ip link add veth-v6-in type veth peer name veth-v6-out $ brctl addif br-in veth-v6-in $ brctl addif br-out veth-v6-out $ ebtables -t filter -A FORWARD -p ! IPv6 -o veth-v6-in -j DROP $ ebtables -t filter -A FORWARD -p ! IPv6 -o veth-v6-out -j DROP  这样就可以看到 veth 上仅有 IPv6 的流量了。</description>
    </item>
    
    <item>
      <title>在 Android 上打开 LTE 的 IPv6</title>
      <link>https://jiege.ch/networking/2018/10/04/enable-lte-ipv6-on-android/</link>
      <pubDate>Thu, 04 Oct 2018 22:47:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/10/04/enable-lte-ipv6-on-android/</guid>
      <description>听闻北京移动给 LTE 配置了 SLAAC ，但现在需要手动打开，方法如下：
Settings -&amp;gt; Network &amp;amp; Internet -&amp;gt; Mobile Network -&amp;gt; Advanced -&amp;gt; Access Point Names -&amp;gt; 中国移动 GPRS (China Mobile) -&amp;gt; 把 APN procotol 和 APN roaming protocol 两项都改成 IPv4/IPv6
然后在 test-ipv6.com 上可以看到确实分配了 IPv6 地址，不过目前评分只有 1&amp;frasl;10 。也就是说可用性还不佳。
而在 iOS 上，通过 HE 的 Network Tools 能看到，确实拿到了 IPv6 的地址，但是出不去，怀疑是运营商没有下发相关配置，所以还不能使用，只能继续等。
2018-11-06 更新：现在 iOS 用户也有 LTE 的 v6 了。评分是 9&amp;frasl;10 。目前可用性已经可以了，就是国内互联还不大好。</description>
    </item>
    
    <item>
      <title>THUCTF 2018 和 Teaser Dragon CTF 2018 小记</title>
      <link>https://jiege.ch/ctf/2018/10/04/2018-10-04-thuctf-2018-and-teaser-dragon-ctf-2018/</link>
      <pubDate>Thu, 04 Oct 2018 14:52:00 +0800</pubDate>
      
      <guid>https://jiege.ch/ctf/2018/10/04/2018-10-04-thuctf-2018-and-teaser-dragon-ctf-2018/</guid>
      <description>终于可以公开 writeup 了，大家也可以去看 twd2 写的 writeup 。 这次是我第一次打 CTF ，发现题目还挺有意思的，虽然也有一些题目做不出来，有拿钱还是美滋滋。
这次也认识了好些会打 CTF 的人吧，如 0x00, user1, igoodvegetable 等队伍的同学。一开始被蛤力橙叫来打比赛，我觉得心里挺没底的，然后花了很多时间做题目，一点一点还是做出了不少题目来。最精彩的还是结束以后，当知晓没做出来的题目的做法时候，会不自觉感叹题目的巧妙。也学到了一些梗：
#define 1000000007 twd2  接着就参与了一下 Teaser Dragon CTF 2018 ，是个在线赛，许多人一起做题，只有 24 小时。看了下题目，除了签到题，其它题都比 THUCTF 2018 难多了，我只能围观他们做题。最后看到别人写的 writeup ，真是太巧妙了，一环接一环，真的想不到。不过也有很麻烦的题目，特别是有的逆向的题目，太考验人的耐心了。
接下来就等待官方的 writeup 和别人的 writeup ，学习一下别人的做法吧。</description>
    </item>
    
    <item>
      <title>绕过 GPGMail 的激活检测</title>
      <link>https://jiege.ch/software/bypass-gpgmail-activation/</link>
      <pubDate>Thu, 04 Oct 2018 11:47:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/bypass-gpgmail-activation/</guid>
      <description>前段时间 GPGMail 宣布不再免费，在三十天的试用期后就不给用了。唉，可能是官方实在没钱维护了，也可能是官方想赚钱了。不过，既然 GPGMail 采用的是自由的许可证，意味着我们可以自己对代码进行更改。和许可证验证相关的代码如下：
- (BOOL)hasActiveContract { NSDictionary *contractInformation = [self contractInformation]; return [contractInformation[@&amp;quot;Active&amp;quot;] boolValue]; }  我们只要改成 return TRUE ，在自己的电脑上手动编译、并复制到 /Library/Application Support/GPGTools/GPGMail 下即可。
另：还有一个直接对二进制打 patch 的方法（仍然符合许可证），利用了最近打 CTF 学到的一些知识。找到以上这个函数，然后把返回值修改成非零即可。这里就不提供方法了。最后的更改：
$ radiff2 -D --- 0x0000282f 410fbec7 - movsx eax, r15b +++ 0x0000282f 4c89e090 + mov rax, r12 + nop  当然了，还需要额外 codesign --remove-signature 一下。
谨慎对非自由软件采用这个方法。可能有法律风险。</description>
    </item>
    
    <item>
      <title>在 macOS 的 VirtualBox 上从 USB 启动</title>
      <link>https://jiege.ch/os/2018/09/14/virtualbox-booting-from-usb-on-mac/</link>
      <pubDate>Fri, 14 Sep 2018 23:57:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2018/09/14/virtualbox-booting-from-usb-on-mac/</guid>
      <description>做了一个 Windows 10 安装 U 盘，想测试一下能不能启动，于是想用 VirtualBox 起一个虚拟机。但是发现，一般情况下要从 ISO 或者把 U 盘克隆成一个 vdi/vmdk etc 再启动。不过找到了 Cem Arslan 的 VirtualBox - Booting From USB (MAC) 实验了一下，确实可以用，以 /dev/disk2 为例方法如下：
$ diskutil unmountDisk /dev/disk2 $ sudo chown $(whoami) /dev/disk2 $ VBoxManage internalcommands createrawvmdk -filename PATH_TO_VMDK -rawdisk /dev/disk2 $ # Now boot from VirtualBox  对于其它平台，可以参考 Tu Nguyen 的 How to boot from USB in VirtualBox 。
研究了一下生成的 vmdk 文件，大概是这样的：
# Disk DescriptorFile version=1 CID=12345678 parentCID=ffffffff createType=&amp;quot;fullDevice&amp;quot; # Extent description RW 12345678 FLAT &amp;quot;/dev/disk2&amp;quot; 0 # The disk Data Base #DDB ddb.</description>
    </item>
    
    <item>
      <title>在 Ubuntu 上跨版本迁移 MongoDB</title>
      <link>https://jiege.ch/software/migrate-mongodb-on-ubuntu/</link>
      <pubDate>Thu, 13 Sep 2018 14:27:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/migrate-mongodb-on-ubuntu/</guid>
      <description>由于 MongoDB 只支持当前版本和上一个版本的数据库格式，然后刚刚滚系统升级的时候升级到了 3.6.x ，而数据库格式仍然是 3.2.x 的，于是需要先安装回 3.4.x 版本的 MongoDB，输入命令把数据库升级到 3.4.x 版本后，再用 3.6.x 的数据库进行升级。
以 从 Ubuntu 14.04 LTS 升级到 Ubuntu 18.04.1 LTS 为例，方法如下：
$ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.17.tgz $ tar xvf mongodb-linux-x86_64-ubuntu1604-3.4.17.tgz $ cd mongodb-linux-x86_64-ubuntu1604-3.4.17/bin/ $ sudo ./mongod --config /etc/mongodb.conf &amp;amp; $ mongo &amp;gt; db.adminCommand( { setFeatureCompatibilityVersion: &#39;3.4&#39; } ) { &amp;quot;ok&amp;quot; : 1 } $ fg ^C $ sudo chown -R mongodb:mongodb /var/lib/mongodb $ sudo systemctl start mongodb $ mongo &amp;gt; db.</description>
    </item>
    
    <item>
      <title>通过 SSH 隧道连接 ADB 和 Android 设备</title>
      <link>https://jiege.ch/programming/2018/09/13/adb-over-ssh-tunnel/</link>
      <pubDate>Thu, 13 Sep 2018 13:20:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/09/13/adb-over-ssh-tunnel/</guid>
      <description>由于本机算力不足，想要在远程编译 LineageOS ，其中有一步需要连接到已有的设备，于是突发奇想：
 adb 可以通过 网络连接 ssh 可以进行端口转发，这里是把 remote 的端口转发到 Android 设备上的端口。  方法如下：
$ adb shell ip -f inet addr show wlan0 $ # remember the ip address here $ adb tcpip PORT1 $ ssh -R PORT2:ANDROID_IP:PORT1 REMOTE (remote)$ adb connect localhost:PORT2 # trust this device on Android  参考文档：
 How can I connect to Android with ADB over TCP? SSH PORT FORWARDING EXAMPLE  </description>
    </item>
    
    <item>
      <title>在 LEDE （OpenWrt） 上启用 wpad</title>
      <link>https://jiege.ch/networking/2018/09/11/enable-wpad-on-lede/</link>
      <pubDate>Tue, 11 Sep 2018 23:23:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/09/11/enable-wpad-on-lede/</guid>
      <description>WPAD（Web Proxy Auto-Discovery Protocol）是一个可以利用 dhcp 分发 pac 配置的协议。方法如下：
$ # ssh to router first $ vim /etc/dnsmasq.conf dhcp-option=252,&amp;quot;http://router_ip/wpad.dat&amp;quot; $ vim /www/wpad.dat # put pac here $ service dnsmasq restart $ # ensure proxy is available to lan $ # enable wpad on devices  参考文档：
 Web Proxy Auto-Discovery Protocol Automatic Proxy Configuration with WPAD Deploying WPAD Example PAC File  </description>
    </item>
    
    <item>
      <title>在 Xcode 9 上启用 Vim 模拟（XVim 2）</title>
      <link>https://jiege.ch/software/enable-vim-mode-in-xcode-9/</link>
      <pubDate>Sat, 08 Sep 2018 02:01:00 +0800</pubDate>
      
      <guid>https://jiege.ch/software/enable-vim-mode-in-xcode-9/</guid>
      <description>作为一个不用 vim 编辑会死星人，用 Xcode 总是止不住自己想 Escape 的心。于是找到了 XVimProject/XVim2 进行配置。
大致方法如下：
 按照 Signing Xcode 对 Xcode 进行重签名。套路和对 GDB 进行签名一样。不过这次，签名完成的时间可长多了，毕竟 Xcode 这么大。 接着按照项目的 README ，首先 git clone 然后 make ，第一次打开 Xcode 的时候选择 Load Bundle 即可。  终于可以满足我 Escape Xcode 的欲望了。</description>
    </item>
    
    <item>
      <title>在 macOS 上读取移动硬盘的 S.M.A.R.T. 信息</title>
      <link>https://jiege.ch/hardware/reading-smart-info-of-external-drives-under-macos/</link>
      <pubDate>Fri, 07 Sep 2018 10:20:00 +0800</pubDate>
      
      <guid>https://jiege.ch/hardware/reading-smart-info-of-external-drives-under-macos/</guid>
      <description>之前想看看自己各个盘的情况，但是发现只能看电脑内置的 SSD 的 S.M.A.R.T 信息，而移动硬盘的都显示：
$ smartctl -a /dev/disk2 smartctl 6.6 2017-11-05 r4594 [Darwin 17.7.0 x86_64] (local build) Copyright (C) 2002-17, Bruce Allen, Christian Franke, www.smartmontools.org /dev/disk2: Unable to detect device type Please specify device type with the -d option. Use smartctl -h to get a usage summary  一开始我怀疑是个别盘不支持，但换了几个盘都不能工作，问题应该出现在了 USB 上。查了下资料，果然如此。根据 USB devices and smartmontools ，获取 S.M.A.R.T 信息需要直接发送 ATA 命令，但是由于经过了 USB ，于是需要进行一个转换，导致无法直接发送 ATA 命令。这个问题自然是有解决方案，大概就是直接把 ATA 命令发送过去（pass-through）。上面这个地址里写到，如果需要在 macOS 上使用，需要安装一个内核驱动。可以找到，源码在 kasbert/OS-X-SAT-SMART-Driver 并且有一个带签名的安装包在 External USB / FireWire drive diagnostics support 中可以下载。丢到 VirusTotal 上没查出问题，用 v0.</description>
    </item>
    
    <item>
      <title>通过 Ipfilter Extension 实现 RFC8367</title>
      <link>https://jiege.ch/networking/2018/08/31/implementing-rfc8367-as-iptables-extension/</link>
      <pubDate>Fri, 31 Aug 2018 15:47:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/08/31/implementing-rfc8367-as-iptables-extension/</guid>
      <description>前几天无聊闲逛看到了一个很有趣的 RFC8367 - Wrongful Termination of Internet Protocol (IP) Packets ，看到日期大家应该都懂了，这是个粥客，不过里面还是反映了一些事情，咳。
之前看到闪客实现了 shankerwangmiao/xt_PROTO ，想到自己也可以做一个 iptables 扩展，于是就写了 jiegec/xt_EQUALIZE 。它是这样使用的：
$ git clone git@github.com:jiegec/xt_EQUALIZE.git $ make $ sudo make install $ sudo iptables -t filter -A INPUT -j EQUALIZE $ sudo dmesg -w &amp;amp; $ # Make some random network requests to see the effect! $ ping 1.1.1.1 $ ping 8.8.8.8 $ ping ::1  目前还没有把参数都变成可以配置的。如果真的有人需要这个模块的话，我再改吧（逃</description>
    </item>
    
    <item>
      <title>在 macOS 上 TAP Interface 上启用 IPv6 自动配置</title>
      <link>https://jiege.ch/networking/2018/08/25/enable-ipv6-autoconfiguration-on-tap-interfaces-in-macos/</link>
      <pubDate>Sat, 25 Aug 2018 19:07:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/08/25/enable-ipv6-autoconfiguration-on-tap-interfaces-in-macos/</guid>
      <description>由于 macOS 对 TAP Interface 不会自动出现一个设置中对应的服务，所以需要手动进行配置。一番测试后，发现可以通过：
$ sudo ipconfig set [tap_if] automatic-v6 $ sudo ipconfig set [tap_if] dhcp  启用系统自带的 dhcp 和 ra 功能。也许有方法可以把这些 tap 搬到系统的设置中去。
UPDATE:
可以把 TAP Interface 加到系统的设置中去。方法参考Virtual network interface in Mac OS X。完成以后可以直接通过系统设置界面进行配置。</description>
    </item>
    
    <item>
      <title>在 macOS 下实现 GRETAP</title>
      <link>https://jiege.ch/networking/2018/08/21/implementing-gretap-in-macos/</link>
      <pubDate>Tue, 21 Aug 2018 09:42:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/08/21/implementing-gretap-in-macos/</guid>
      <description>由于没有找到 macOS 下现成的 GRETAP 实现，我就想到自己实现一个。由于tuntaposx提供了一个和 Linux 下基本一样的 TAP Interface，于是自己利用 raw socket 和 TAP Interface 实现了一下，主要方法：
 打开 raw socket ，读取收到的 proto 47 的包，判断是否为 GRETAP 包，是，则写入内层包到打开的 TAP Interface 中。 从 TAP Interface 中读入包，自己加上 GRE 头和 IP 头，然后发送。  主要的难度是在 raw socket 部分，macOS 继承了 BSD ，与 Linux 不大一样。于是参考了SOCK_RAW Demystified，成功地实现了这个功能。
代码放在jiegec/gretapmac。写得并不高效，仅仅可用，用了一百多行。
UPDATE: 之后又随手实现了一个类似的协议，L2TPv3 over UDP。代码在jiegc/l2tpv3udptap。</description>
    </item>
    
    <item>
      <title>在 WireGuard 构建的 Overlay Network 上跑 babel 路由协议</title>
      <link>https://jiege.ch/networking/2018/08/10/use-babel-in-overlay-network-with-wireguard/</link>
      <pubDate>Fri, 10 Aug 2018 09:17:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/08/10/use-babel-in-overlay-network-with-wireguard/</guid>
      <description>受 Run Babeld over Wireguard - Fugoes&amp;rsquo;s Blog 和 Route-based VPN on Linux with WireGuard 启发，自己也想尝试一下，在一个有多个结点的网络中，如何通过 WireGuard 构建一个 overlay network，并通过 babel 自动进行结点发现和路径选择。
首先建立点对点的 WireGuard Tunnel 。由于我们用 babel 进行路由，所以我们不能采用 Wiregurad 本身基于目的地址的端口复用，所以每一个 WireGuard interface 都只有一个 Peer 。
配置一个点对点的 WireGuard Tunnel：
$ # for wg-quick $ cat wg0.conf [Interface] Address = IPV4/32, fe80::ID/64 PrivateKey = REDACTED ListenPort = PORT1 Table = off # ask wg-quick not to insert peer address into routing table [Peer] PublicKey = REDACTED AllowedIPs = 0.</description>
    </item>
    
    <item>
      <title>更改 macOS 屏幕亮度的按键</title>
      <link>https://jiege.ch/os/2018/08/05/changing-screen-brightness-key/</link>
      <pubDate>Sun, 05 Aug 2018 09:59:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2018/08/05/changing-screen-brightness-key/</guid>
      <description>由于我打开了「Invert Fn」功能，所以需要调亮度的时候，是采用Fn+F1/F2的方法。但是，我的机械键盘则是，不按Fn时为1-9,按着Fn时为对应的F1-F9，但是就无法调整亮度和声音了。
然后捣腾了一下，发现可以用ScLk和Pa/Br（名称在各个键盘上不大一样）调整亮度。不过，还没发现如何更改音量。。。</description>
    </item>
    
    <item>
      <title>向 Lenovo y1s 刷入 OpenWRT 17.01.5 固件，并把 IPv6 bridge 到内网中和配置认证脚本</title>
      <link>https://jiege.ch/networking/2018/07/26/flashing-lenovo-y1s-and-bridge-ipv6/</link>
      <pubDate>Thu, 26 Jul 2018 20:48:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/07/26/flashing-lenovo-y1s-and-bridge-ipv6/</guid>
      <description>首先参照OpenWRT Wiki - Lenovo Y1 v1找到刷固件教程：
 下载Lenovo y1s 的固件备用 断开电源，等待一段时间，插入电源同时快速按下重置按钮，如果面板双闪，则说明进入了恢复模式 电脑连接到四个 LAN 口中任意一个，配置静态地址在 192.168.1.0/24 网段 打开 192.168.1.1 可以看到刷固件的页面 上传固件，等待路由器重启 配置 IP 地址为 DHCP 模式，打开 192.168.1.1 进行配置  然后就是常规的密码设置，opkg 源设置为 tuna 的源，配置 ssh 和 公钥。
接下来，我们为了使用学校的 SLAAC ，采用 ebtables 直接把学校的 IPv6 bridge 进来，而 IPv4 由于准入系统，需要 NAT 。
参考Bridge IPv6 connections to WAN，下载v6brouter_openwrt.sh到某个地方，然后修改一下里面的一些参数：
# For Lenovo y1s WAN_DEV=eth0.2 BRIDGE=br-lan # the rest remain unchanged  然后跑起来之后，自己的电脑可以成功拿到原生的 IPv6 地址了，不需要用难用的 NAT66 技术。
下一步是采用z4yx/GoAuthing。</description>
    </item>
    
    <item>
      <title>构建简易的 initramfs</title>
      <link>https://jiege.ch/os/2018/07/16/build-custom-initramfs/</link>
      <pubDate>Mon, 16 Jul 2018 03:43:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2018/07/16/build-custom-initramfs/</guid>
      <description>一直对 Linux 的启动很感兴趣，但对 initrd 和 initramfs 等概念不大了解，于是上网找了资料，自己成功地看到了现象。
参考资料： Build and boot a minimal Linux system with qemu Custom Initramfs initramfs vs initrd ramfs, rootfs and initramfs The Kernel Newbie Corner: &amp;ldquo;initrd&amp;rdquo; and &amp;ldquo;initramfs&amp;rdquo;&amp;ndash; What&amp;rsquo;s Up With That?
具体步骤：
$ cat hello.c #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; int main() { for (;;) { printf(&amp;quot;Hello, world!\n&amp;quot;); } } $ gcc -static hello.c -o init $ echo init | cpio -o -H newc | gzip &amp;gt; initrd $ qemu-system-x86_64 -kernel /boot/vmlinuz-linux -initrd initrd -nographic -append &#39;console=ttyS0&#39; # Use C-a c q u i t &amp;lt;Enter&amp;gt; to exit  可以看到过一会（三四秒？），可以看到满屏的 Hello world 在输出。</description>
    </item>
    
    <item>
      <title>用 multicast 地址找到同一网段的主机</title>
      <link>https://jiege.ch/networking/2018/07/15/use-multicast-address-to-find-neighbours/</link>
      <pubDate>Sun, 15 Jul 2018 17:19:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/07/15/use-multicast-address-to-find-neighbours/</guid>
      <description>IPv4 :
$ ping -t1 224.0.0.1  IPv6:
$ ping -t1 ff02::1%iface  </description>
    </item>
    
    <item>
      <title>用 MuSSH 快速对多台机器进行软件包升级</title>
      <link>https://jiege.ch/devops/use-mussh-to-upgrade-multiple-machines/</link>
      <pubDate>Sun, 15 Jul 2018 01:10:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/use-mussh-to-upgrade-multiple-machines/</guid>
      <description>Debian Stretch 9.5 刚刚更新，自己手上有不少 stretch 的机器，于是顺手把他们都升级了。不过，这个过程比较繁琐，于是我采用了 MuSSH 的方法，让这个效率可以提高，即自动同时 SSH 到多台机器上进行更新。
首先编写 hostlist 文件，一行一个地址，分别对应每台机器。
然后采用 MuSSH 对每台机器执行同样的命令
$ mussh -H hostlist -c &#39;apt update &amp;amp;&amp;amp; apt upgrade -y&#39;  此时要求，ssh 上去以后有相应的权限。这个有许多方法，不再赘述。然后就可以看到一台台机器升级，打上安全补丁，爽啊。</description>
    </item>
    
    <item>
      <title>配置 fcitx-fbterm 实现在终端下显示和输入中文</title>
      <link>https://jiege.ch/misc/2018/07/12/using-fcitx-fbterm/</link>
      <pubDate>Thu, 12 Jul 2018 23:06:00 +0800</pubDate>
      
      <guid>https://jiege.ch/misc/2018/07/12/using-fcitx-fbterm/</guid>
      <description>参考网站：
Ubuntu使用fbterm无法打开fb设备的解决及fcitx-fbterm安装 Fcitx - ArchWiki 完美中文tty, fbterm+yong(小小输入法) 让linux console支持中文显示和fcitx输入法
考虑到 lemote yeeloong 机器的 cpu 运算性能，跑一个图形界面会非常卡，于是选择直接用 framebuffer 。但是，显示中文又成了问题。于是，采用了 fbterm 和 fcitx 配合，加上 gdm 的方法，完成了终端下的中文输入。
首先，安装相关的包：
$ sudo apt install gpm fcitx-fronend-fbterm dbus-x11 fbterm fonts-wqy-zenhei  接着，基于以上参考网站第一个，编写 zhterm 文件：
$ echo zhterm #!/bin/bash eval `dbus-launch --auto-syntax` fcitx &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 fbterm -i fcitx-fbterm kill $DBUS_SESSION_BUS_PID fcitx-remote -e $ chmod +x zhterm $ zhterm # Use C-SPC to switch input source  另：找到一个映射 Caps Lock 到 Escape 的方案：</description>
    </item>
    
    <item>
      <title>在 Lemote Yeeloong 上安装 Debian jessie</title>
      <link>https://jiege.ch/devops/installing-debian-in-lemote-yeeloong/</link>
      <pubDate>Wed, 11 Jul 2018 23:12:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/installing-debian-in-lemote-yeeloong/</guid>
      <description>参考网站：
gNewSense To MIPS Run a TFTP server on macOS Debian on Yeeloong Debian MIPS port wiki Debian MIPS port
首先，进入设备的 PMON：
Press Del to enter PMON  然后，下载 Debian Jessie 的 netboot 文件：
$ wget https://mirrors.tuna.tsinghua.edu.cn/debian/dists/jessie/main/installer-mipsel/current/images/loongson-2f/netboot/vmlinux-3.16.0-6-loongson-2f $ wget https://mirrors.tuna.tsinghua.edu.cn/debian/dists/jessie/main/installer-mipsel/current/images/loongson-2f/netboot/initrd.gz  以 macOS 为例，起一个 tftp 服务器以供远程下载：
# ln -s these files to /private/tftpboot: # initrd.gz # vmlinux-4.16.0-6-loongson-2f $ sudo launchctl load -F /System/Library/LaunchDaemons/tftp.plist # set addr manually to 192.168.2.1  回到 PMON ，配置远程启动：</description>
    </item>
    
    <item>
      <title>通过 systemd-run 直接在容器中执行命令</title>
      <link>https://jiege.ch/devops/run-command-in-container-directly/</link>
      <pubDate>Fri, 06 Jul 2018 15:56:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/run-command-in-container-directly/</guid>
      <description>之前使用 systemd-nspawn 开了容器，然后通过 machinectl shell 进去，想要起一个服务然后丢到后台继续执行，但是发现离开这个 session 后这个进程总是会被杀掉，于是找了 systemd-run 的方案，即：
systemd-run --machine machine_name_here absolute_path_to_executable args_here  这样可以直接在容器中跑服务，而且用这个命令输出的临时 server 名称，还可以看到日志：
journalctl --machine machine_name_here -u unit_name_above  </description>
    </item>
    
    <item>
      <title>通过 iptables 在同一个端口根据源地址解复用（demux）</title>
      <link>https://jiege.ch/networking/2018/07/06/use-iptables-to-serve-different-services-on-one-port/</link>
      <pubDate>Fri, 06 Jul 2018 09:36:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/07/06/use-iptables-to-serve-different-services-on-one-port/</guid>
      <description>现在遇到一个场景，原来的一个服务只给一个客户端用，但现在增加了一个客户端，由于客户端配置相同，但是服务端需要区别对待两个客户端的服务端配置，所以利用 iptables 根据源地址做了一个端口转发，实现了 demux 。
假设：服务器在 192.168.0.1 ，客户端分别在 192.168.0.2 和 192.168.0.3 。客户端配置的服务端地址是 192.168.0.1:8000 。之前，在服务器上只跑了一个服务，监听着 8000 端口。
现在，在服务器上再跑一个服务，监听 8001 端口，同时根据需求进行相应的配置。然后，加上如下 iptables 规则：
$ sudo iptables -t nat -A PREROUTING -s 192.168.0.3 -d 192.168.0.1 -p tcp -m tcp --dport 8000 -j REDIRECT --to-ports 8001  这样，在不需要更改客户端的情况下，完成了需要的效果。</description>
    </item>
    
    <item>
      <title>升级 MongoDB 到 4.0</title>
      <link>https://jiege.ch/programming/2018/07/04/upgrade-mongodb-to-4.0/</link>
      <pubDate>Wed, 04 Jul 2018 07:22:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/07/04/upgrade-mongodb-to-4.0/</guid>
      <description>MongoDB 4.0 刚刚发布，加入了我很想要的 Transaction 功能。不过，我一更新就发现 MongoDB 起不来了。研究了一下日志，发现由于我创建数据库时，MongoDB版本是 3.4 ，虽然后来升级到了 3.6 ，但还是用着 3.4的兼容模式。这个可以这样来检测：
$ mongo &amp;gt; db.adminCommand( { getParameter: 1, featureCompatibilityVersion: 1 } )  如果不是 3.6， 升级到 4.0 之前，需要先执行如下操作：
$ # MongoDB version 3.6 $ mongo &amp;gt; db.adminCommand( { setFeatureCompatibilityVersion: &amp;quot;3.6&amp;quot; } )  然后再升级到 MongoDB 4.0 ，才能正常地启动 MongoDB 4.0 。之后可以考虑尝试使用 MongoDB 4.0 的 Transaction 了。不知道什么时候进入 Debian 的 stretch-backports 源中。
为了使用 MongoDB 4.0 的新特性，输入以下命令：
$ mongo &amp;gt; db.adminCommand( { setFeatureCompatibilityVersion: &amp;quot;4.</description>
    </item>
    
    <item>
      <title>Wireguard 隧道搭建</title>
      <link>https://jiege.ch/networking/2018/06/29/wireguard-tunnel/</link>
      <pubDate>Fri, 29 Jun 2018 10:59:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/06/29/wireguard-tunnel/</guid>
      <description>随着 Wireguard Go 版本的开发，在 macOS 上起 WireGuard Tunnel 成为现实。于是，搭建了一个 macOS 和 Linux 之间的 WireGuard Tunnel。假设 Linux 端为服务端， macOS 端为客户端。
macOS端：
$ brew install wireguard-tools $ cd /usr/local/etc/wireguard $ wg genkey &amp;gt; privatekey $ wg pubkey &amp;lt; privatekey &amp;gt; publickey $ vim tunnel.conf [Interface] PrivateKey = MACOS_PRIVATE_KEY [Peer] PublicKey = LINUX_PUBLIC_KEY # Generated below AllowedIPs = 192.168.0.0/24 Endpoint = LINUX_PUBLIC_IP:12345 $ vim up.sh #!/bin/bash # change interface name when necessary sudo wireguard-go utun0 sudo wg setconf utun0 tunnel.</description>
    </item>
    
    <item>
      <title>Verilog 初体验</title>
      <link>https://jiege.ch/programming/2018/06/21/verilog-first-try/</link>
      <pubDate>Thu, 21 Jun 2018 21:36:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/06/21/verilog-first-try/</guid>
      <description>自己以前一直对硬件方面没有接触，但是大二大三很快就要接触相关知识，所以自己就先预习一下 Verilog HDL，以便以后造计算机。听学长们推荐了一本书叫《自己动手写CPU》，由于自己手中只有很老的 Spartan-3 板子，手上没有可以用来试验的 FPGA ，所以选择用 Verilog + Verilator 进行模拟。既然是模拟，自然是会有一定的问题，不过这个以后再说。
然后就是模仿着这本书的例子，写了指令的获取和指令的解码两部分很少很少的代码，只能解码 ori (or with immidiate) 这一个指令。然后，通过 verilator 跑模拟，输出 vcd 文件，再用 gtkwave 显示波形，终于能够看到我想要的结果了。能够看到，前一个时钟周期获取指令，下一个时钟周期进行解码，出现了流水线的结果。这让我十分开心。
接下来就是实现一些基本的算术指令，然后讲计算的结果写入到相应的寄存器中。这样做完之后，就可以做一个基于 verilator 的简易 A+B 程序了。
我的代码发布在jiegec/learn_verilog中。最近马上到考试周，可能到暑假会更频繁地更新吧。</description>
    </item>
    
    <item>
      <title>在 ArchLinux 上编译 LineageOS for Huawei Angler</title>
      <link>https://jiege.ch/programming/2018/06/18/building-lineageos-in-archlinux/</link>
      <pubDate>Mon, 18 Jun 2018 05:47:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/06/18/building-lineageos-in-archlinux/</guid>
      <description>实践了一下如何在 ArchLinux 上编译自己的 LineageOS 。本文主要根据官方文档 进行编写。
$ # for py2 virtualenv and running x86 prebuilt binaries(e.g. bison) $ sudo pacman -Sy python2-virtualenv lib32-gcc-libs $ mkdir -p ~/bin $ mkdir -p ~/virtualenv $ # build script is written in python 2 $ cd ~/virtualenv $ virtualenv2 -p /usr/bin/python2 py2 $ mkdir -p ~/android/lineage $ curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo $ chmod a+x ~/bin/repo $ vim ~/.config/fish/config.fish set -x PATH ~/bin $PATH set -x USE_CCACHE=1 $ exec fish -l $ cd ~/android/lineage $ repo init -u https://github.</description>
    </item>
    
    <item>
      <title>编写 eBPF 程序和利用 HyperLogLog 统计包的信息</title>
      <link>https://jiege.ch/programming/2018/06/15/ebpf-with-hyperloglog/</link>
      <pubDate>Fri, 15 Jun 2018 22:03:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/06/15/ebpf-with-hyperloglog/</guid>
      <description>前段时间在写概率论与数理统计的期末论文，讨论的主题是如何对一个十分巨大的多重集合（或者是流）中相异元素个数进行估计，写的是 HyperLogLog 等算法。联想到前段时间 LWN 上多次提到的 eBPF 和 BCC 的文章，我准备自己用 eBPF 实现一个高效的估计 inbound packet 中来相异源地址的个数和 outbound packet 中相异目的地址的个数。经过了许多的尝试和努力，最终是写成了 jiegec/hll_ebpf ，大致原理如下：
由于 eBPF 是一个采用专用的 bytecode 并且跑在内核中的语言，虽然我们可以用 clang 写 C 语言然后交给 LLVM 生成相应地 eBPF bytecode ，但仍然收到许多的限制。而且，我很少接触 Linux 内核开发，于是在找内核头文件时费了一番功夫。首先是核心代码：
struct bpf_map_def SEC(&amp;quot;maps&amp;quot;) hll_ebpf_out_daddr = { .type = BPF_MAP_TYPE_PERCPU_ARRAY, .key_size = sizeof(u32), .value_size = sizeof(u32), .max_entries = 256, .pinning = 2 // PIN_GLOBAL_NS }; SEC(&amp;quot;out_daddr&amp;quot;) int bpf_out_daddr(struct __sk_buff *skb) { u32 daddr = get_daddr(skb); u32 hash = Murmur3(daddr, 0); update_hll(&amp;amp;hll_ebpf_out_daddr, hash); return 0; }  首先是声名一个类型为 PERCPU_ARRAY 的 eBPF MAP 类型。这里的 MAP 不是字典，Array 才是真是的数据结构，只不过提供的 API 是类似于字典的。 SEC 宏则是指定这个东西要放在哪一个段，这个在后面会提到。这个函数的作用就是，获取 IP 包的目的地址（其实应该判断一下是否是 IPv4的），然后根据 HyperLogLog 的要求，进行哈希（这里采用的是 Murmur3），然后对得到的哈希值分段，前一部分用于索引，后一部分的 nlz （clz, whatever）用于估计。具体算法详情可以参考 HyperLogLog 的论文。</description>
    </item>
    
    <item>
      <title>调整 Nginx 和 PHP 的上传文件大小限制</title>
      <link>https://jiege.ch/programming/2018/06/10/nginx-php-upload-size-limit/</link>
      <pubDate>Sun, 10 Jun 2018 16:04:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/06/10/nginx-php-upload-size-limit/</guid>
      <description>之前迁移的 MediaWiki ，有人提出说无法上传一个 1.4M 的文件。我去看了一下网站，上面写的是限制在 2M ，但是一上传就说 Entity Too Large，无法上传。后来经过研究，是 Nginx 对 POST 的大小进行了限制，同时 PHP 也有限制。
Nginx 的话，可以在 nginx.conf 的 http 中添加，也可以在 server 或者 location 中加入这么一行：
client_max_body_size 100m;  我的建议是，尽量缩小范围到需要的地方，即 location &amp;gt; server &amp;gt; http 。
在 PHP 中，则修改 /etc/php/7.0/fpm/php.ini ：
post_max_size = 100M  回到 MediaWiki 的上传页面，可以看到显示的大小限制自动变成了 100M ，这个是从 PHP 的配置中直接获得的。</description>
    </item>
    
    <item>
      <title>最近写 Node.js 遇到的若干坑</title>
      <link>https://jiege.ch/programming/2018/06/08/nodejs-experiences/</link>
      <pubDate>Fri, 08 Jun 2018 10:33:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/06/08/nodejs-experiences/</guid>
      <description>最近在做前后端分离，前端在用 Vue.js 逐步重写，后端则变为 api 的形式。同时，我尝试了用 autocannon 和 clinic 工具测试自己的 api endpoint 的性能，一开始发现有几个延迟会特别高，即使是一个很简单的 api 也有不正常的高延迟。
于是，我用 clinic 生成了 flamegraph ，发现了一些问题：
 我在 session 里保存了一些缓存的信息，这部分内容比较大， express-session 在保存到数据库前会先 JSON.stringify 再 crc 判断是否有改变，如果有改变则保存下来。但是由于我的这个对象嵌套层数多，所以时间花得很多。我调整了这个对象的结构，缩小了很多以后，果然这部分快了很多 有一个 API 需要大量的数据库查询，原本是 O（结点总数）次查询，我考虑到我们数据的结构，改成了O（深度），果然快了许多 之前遇到一个小问题，就是即使我没有登录，服务器也会记录 session 并且返回一个 cookie 。检查以后发现，是 connect-flash 即使在没有使用的时候，也会往 cookie 中写入一个空的对象，这就导致 express-session 认为需要保存，所以出现了问题。解决方案就是，换成了它的一个 fork ： connect-flash-plus ，它解决了这个问题  </description>
    </item>
    
    <item>
      <title>在 Nginx 将某个子路径反代</title>
      <link>https://jiege.ch/devops/nginx-proxy-subpath/</link>
      <pubDate>Fri, 01 Jun 2018 07:57:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/nginx-proxy-subpath/</guid>
      <description>现在遇到这么一个需求，访问根下面是提供一个服务，访问某个子路径（/abc），则需要提供另一个服务。这两个服务处于不同的机器上，我们现在通过反代把他们合在一起。在配置这个的时候，遇到了一些问题，最后得以解决。
upstream root { server 1.2.3.4:1234; } upstream subpath { server 4.3.2.1:4321; } server { listen 443 ssl; server_name test.example.com; # the last slash is useful, see below location /abc/ { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; # the last slash is useful too, see below proxy_pass http://subpath/; } location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://root; } }  由于并不想 subpath 他看到路径中 /abc/ 这一层，导致路径和原来在根下不同，通过这样配置以后，特别是两个末尾的斜杠，可以让 nginx 把 GET /abc/index.</description>
    </item>
    
    <item>
      <title>向 Nexus 6P 中刷入 LineageOS 实践</title>
      <link>https://jiege.ch/os/2018/05/29/flashing-lineageos-in-nexus6p/</link>
      <pubDate>Tue, 29 May 2018 07:18:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2018/05/29/flashing-lineageos-in-nexus6p/</guid>
      <description>Nexus 6P 自带的系统没有允许 Root ，所以需要自己解锁 bootloader 并且刷上别的系统。我选择了 LineageOS 。Nexus 6P 的代号为 angler， 首先可以找到官方的安装教程。
我们需要下载的东西：
$ wget https://mirrorbits.lineageos.org/full/angler/20180521/lineage-15.1-20180521-nightly-angler-signed.zip $ wget https://mirrorbits.lineageos.org/full/angler/20180521/lineage-15.1-20180521-nightly-angler-signed.zip?sha256 -O lineage-15.1-20180521-nightly-angler-signed.zip.sha256 $ wget https://mirrorbits.lineageos.org/su/addonsu-15.1-arm64-signed.zip $ wget https://mirrorbits.lineageos.org/su/addonsu-15.1-arm64-signed.zip?sha256 -O addonsu-15.1-arm64-signed.zip $ wget https://github.com/opengapps/arm64/releases/download/20180527/open_gapps-arm64-8.1-full-20180527.zip $ wget https://github.com/opengapps/arm64/releases/download/20180527/open_gapps-arm64-8.1-full-20180527.zip.md5 $ wget https://dl.twrp.me/angler/twrp-3.2.1-0-angler.img $ wget https://dl.twrp.me/angler/twrp-3.2.1-0-angler.img.asc $ wget https://dl.twrp.me/angler/twrp-3.2.1-0-angler.img.md5 $ gpg --verify *.asc $ md5sum -c *.md5 $ sha256sum -c *.sha256  其中 Open GApps 可以自己考虑选择 full 还是其它的选择。
接下来，按照教程，先解锁 bootloader 。连接手机，进入 USB Debugging Mode ，重启进入 bootloader 并且解锁：</description>
    </item>
    
    <item>
      <title>在 WSL 上开启一个 getty 到串口的方法</title>
      <link>https://jiege.ch/os/2018/05/25/opening-tty-terminal-in-wsl/</link>
      <pubDate>Fri, 25 May 2018 21:56:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2018/05/25/opening-tty-terminal-in-wsl/</guid>
      <description>为了测试一个硬件的 terminal ，想在 Windows 上向串口开一个 tty ，跑各种软件来测试。这件事情在 Linux 上和 macOS 上都有实践，但一直不知道 Windows 上怎么搞。经过了一番搜索，找到了 https://blogs.msdn.microsoft.com/wsl/2017/04/14/serial-support-on-the-windows-subsystem-for-linux/ 和 https://unix.stackexchange.com/a/123559 的方案。
以 COM5 为例：
$ sudo chmod 666 /dev/ttyS5 $ sudo agetty -s 115200 ttyS5 linux  这样就可以看到一个登录的界面了。
在 macOS 上(https://superuser.com/questions/1059744/serial-console-login-on-osx)：
$ screen /dev/tty.SLAB_USBtoUART 115200 # type C-b : exec ::: /usr/libexec/getty std.115200  </description>
    </item>
    
    <item>
      <title>体验 Fedora on RISCV</title>
      <link>https://jiege.ch/os/2018/05/24/trying-fedora-on-riscv/</link>
      <pubDate>Thu, 24 May 2018 23:40:00 +0800</pubDate>
      
      <guid>https://jiege.ch/os/2018/05/24/trying-fedora-on-riscv/</guid>
      <description>看到 RISCV 很久了，但一直没能体验。最近工具链不断更新， QEMU 在 2.12.0 也正式加入了 riscv 的模拟。但是自己编译一个内核又太麻烦，就找到了 Fedora 做的 RISCV port，下载下来试用了一下。之前试过一次，但是遇到了一些问题，刚才总算是成功地搞出来了。
官方文档地址： https://fedorapeople.org/groups/risc-v/disk-images/readme.txt 首先下载 https://fedorapeople.org/groups/risc-v/disk-images/ 下的 bbl vmlinux 和 stage4-disk.img.xz 三个文件，然后解压 stage4-disk.img.xz ，大约有 5G 的样子。之前作者在脚本里作死开得特别大，导致我以前光是解压这一步就成功不了。现在终于解决了。
然后启动 qemu 命令打开虚拟机：
qemu-system-riscv64 \ -nographic \ -machine virt \ -m 2G \ -kernel bbl \ -object rng-random,filename=/dev/urandom,id=rng0 \ -device virtio-rng-device,rng=rng0 \ -append &amp;quot;console=ttyS0 ro root=/dev/vda&amp;quot; \ -device virtio-blk-device,drive=hd0 \ -drive file=stage4-disk.img,format=raw,id=hd0 \ -device virtio-net-device,netdev=usernet \ -netdev user,id=usernet,hostfwd=tcp::10000-:22  这段命令摘自 readme.txt ，区别只在于把 -smp 4 去掉了。不知道为什么不能正常工作，可能和作者提到的 FPU patch 有关。然后系统就可以正常起来了（firewalld和systemd-logind不止为啥起不来，但是不用管）。</description>
    </item>
    
    <item>
      <title>在 VMware ESXi 上部署 vCSA 实践</title>
      <link>https://jiege.ch/devops/deploy-vcsa-under-esxi/</link>
      <pubDate>Sun, 20 May 2018 16:44:00 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/deploy-vcsa-under-esxi/</guid>
      <description>首先获取 vCSA 的 ISO 镜像，挂载到 Linux 下（如 /mnt），然后找到 /mnt/vcsa-cli-installer/templates/install 下的 embedded_vCSA_on_ESXi.json ，复制到其它目录并且修改必要的字段，第一个 password 为 ESXi 的登录密码，一会在安装的过程中再输入。下面有个 deployment_option，根据你的集群大小来选择，我则是用的 small 。下面配置这台机器的 IP 地址，用内网地址即可。下面的 system_name 如果要写 fqdn ，记得要让这个域名可以解析到正确的地址，不然会安装失败，我因此重装了一次。下面的密码都可以留空，在命令行中输入即可。SSO 为 vSphere Client 登录时用的密码和域名，默认用户名为 Administrator@domain_name (默认的话，则是 Administrator@vsphere.local) 这个用户名在安装结束的时候也会提示。下面的 CEIP 我选择关闭，设置为 false 。
接下来进行安装。
$ /mnt/vcsa-cli-installer/lin64/vcsa-deploy install /path/to/embedded_vCSA_on_ESXi.json --accept-eula  一路输入密码，等待安装完毕即可。然后通过 443 端口进入 vSphere Client, 通过 5480 端口访问 vCSA 的管理页面。两个的密码可以不一样。
2018-05-21 Update: 想要设置 VMKernel 的 IPv6 网关的话，ESXi 中没找到配置的地方，但是在 vSphere Client 中可以进行相关配置。</description>
    </item>
    
    <item>
      <title>在脚本中寻找 X11 的 DISPLAY 和 XAUTHORITY</title>
      <link>https://jiege.ch/programming/2018/05/11/finding-x11-display-and-xauthority/</link>
      <pubDate>Fri, 11 May 2018 14:21:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/05/11/finding-x11-display-and-xauthority/</guid>
      <description>之前在搞一个小工具，在里面需要访问 X11 server ，但是访问 X11 server 我们需要两个东西：DISPLAY和XAUTHORITY两个环境变量。但是，由于它们在不同的发型版和Display Manager下都有些不同，所以花了不少功夫才写了一些。
为了验证我们是否可以连上 X11 server， 我们使用这一句：
DIMENSIONS=$(xdpyinfo | grep &#39;dimensions:&#39; | awk &#39;{print $2;exit}&#39;)  它尝试打开当前的 DISPLAY，并且输出它的分辨率。接下来，我对不同的一些发型版，综合网上的方法，尝试去找到正确的环境变量。
对于 Debian:
DISPLAY=$(w -hs | awk -v tty=&amp;quot;$(cat /sys/class/tty/tty0/active)&amp;quot; &#39;$2 == tty &amp;amp;&amp;amp; $3 != &amp;quot;-&amp;quot; {print $3; exit}&#39;) USER=$(w -hs | awk -v tty=&amp;quot;$(cat /sys/class/tty/tty0/active)&amp;quot; &#39;$2 == tty &amp;amp;&amp;amp; $3 != &amp;quot;-&amp;quot; {print $1; exit}&#39;) eval XAUTHORITY=~$USER/.Xauthority export DISPLAY export XAUTHORITY DIMENSIONS=$(xdpyinfo | grep &#39;dimensions:&#39; | awk &#39;{print $2;exit}&#39;)  对于 Archlinux：</description>
    </item>
    
    <item>
      <title>在 macOS 和 Linux 之间搭建 tinc 网络</title>
      <link>https://jiege.ch/networking/2018/05/09/tinc-between-macos-and-linux/</link>
      <pubDate>Wed, 09 May 2018 10:02:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/05/09/tinc-between-macos-and-linux/</guid>
      <description>一直听说 tinc 比较科学，所以尝试自己用 tinc 搭建一个网络。这里，macOS 这段没有固定 IP 地址，Linux 机器有固定 IP 地址 linux_ip 。假设网络名称为 example , macOS 端名为 macos 地址为 192.168.0.2, linux 端名为 linux 地址为 192.168.0.1。
2018-11-11 注：本文用的 tinc 版本为 1.0.x ，而不是 1.1-pre ，两个分支命令不同，但协议可以兼容。
在 macOS 上配置：
brew install tinc mkdir -p /usr/local/etc/tinc/example  新建 /usr/local/etc/tinc/example/tinc.conf:
Name = macos Device = utun0 # use an unused number ConnectTo = linux  编辑 /usr/local/etc/tinc/example/tinc-up:
#!/bin/sh ifconfig $INTERFACE 192.168.0.2 192.168.0.1 mtu 1500 netmask 255.</description>
    </item>
    
    <item>
      <title>使用 Nginx 转发 VMware ESXi</title>
      <link>https://jiege.ch/networking/2018/05/08/nginx-proxy-vmware-esxi/</link>
      <pubDate>Tue, 08 May 2018 19:26:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/05/08/nginx-proxy-vmware-esxi/</guid>
      <description>我们的 VMware ESXi 在一台 NAT Router 之后，但是我们希望通过域名可以直接访问 VMware ESXi 。我们首先的尝试是，把 8443 转发到它的 443 端口，比如：
socat TCP-LISTEN:8443,reuseaddr,fork TCP:esxi_addr:443  它能工作地很好（假的，如果你把 8443 换成 9443 它就不工作了），但是，我们想要的是，直接通过 esxi.example.org 就可以访问它。于是，我们需要 Nginx 在其中做一个转发的功能。在这个过程中遇到了很多的坑，最后终于是做好了 （VMware Remote Console等功能还不行，需要继续研究）。
首先讲讲为啥把 8443 换成 9443 不能工作吧 &amp;ndash; 很简单，ESXi 的网页界面会请求 8443 端口。只是恰好我用 8443 转发到 443， 所以可以正常工作。这个很迷，但是测试的结果确实如此。VMware Remote Console 还用到了别的端口，我还在研究之中。
来谈谈怎么配置这个 Nginx 转发吧。首先是 80 跳转 443:
server { listen 80; listen 8080; server_name esxi.example.org; return 301 https://$host$request_uri; }  这个很简单，接下来是转发 443 端口：
 server { listen 443 ssl; server_name esxi.</description>
    </item>
    
    <item>
      <title>搭建 FTP server behind NAT</title>
      <link>https://jiege.ch/networking/2018/05/08/ftp-behind-nat/</link>
      <pubDate>Tue, 08 May 2018 13:34:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/05/08/ftp-behind-nat/</guid>
      <description>我们出现新的需求，要把以前的 FTP 服务器迁移到 NAT 之后的一台机器上。但是，FTP 不仅用到 20 21 端口， PASV 还会用到高端口，这给端口转发带来了一些麻烦。我们一开始测试，直接在 Router 上转发 20 和 21 端口到 Server 上。但是很快发现， Filezilla 通过 PASV 获取到地址为 （内网地址，端口高8位，端口低8位），然后，Filezilla 检测出这个地址是内网地址，于是转而向 router_ip:port 发包，这自然是不会得到结果的。
此时我们去网上找了找资料，找到了一个很粗暴的方法：
iptables -A PREROUTING -i external_interface -p tcp -m tcp --dport 20 -j DNAT --to-destination internal_ip:20 iptables -A PREROUTING -i external_interface -p tcp -m tcp --dport 21 -j DNAT --to-destination internal_ip:21 iptables -A PREROUTING -i external_interface -p tcp -m tcp --dport 1024:65535 -j DNAT --to-destination internal_ip:1024-65535  有趣地是， macOS 自带的 ftp 命令（High Sierra似乎已经删去）可以正常使用。研究发现，它用 EPSV（Extended Passive Mode） 代替 PASV ，这里并没有写内网地址，因而可以正常使用。</description>
    </item>
    
    <item>
      <title>使用 iptables 和策略路由进行带源地址的 forwarding</title>
      <link>https://jiege.ch/networking/2018/05/06/nat-forwarding-with-src-address/</link>
      <pubDate>Sun, 06 May 2018 14:07:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/05/06/nat-forwarding-with-src-address/</guid>
      <description>陈老师打开他的服务器，突然发现 CPU 莫名高负载，然后发现是有一个用户被远程登录拿来挖矿了。但是这台机器在 NAT 后，所以登录的源地址全是 NAT 路由，所以不知道对方的地址是什么。我们为了能使用 fail2ban 来禁用多次尝试失败的 IP ，但又不想因为别人把 NAT 路由的地址给禁了，这样我们自己也用不了了。所以必须要让这台机器能够知道 ssh 的源地址，我们现在简单的 socat 方案不能满足这个需求。
需求：
 可以在外网连 NAT 路由的高端口（如2222）来访问这台机器。 在内网中，既可以直接连它的内网地址，也可以连 NAT 路由的高端口来访问这台服务器。此时，由于连 ssh 的机器就在同一个子网中，如果保留了源地址，服务器发的包会直接回来不经过 NAT 。所以我们还是保留了 socat 的方案。  实现方法：
在 NAT Router 上配置 DNAT ，这样发到 NAT Router 上的包就可以转发到服务器上：
iptables -t nat -A PREROUTING -i external_interface -p tcp -m tcp --dport 2222 -j DNAT --to-destination internal_server_ip:22  但是，从服务器回来的包到了 NAT Router 上后，由于路由表的配置问题，默认的路由并不能把包送达对方。
方法1: 我们首先给包打上 mark：
iptables -t mangle -A PREROUTING -i internal_interface -p tcp -m tcp --sport 22 -j MARK --set-mark 0x2222  然后配置策略路由：</description>
    </item>
    
    <item>
      <title>利用 UPnP 协议进行 mosh NAT 穿透的研究</title>
      <link>https://jiege.ch/networking/2018/05/05/mosh-behind-nat-with-upnp/</link>
      <pubDate>Sat, 05 May 2018 20:25:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/05/05/mosh-behind-nat-with-upnp/</guid>
      <description>由于经常要从宿舍、教室等不同的 Wi-Fi 之间切换，但是 ssh 连接又总是断，所以想用 mosh 代替 ssh 。但是 mosh 也有它的问题：
 不能滚动。这个可以在 mosh 中嵌套一层 tmux 解决。我目前写了一些自动 mosh 后打开 tmux 并且开启鼠标支持的脚本，但还是有缺陷。 在高端口 60000+ 监听 UDP ，这使得 NAT 后的服务器难以直接通过端口转发。如果直接转发到 NAT 后的机器，那么 NAT 后面如果有多台机器，这又失效了。  于是找了找网上的 NAT 穿透的一些文章，看到了 UPnP 的方法。大致就是，用户可以向路由器注册一个临时的转发规则，路由会自动在 iptables 上配置转发。但是，这样也会遇到一个问题：路由上的 mosh-server 不知道这个转发的存在，所以它可能会尝试监听同样的端口。解决方案下面会提到。
需求：
Server &amp;lt;---&amp;gt; NAT Router &amp;lt;---&amp;gt; My Laptop On NAT Router, port 8022 is forwarded to Server:22 1. mosh router # works 2. mosh --ssh=&amp;quot;ssh -p 8022&amp;quot; router # works  首先在 NAT Router 上配置 miniupnpd （以 Debian 为例）</description>
    </item>
    
    <item>
      <title>在 Archlinux 上用 winbind 配合 pam 配置 Windows AD 认证登录</title>
      <link>https://jiege.ch/system/2018/05/05/windows-ad-linux-pam/</link>
      <pubDate>Sat, 05 May 2018 15:39:00 +0800</pubDate>
      
      <guid>https://jiege.ch/system/2018/05/05/windows-ad-linux-pam/</guid>
      <description>作为不清真的网络管理员，为了配置一套完整的统一认证系统，陈老师采用了 Windows AD 的方法给这里配置统一认证。重装了系统，自然要把之前的统一认证再配到新装的 Archlinux 上。
参考资料： Active Directory Integration
首先安装相应的包：
pacman -S samba  我们还没有配好 Kerberos，所以跳过。
然后配置 /etc/samba/smb.conf ，以下是一个例子。可以根据文档微调。
[global] security = ads realm = YOUR-AD-HERE workgroup = YOUR-GROUP-HERE idmap uid = 10000-20000 idmap gid = 10000-20000 winbind enum users = yes winbind enum groups = yes template homedir = /home/%D/%U template shell = /bin/bash client use spnego = yes client ntlmv2 auth = yes encrypt passwords = yes winbind use default domain = yes restrict anonymous = 2  这样，域上的用户 user 会拿到 home 目录为 /home/YOUR-DOMAIN-HERE/user ，uid 在 10000-2000范围内的用户。在一会经过配置之后，可以通过 getent passwd 验证。</description>
    </item>
    
    <item>
      <title>在服务器上安装 Archlinux 记录</title>
      <link>https://jiege.ch/system/2018/05/01/installing-arch-experience/</link>
      <pubDate>Tue, 01 May 2018 16:46:00 +0800</pubDate>
      
      <guid>https://jiege.ch/system/2018/05/01/installing-arch-experience/</guid>
      <description>有一台服务器的 Ubuntu 挂了，我们想在上面重装一个 Archlinux 。我们首先下载了 archlinux-2018.04.01 的 ISO, 直接 dd 到 U 盘上，但是遇到了问题。
首先遇到的问题是，一启动之后就会花屏。我们一开始怀疑是 NVIDIA 驱动的问题，于是想改 kernel param 但是发现，这个 ISO 是 hybrid 的，我们在 macOS 和 Windows 上都不能 mount 上这种类型的盘。于是我们选择自己搞分区表。我们把 U 盘插到电脑上，然后在 Linux 虚拟机内重新分区为 GPT ，然后 mount 到 /mnt/usb ，再重新下载 archlinux iso ，不过此时刚好上游更新了 archlinux-2018.05.01 的影响。我们把 ISO 中根分区 mount 到 /mnt/iso 上来，然后 cp -a /mnt/iso/* /mnt/usb 。调整了 grub 中的内核参数，仍然无果。我们认为问题可能在显卡上，就把那张显卡拔下来了，果然显示就正常了，但是新的问题就来了。
一启动， fstab 尝试把 LABEL=ARCHISO_201805 挂在上来，但是失败。于是我们把 U 盘插到 mac 上，用 Disk Utility 给分区命了名，再插回去，然后这个 Live CD 的 Systemd 就成功起来了。接下来就是根据官方的 Installation Guide 进行安装各种东西。安装完后，在 /boot/EFI 的操作上也出现了一些问题，一开始忘记调用 grub-mkconfig ，导致重启以后进入 grub-rescue ，所以又回到 Live CD 重新 grub-mkconfig 。同时对 systemd-networkd 也进行了相应的调整，这样开机以后可以配好网络。主要就是在网卡上配上两个 VLAN 和相应的 DHCP 和静态地址。</description>
    </item>
    
    <item>
      <title>使用 Cisco AC &#43; AP 组合搭建网络实践</title>
      <link>https://jiege.ch/networking/2018/04/28/wifi-with-cisco-ac-and-ap/</link>
      <pubDate>Sat, 28 Apr 2018 21:58:00 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/04/28/wifi-with-cisco-ac-and-ap/</guid>
      <description>有一台已配置好直接可用的 AC 在地址 ac-address 。我们需要搭建交换机 + AP 的网络，并且用一台 Linux 服务器进行 DHCP 从而给 AP 分发 AC 的地址。这里以 systemd-networkd 为例。
我们约定，vlan 2 上联外网， vlan 3 为 Linux 服务器和 AP 的内部网络。
接下来，配置交换机给 Linux 服务器的端口为 trunk 口，然后将下联 Cisco AP 的端口都设为 access vlan 3 模式。接下来在 Linux 服务器上配置 DHCP 服务器和 NAT 。
如果 Linux 服务器的 interface 名称为 eno1 :
配置两个 VLAN interface:
$ cat /etc/systemd/network/eno1.network [Match] Name=eno1 [Network] VLAN=eno1.2 VLAN=eno1.3  相应添加 VLAN 配置：
$ cat /etc/systemd/network/eno1.</description>
    </item>
    
    <item>
      <title>把 GDB 降级到 8.0.1</title>
      <link>https://jiege.ch/programming/2018/04/17/downgrade-gdb/</link>
      <pubDate>Tue, 17 Apr 2018 13:08:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/04/17/downgrade-gdb/</guid>
      <description>在 macOS 上使用 GDB 需要 codesigning 。但是在 GDB 升级到 8.1 后这种方法不知道为何失效了。所以我安装回了 GDB 8.0.1 并且重新 codesigning ，现在又可以正常升级了。
对 Formula 进行 patch：
diff --git a/Formula/gdb.rb b/Formula/gdb.rb index 29a1c590..25360893 100644 --- a/Formula/gdb.rb +++ b/Formula/gdb.rb @@ -1,14 +1,15 @@ class Gdb &amp;lt; Formula desc &amp;quot;GNU debugger&amp;quot; homepage &amp;quot;https://www.gnu.org/software/gdb/&amp;quot; - url &amp;quot;https://ftp.gnu.org/gnu/gdb/gdb-8.1.tar.xz&amp;quot; - mirror &amp;quot;https://ftpmirror.gnu.org/gdb/gdb-8.1.tar.xz&amp;quot; - sha256 &amp;quot;af61a0263858e69c5dce51eab26662ff3d2ad9aa68da9583e8143b5426be4b34&amp;quot; + url &amp;quot;https://ftp.gnu.org/gnu/gdb/gdb-8.0.1.tar.xz&amp;quot; + mirror &amp;quot;https://ftpmirror.gnu.org/gdb/gdb-8.0.1.tar.xz&amp;quot; + sha256 &amp;quot;3dbd5f93e36ba2815ad0efab030dcd0c7b211d7b353a40a53f4c02d7d56295e3&amp;quot; bottle do - sha256 &amp;quot;43a6d6cca157ef70d13848f35c04e11d832dc0c96f5bcf53a43330f524b3ac40&amp;quot; =&amp;gt; :high_sierra - sha256 &amp;quot;fe7c6261f9164e7a744c9c512ba7e5afff0e74e373ece9b5aa19d5da6443bfc2&amp;quot; =&amp;gt; :sierra - sha256 &amp;quot;cd89001bcf8c93b5d6425ab91a400aeffe0cd5bbb0eccd8ab38c719ab5ca34ba&amp;quot; =&amp;gt; :el_capitan + sha256 &amp;quot;e98ad847402592bd48a9b1468fefb2fac32aff1fa19c2681c3cea7fb457baaa0&amp;quot; =&amp;gt; :high_sierra + sha256 &amp;quot;0fdd20562170c520cfb16e63d902c13a01ec468cb39a85851412e7515b6241e9&amp;quot; =&amp;gt; :sierra + sha256 &amp;quot;f51136c70cff44167dfb8c76b679292d911bd134c2de3fef40777da5f1f308a0&amp;quot; =&amp;gt; :el_capitan + sha256 &amp;quot;2b32a51703f6e254572c55575f08f1e0c7bc2f4e96778cb1fa6582eddfb1d113&amp;quot; =&amp;gt; :yosemite end deprecated_option &amp;quot;with-brewed-python&amp;quot; =&amp;gt; &amp;quot;with-python@2&amp;quot;  </description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（8）</title>
      <link>https://jiege.ch/programming/2018/04/10/thoughts-on-stanford-cs140e-8/</link>
      <pubDate>Tue, 10 Apr 2018 17:27:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/04/10/thoughts-on-stanford-cs140e-8/</guid>
      <description>在上一篇文章之后，我其实还是很忙，但是一直心理惦记着这件事，毕竟只剩最后的一点点就可以做完了，不做完总是觉得心痒。
今天做的部分是调度。我们目前只在 EL0 运行了一个 shell ，每当触发 exception 时回到 kernel 进行处理，再回到原来的地方。但现在，我要实现一个 preemtive round-robin scheduler ，就需要管理当前的所有进程，并且维护当前的进程状态，当时钟中断到来的时候，决定下一个 time slice 要执行的进程，再切换过去。这个过程当然会遇到不少的坑。
首先，我们需要判断一个进程是否可以执行了。考虑到阻塞的 IO ，作者提供了一个优雅的方法：如果这个进程阻塞在 IO 上，那么，提供一个函数，在 scheduler 中调用，判断所需要的数据是否到达。这样，我们就可以一个循环把下一个 time slice 要执行的线程找到。如果找不到，就等待 interrupt 再尝试。
困难的地方在于，在启动的时候，切换到一个起始线程。并且在上下文切换的时候，在 process 1 -&amp;gt; kernel -&amp;gt; process 2 这两步过程中，有许多寄存器都需要仔细考虑如何实现。并且在这个过程中，我也发现了之前写的代码中的问题，最终修复了（目前来看是 working 了）。
我的代码实现在 这里 。下一步就要写 syscall 了。希望能在期中前抽时间赶紧把这个做完。
18:54 PM Update: 刚实现完了 sleep 的 syscall 。比预想中要简单。果然找到了自己实现的调度器的 BUG 。此系列大概是完结了。
2019-02-12 Update: 下一篇文章。</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（7）</title>
      <link>https://jiege.ch/programming/2018/04/07/thoughts-on-stanford-cs140e-7/</link>
      <pubDate>Sat, 07 Apr 2018 14:05:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/04/07/thoughts-on-stanford-cs140e-7/</guid>
      <description>在上一篇文章之后，我很长时间都没有在继续我这个项目，清明节刚好闲下来了我就回来继续啃它。Stanford那边已经结课，最后的 3-spawn 也只有一部分，剩下的部分不知道什么时候作者才会填上去了。
这次主要要写的代码就是，对异常的处理。这里的异常并不是我们编程语言中的 catch/throw ，而是硬件的异常。AArch64 和 x86 一样，也有不同的特权级别的区分，前者是 EL0~EL3 ，后者则是 RING0 和 RING3 。特权级别高可以往特权级别低转换，但是反过来，只能通过异常的方式提高特权等级，并且切换特权等级后只有固定的一些代码可能会跳转，这就是 exception handler/vectors 。这些函数可以知道是什么原因调用了他们，根据硬件规定好的文档，我们可以知道发生了什么事情，是对齐出错了呢，还是用户调用了 syscall 呢，等等。根据不同的情况，我们需要进行不同的处理。当处理完之后，我们需要考虑，跳转回用户代码的时候，回到哪里，提供什么值，不提供什么。
实现的话，需要很多步骤。首先是构造好 exception vector ，这里作者已经写好了一个宏（这里 @BenYip 遇到了一个 assembler 的 BUG ），直接用宏就可以把它写出来。然后，我们需要把它加载到当前 EL 的 VBAR_ELx 寄存器中，当 CPU 抛出异常的时候，就会找到这里相应的处理器进行处理。进到这里以后，我们首先先不考虑太多上下文保存的事情&amp;ndash;我们先保证能处理异常，恢复也是个有很多坑的步骤，作者也是在这里分成了两个 Subphase 。首先还是从 ESR_ELx 中解析到错误的来源的具体内容，如果是我们在 shell 中自己调用的 brk 2 指令，我们就自己新开一个 shell ，修改了提示符以示区别。这样，我们就成功地捕捉到了这个异常。由于我们还无法恢复回去，所以我们直接死循环。
接下来我们要做的是，从异常中恢复出来。由于用户代码可能在各种地方抛出异常，异常也分同步和异步两种情况，这里有许多需要考虑的问题。为了简化，我们目前只考虑同步的 brk 2 导致的 Brk 异常。为了能恢复之后能够正常运行，我们需要把所有的寄存器都保存下来，即 TrapFrame 。保存的时候需要讲究 AArch64 平台下 SP 寄存器的对齐问题。我们也要把一些特殊的寄存器保存下来。还有一点，就是，因为 exception handler 中调用了 context_save 函数，所以此时的 lr 本身也需要进行保存，这个地方也卡了我很久。最后，再把这些一个一个地恢复到原来的样子，调整 ELR_EL1 使得退回到原来的状态时，会跳过当前的 brk 2 指令，调用它的下一调指令。这样，我们就成功地在遇到异常时，弹出一个 shell ，而且还可以回退回来。</description>
    </item>
    
    <item>
      <title>最近比较忙</title>
      <link>https://jiege.ch/others/2018/03/26/busy-these-days/</link>
      <pubDate>Mon, 26 Mar 2018 15:05:00 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2018/03/26/busy-these-days/</guid>
      <description>最近一直没有更新我的 CS140e 系列文章，是因为最近一直忙于各种事情。等有空了再更新吧。</description>
    </item>
    
    <item>
      <title>偶遇清华吴文虎教授</title>
      <link>https://jiege.ch/others/2018/03/08/encountering-wu-wenhu/</link>
      <pubDate>Thu, 08 Mar 2018 17:47:50 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2018/03/08/encountering-wu-wenhu/</guid>
      <description>今天百团大战，正准备收摊的时候，天空工场那边来了一位长者，在和他们聊着什么。我很感兴趣，就上去听。老人大概已有八十高龄（后来查，是1936年生），但依然精神矍铄，首先和我们讲，作为工科的学生，一定在理解原理的基础上，多多去实践。他举了他自己的例子，他首先在电机系学习，后来，计算机系成立（当时还是自动控制系），他转到了计算机系，重新学起了计算机，说计算机编程学起来并没有什么难的。当年，苹果公司送过来了中国第一台 Apple-2 ，他们就把电脑拆了下来研究原理，又装上去继续工作。后来，他就在计算机系任教，教的正是《程序设计基础》这门课程。他十分重视实践，在第一年开课的时候就说，最关键的就是实践，安排了一些编程实验课，期中期末就是大作业。一开始有一些同学不重视实践，结果期末就挂科了。后来同学们就明白了实践的重要性，实践起来发现并没有那么难，最后就说，“吴老师，你说得对”。他又谈到了他的体育，他当年是北京长跑代表队的集训队选手，擅长一千五百米项目，他三千米只需要九分钟就能跑完。我们都感到自愧不如。我们说，现在的《程序设计基础》是徐明星老师在教，他说徐明星是他的博士生，邬晓钧也是他的博士生，他另外还有一个高徒我记不清楚了。他还是IOI中国队的前教练，听到我们有过一些OI基础，表示了赞许和鼓励。还有一些细节记不清楚了，记起来了再补充吧。</description>
    </item>
    
    <item>
      <title>〖新手向〗绕过 C&#43;&#43; 类的访问限制</title>
      <link>https://jiege.ch/programming/2018/03/07/breaking-c-weak-access-control/</link>
      <pubDate>Wed, 07 Mar 2018 07:59:20 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/03/07/breaking-c-weak-access-control/</guid>
      <description>这是一篇很水的文章，面向萌新，已经知道了的可以自觉绕道。
昨天上课，有同学问，如果用户偷偷把 private 改成 public 再和原有的库链接，是不是就可以在用户代码里更改了。这个答案是肯定的。下面我们就做个实验：
首先，创建 good_class.h 和 good_class.cpp:
class SomeClass { private: int data; public: int getData(); };  #include &amp;quot;good_class.h&amp;quot; int SomeClass::getData() { return data; }  然后，首先编译，
clang++ -c good_class.cpp -o good_class.o  然后，修改 good_class.cpp 并写一个 evil_user.cpp
class SomeClass { public: int data; public: int getData(); };  #include &amp;lt;stdio.h&amp;gt; #include &amp;quot;good_class.h&amp;quot; int main() { SomeClass a; a.data = 37; printf(&amp;quot;%d\n&amp;quot;, a.getData()); return 0; }  编译：</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（6）</title>
      <link>https://jiege.ch/programming/2018/03/05/thoughts-on-stanford-cs140e-6/</link>
      <pubDate>Mon, 05 Mar 2018 19:55:49 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/03/05/thoughts-on-stanford-cs140e-6/</guid>
      <description>在上一篇文章之后，作者终于更新了测试的用例，我的程序终于可以成功跑过所有测试，也成功在树莓派跑起来。不过，我的代码中很多地方的错误处理比较偷懒，往往直接 panic ，显然并不友好。同时，我想到了使用 cargo-fuzz 来进行自动化测试，果然，使用这个很快就修复了不少我没想到的会出错的地方，比如乘法溢出，目录项没有正确结束等等。目前还发现一个 timeout 的问题，研究发现大概是文件的 cluster chain 中出现了环，导致一直读取文件而没有停止。要解决这个问题，我目前想到的是 Floyd 的判圈算法，但还没上实现。等过几天，新的 Assignment 3 出了以后，再继续更新。希望作者少点跳票，多点勤奋，哈哈哈哈哈
更新：下一篇在这里。</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（5）</title>
      <link>https://jiege.ch/programming/2018/03/03/thoughts-on-stanford-cs140e-5/</link>
      <pubDate>Sat, 03 Mar 2018 11:07:30 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/03/03/thoughts-on-stanford-cs140e-5/</guid>
      <description>在上一篇文章之后，作者多次延期跳票之后（again），终于放出了 Assignment 2 Phase 3: Saddle Up 。这次，我们要做的变成了把已经写好的（错漏百出）的 fat32 的驱动搬到树莓派里面去，然后实现一些基本的 shell 命令： ls cat cd 等等。作者首先更新了老版本的新的测试样例，放了一些映像然后提供了预期的结果，结果发现，这里的 fat32 有一些不同，主要的就是 bytes_per_sector 不是 512 了，意味着物理的扇区和逻辑扇区并不一致。同时， sectors_per_cluster 也不是 1 了，需要考虑多个扇区的情况。同时， read_cluster 传入的 offset 也可能不再是第一个 sector 中的，所以需要做一个处理。对于物理和逻辑扇区的问题，作者推荐的方案是，把 fat32 之外的扇区保持不变，把其内的扇区视为逻辑扇区。这样，其它代码都可以透明地工作，而不用到处更改，这就体现了封装的威力。接着，作者提供了一个写好了的 libsd 和一些导出的函数，使用这些函数即可。不过，在错误处理和 timeout 上也遇到了一些坑。后面，把东西搬到树莓派上运行，问题就出现了：读取了第一个扇区（即 MBR 所在的扇区）之后，直接就死掉了。想了半天都没找到方案，突然想起可以利用 panic! 对错误语句进行二分查找。查找了大概有七八个小时之后，终于发现，问题出现在读取一个 u32 类型的变量上。我起初怀疑是栈出了问题，所以放到堆上分配，然而还是不行。忽然想起以前遇到的对齐问题，在 AArch64 架构上，可能为了简化，读取的 u32 必须对齐到四个字节上。于是找了找 Rust 中的对齐方面的文档，找到了 #[repr(align=4)] 这种表示方法，代替了原来的 #[repr(packed)] ，并且把数据先拷贝到对齐后的栈上的对应数据结构，然后再读取对应的项。果然，这个问题就解决了。然后又发现我的盘中会出现 lfn 项并不是从后往前的情况，于是我又修改了一下相关的代码。现在，终于可以成功地 ls cat cd 。
不过还是要吐槽一下，作者的测试用的映像文件中，会出现 0xE5 表示这个项已经被删除的情况，但是似乎作者的代码并没有处理这个，所以在预期的输出中出现了一些明显不正确的结果，导致我的代码跑测试并不能通过。而且，作者的代码在一些情况下会把文件的后缀漏掉。作者后来更新了几次测试的文件，不过这个问题只解决了一部分，并没有完全解决。坐等作者继续放出新的测试文件吧。
更新：下一篇在这里。</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（4）</title>
      <link>https://jiege.ch/programming/2018/02/27/thoughts-on-stanford-cs140e-4/</link>
      <pubDate>Tue, 27 Feb 2018 22:42:59 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/02/27/thoughts-on-stanford-cs140e-4/</guid>
      <description>在上一篇文章之后，作者多次延期跳票之后，终于放出了 Assignment 2 Phase 2:32-bit Lipids ，这两天就把只读 FAT32 写完了（不过封装得并不好，许多地方利用了 pub(super) 把变量可以访问的范围控制到 vfat 中，然后直接读，只有少数需要特殊处理的进行了函数的封装）。首先当然是研究了半天 MBR 和 FAT32 的结构，拿了不同来源的 FAT 结构说明进行对比和验证，最后终于把格式搞清楚了，先实现了 MasterBootRecord ，这个其实很好实现，以前也有接触过 MBR ，本身也很简单。然后就是根据 MBR 找到第一个 FAT32 的分区，根据偏移找到分区的开头，开头的第一个扇区就是 EBPB 数据结构，里面保存了 FAT32 分区的各种信息。根据里面的信息，可以找到 FAT 表的位置和数量，还有数据部分的 Cluster 的位置和数量。接着，解析一下 FAT 表，实际上是一个与 Cluster 一一对应的链表结构，用特殊的数据代表链表的尾和空、坏扇区。利用这些，和 EBPB 中根目录所在的第一个 Cluster ，先在 VFat 里面实现了读取一个 Cluster 链的内容的函数，利用这个函数读取一个一个的目录项，解析目录项，把长文件名的项合并到一个之中，然后对应地丢到 Entry 对象中，目录则可以枚举子目录项，根据名字比较去找子目录或者子文件夹，文件则实现了 io::Read和 io::Seek 使得可以读取文件的内容。实现好了这些以后，就拿了 raspbian-strech-lite.img 作为硬盘映像，从文件里读取文件信息，成功地把 config.txt 读取出来。
其中还是遇到许多困难，如各种偏移的计算，如何处理跨 Cluster 和跨 Sector 的读写，等等，有不少的坑在其中，花了两天的空余时间才差不多完善了这个功能。还有就是利用 Rust 现有的功能完成 C 里面很轻易就可以实现的指针操作，也花了不少时间。
更新：下一篇在这里。</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（3）</title>
      <link>https://jiege.ch/programming/2018/02/16/thoughts-on-stanford-cs140e-3/</link>
      <pubDate>Fri, 16 Feb 2018 20:09:00 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/02/16/thoughts-on-stanford-cs140e-3/</guid>
      <description>由于 Assignment 2: File System 延期发布，所以中间那段时间转向 MIT 6.828 稍微研究了一下。前几天放出了新的任务，在上一篇文章之后，我又有了一些进展： 实现了从内存中读取 ATAGS(ARM Tags) 信息的代码，从而可以获得内存大小的信息，根据这个信息，实现了 bump 和 bin 两种内存分配器，并且把二者之一注册为全局内存分配器，利用上更新了的 std 就可以使用需要动态分配内存的相关工具了。利用这个，我实现了 shell 输入历史的回溯，把输入历史保存在一个动态增长的数组中，再特殊处理上下键，把当前的行替换为历史。
这个过程也不是没有踩坑。一开始代码放出来了，但是题目说明还没出，我就自己按照代码做了 ATAGS 和 bump 分配器，后来做完了，看到说明出了以后，发现理解还是有偏差，把代码更改了并修复了分配器的 BUG 。看到 bin 分配器的时候，我按照网上的 buddy memory allocation 实现了一个内存分配器，原理看起来简单实现起来还是有很多细节问题，后来按照新放出的单元测试，修修补补才写得差不多可用了。同时，原来的 bootloader 因为用了新的 std 而缺失了 alloc 不能编译，我就把 kernel 下的相关文件软连接过去，调了数次后把问题解决。此时， kernel 文件大小已经有 40K ，按照 115200 Baudrate 发送需要几秒才能传输过去，我就调到了 230400 Baudrate ，果然现在的传输速度就有所提升，可以接受了。等之后写了 EMMC(SD card) 的驱动和 FAT32 的文件系统后，就可以实现更多的 shell 的功能了。中间还遇到一个问题，就是如果给 kernel 开启了 bin 分配器，使用 exit 回到 bootloader 就无法传新的 kernel 上去了，结果发现是因为 bin 中用到的侵入式 LinkedList 实现覆盖了部分 bootloader 的代码，换回不能回收内存的 bump 分配器即可，反正目前远远还用不了那么多内存。</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考（2）</title>
      <link>https://jiege.ch/programming/2018/02/06/thoughts-on-stanford-cs140e-2/</link>
      <pubDate>Tue, 06 Feb 2018 12:52:59 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/02/06/thoughts-on-stanford-cs140e-2/</guid>
      <description>在上一篇文章之后，我又有了一些进展：UART ，简易的shell ，修复了之前写的 xmodem 中的 BUG，一个可以从 UART 接收一个 kernel 写入到内存中再跳转过去的 bootloader 。
首先是 UART ，就是通过两个 GPIO pin 进行数据传输，首先在 memory mapped IO 上进行相应的初始化，然后包装了 io::Read 和 io::Write （这里实现一开始有 BUG，后来修复了），然后很快地完成了一个仅仅能 echo 的 kernel 。
然后实现了 CONSOLE ，一个对 MiniUart 和单例封装，就可以用 kprint!/kprintln! 宏来输出到 UART ，接着实现了一个 echo 的 shell ，读入一行输出一行。然后实现退格键和方向键，这里的难点在于要控制光标并且用读入的或者空格覆盖掉屏幕上已经显示而不应该显示的内容。接着，利用 skeleton 中的 Command 做了一个简单的 echo 命令。
接着，利用之前编写的 tty ，配合上新编写的 bootloader ，实现通过 UART 把新的 kernel 通过 XMODEM 协议发送到设备，写入 0x80000 启动地址并且调转到新加载的 kernel 中执行。
最后，又实现了 uptime （输出设备启动到现在的时间）和 exit （跳转回 bootloader ，可以上传新的 kernel ）。并添加了 TUNA 作为 shell 启动时输出的 BANNER 。</description>
    </item>
    
    <item>
      <title>近来做 Stanford CS140e 的一些进展和思考</title>
      <link>https://jiege.ch/programming/2018/02/04/thoughts-on-stanford-cs140e/</link>
      <pubDate>Sun, 04 Feb 2018 22:28:23 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/02/04/thoughts-on-stanford-cs140e/</guid>
      <description>最近，受各路安利，剁手买下了 这个淘宝商家的树莓派的套餐C ，还买了许多 LED 灯泡、杜邦线和电阻，开始按照 CS 140e 学习 Rust 并且用 Rust 编译写一个简易的操作系统。Assignment 0 的目标就是编写一个向 GPIO 16 连接的 LED 灯闪烁。首先当然就是愉快地按照教程下载 bootloader ，下载交叉编译工具链，顺带装一个 Raspbian 到机器上，随时可以当成一个低性能的 ARM/ARM64 （实际上，Raspbian 只用了armv7l，没有用 64bit）机器来用，以后如果配上 @scateu 团购的 Motorola Laptop Dock 的话就是一个几百块的笔记本了。把课程上的文件丢上去，可以看到绿色的活动指示灯闪烁，后面又把 CP2102 模块连上去，又能看到 Blink on, Blink off 的输出。然后按照要求，自己先码一段 C 语言，实现 blinky:
#define GPIO_BASE (0x3F000000 + 0x200000) volatile unsigned *GPIO_FSEL1 = (volatile unsigned *)(GPIO_BASE + 0x04); volatile unsigned *GPIO_SET0 = (volatile unsigned *)(GPIO_BASE + 0x1C); volatile unsigned *GPIO_CLR0 = (volatile unsigned *)(GPIO_BASE + 0x28); static void spin_sleep_us(unsigned int us) { for (unsigned int i = 0; i &amp;lt; us * 6; i++) { asm volatile(&amp;quot;nop&amp;quot;); } } static void spin_sleep_ms(unsigned int ms) { spin_sleep_us(ms * 1000); } int main(void) { // STEP 1: Set GPIO Pin 16 as output.</description>
    </item>
    
    <item>
      <title>再次吐槽 VS 关于 scanf 和 scanf_s 的问题</title>
      <link>https://jiege.ch/programming/2018/01/30/more-on-scanf-and-scanf_s/</link>
      <pubDate>Tue, 30 Jan 2018 16:05:33 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/01/30/more-on-scanf-and-scanf_s/</guid>
      <description>继上次的吐槽后，今天再次遇到同学因为 scanf 在 VS 下的 deprecation error 感到十分迷茫，在知乎上求助又因为拍照的原因被说，我就在此再次吐槽一下 VS 这对初学者很不友善很不友善的两点。
一点就是上面提到的这个，另一点就是程序结束后任意键以退出这一功能要做得更加醒目一点 。前者由于大多数新手在学习 C/C++ 的时候都会跟着书上或者网上的代码敲一遍输入输出的代码，很容易就会撞到这个问题。后者则会让新手习惯性地以为程序闪退了，没有出结果，而不知道其实是程序执行结束后关闭而已。</description>
    </item>
    
    <item>
      <title>我正在使用的两个 Emacs 的 Patch</title>
      <link>https://jiege.ch/programming/2018/01/07/two-patches-of-emacs-i-am-using/</link>
      <pubDate>Sun, 07 Jan 2018 14:24:24 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2018/01/07/two-patches-of-emacs-i-am-using/</guid>
      <description>我在本地对 emacs.rb 进行了修改：
diff --git a/Formula/emacs.rb b/Formula/emacs.rb index d0138cd..de3c5ff 100644 --- a/Formula/emacs.rb +++ b/Formula/emacs.rb @@ -4,6 +4,14 @@ class Emacs &amp;lt; Formula url &amp;quot;https://ftp.gnu.org/gnu/emacs/emacs-25.3.tar.xz&amp;quot; sha256 &amp;quot;253ac5e7075e594549b83fd9ec116a9dc37294d415e2f21f8ee109829307c00b&amp;quot; + patch do + url &amp;quot;https://gist.githubusercontent.com/aatxe/260261daf70865fbf1749095de9172c5/raw/214b50c62450be1cbee9f11cecba846dd66c7d06/patch-multicolor-font.diff&amp;quot; + end + + patch do + url &amp;quot;https://debbugs.gnu.org/cgi/bugreport.cgi?filename=0001-Fix-child-frame-placement-issues-bug-29953.patch;bug=29953;att=1;msg=8&amp;quot; + end + bottle do sha256 &amp;quot;d5ce62eb55d64830264873a363a99f3de58c35c0bd1602cb7fd0bc37137b0c9d&amp;quot; =&amp;gt; :high_sierra sha256 &amp;quot;4d7ff7f96c9812a9f58cd45796aef789a1b5d26c58e3e68ecf520fab34af524d&amp;quot; =&amp;gt; :sierra  主要涉及到两个 Patch ：
 启用对 Multicolor font ，比如 Emoji 的支持。由于一些 ethic problems 暂时在 Emacs 中被禁用了，所以自己启用回来。 打上我前几天上报的 BUG #29953 的修复。已经在上游 Merge 到 emacs-26 分支中，这个修复会在下一个版本中。  有了第一个，就可以正常显示 Emoji （对不起，RMS）；有了第二个，就解决了 pyim 和 lsp-ui-peek 用 child-frame 显示的一些问题了。</description>
    </item>
    
    <item>
      <title>NAT64 初尝试</title>
      <link>https://jiege.ch/networking/2018/01/02/first-trail-of-nat64/</link>
      <pubDate>Tue, 02 Jan 2018 19:41:22 +0800</pubDate>
      
      <guid>https://jiege.ch/networking/2018/01/02/first-trail-of-nat64/</guid>
      <description>最近宿舍里有线网络的 IPv4 总是拿不到地址，只能连无线网，不禁对计算机系学生的可怕的设备数量有了深刻的认识。不过，作为一个有道德（误）的良好青年，还是不要给已经枯竭的 IPv4 地址填堵了，还是赶紧玩玩 IPv6 的网络吧。然后在 TUNA 群里受青年千人续本达 (@heroxbd) 的安利，本地搭建一下 NAT64+DNS64 的环境。不过考虑到宿舍还是拿不到有线的 IPv4 地址，我就先利用苹果先前在强制 iOS 的应用支持 NAT64 网络的同时，在 macOS 上为了方便开发者调试，提供的便捷的建立 NAT64 网络的能力。
首先在设置中按住 Option 键打开 Sharing ， 点击 Internet Sharing ，勾上 Create NAT64 Network 然后把网络共享给设备。然后在手机上关掉 Wi-Fi 和 Cellular ，发现还能正常上网。此时可以打开 Wireshark 验证我们的成果了：
在手机上打开浏览器，浏览千度，得到如下的 Wireshark 截图： 这里，2001:2:0:aab1::1 是本机在这个子网中的地址，2001:2::aab1:cda2:5de:87f6:fd78 是我的 iOS 设备的地址，然后 iOS 向 macOS 发出了 DNS请求， macOS 发送 DNS 请求后得到 baidu.com 的 IPv4 地址之一为 111.13.101.208 ： 上图中，我们可以看到， baidu.com 的 AAAA 记录是 2001:2:0:1baa::6f0d:65d0 ，这个就是 DNS64 转译的地址，前面为网关的 prefix ，后面就是对应的 IPv4 地址： 0x6f=111, 0x0d=13, 0x65=101, 0xd0=208 ，当客户端向这个地址发包的时候，网关发现前缀符合条件，把最后的这部分 IPv4 地址取出来，自己把包发送到真实的地址上去，再把返回来的包再转为 IPv6 的地址返还给客户端。可以验证，剩下的几个地址也符合这个转译规则。</description>
    </item>
    
    <item>
      <title>有趣的 Java 日期格式化问题</title>
      <link>https://jiege.ch/programming/2017/12/31/interesting-java-formatting-problem/</link>
      <pubDate>Sun, 31 Dec 2017 10:55:23 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2017/12/31/interesting-java-formatting-problem/</guid>
      <description>今天在群里看到有人说， Java 的日期格式化有问题，如果用 YYYY-MM-dd ，今天的日期就会显示 2018-12-31 。我立马在本地用 Java REPL (aka Groovy) 跑了一下，果然如此：
$ date = new Date() ===&amp;gt; Sun Dec 31 10:51:26 CST 2017 $ import java.text.SimpleDateFormat ===&amp;gt; java.text.SimpleDateFormat $ new SimpleDateFormat(&amp;quot;YYYY-MM-dd&amp;quot;).format(date) ===&amp;gt; 2018-12-31  解决方案是，把格式换为 yyyy-MM-dd ，确实就可以了。于是我就去研究了一下文档： Class SimpleDateFormat ，发现了问题：
y 代表 year ，而 Y 代表 week year 。根据 week year ，因为今年最后的一个星期在明年的部分更多，于是这个星期被归在了明年，所以这一周属于 2018 ，这就可以解释之前的那个输出问题了。</description>
    </item>
    
    <item>
      <title>在 macOS 上试用 Gentoo/Prefix</title>
      <link>https://jiege.ch/devops/try-gentoo-prefix-on-macos/</link>
      <pubDate>Wed, 27 Dec 2017 20:25:23 +0800</pubDate>
      
      <guid>https://jiege.ch/devops/try-gentoo-prefix-on-macos/</guid>
      <description>前几天参加了许朋程主讲的Tunight，对Gentoo有了一定的了解，不过看到如此复杂的安装过程和长久的编译时间，又看看我的CPU，只能望而却步了。不过，有Gentoo/Prefix这个工具，使得我们可以在其它的操作系统（如macOS,Solaris等）上在一个 $EPREFIX 下跑 Portage ，也就是把 Portage 运行在别的操作系统，当作一个包管理器，并且可以和别的操作系统并存。
首先还是祭出官网：Project:Prefix。
首先设定好环境变量 $EPREFIX ，之后所有的东西都会安装到这个目录下，把 bootstrap-prefix.sh 下载到 $EPREFIX ，然后 ./bootstrap-prefix.sh ，会进行一系列的问题，一一回答即可。建议在运行前设置好 GENTOO_MIRRORS=http://mirrors.tuna.tsinghua.edu.cn/gentoo 由于TUNA没有对gentoo_prefix做镜像，只能把distfiles切换到TUNA的镜像上。
然后。。。
stage1&amp;hellip;
stage2..
stage3.
emerge -e @world BOOM
经过 n 次跑挂以后，终于搞完了 stage3 ，然后 SHELL=bash ./bootstrap-prefix.sh $EPREFIX startscript 生成 startprefix ，在外面的SHELL中向切进来的时候运行这个即可。
然后就可以使用Gentoo/Prefix了。注意！此时的 $PATH 仅限于 $EPREFIX 下几个目录和 /usr/bin /bin 所以很多东西都会出问题（Emacs, Vim, Fish etc）。小心不要把自己的目录什么的搞挂了。
然后就可以假装试用Gentoo了！
哈哈哈哈哈哈哈
死于编译 libgcrypt 和 llvm 。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2017/12/12/lsp-and-cpp/</link>
      <pubDate>Tue, 12 Dec 2017 08:13:40 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2017/12/12/lsp-and-cpp/</guid>
      <description>之前时间，巨硬发布了LSP（Language Server Protocol），目的是解决目前IDE和各语言的m+n问题。想法很好，不过直到最近，终于有我觉得可以用的工具出来了，并且已经代替了我在使用的其它的插件。
由于我最近主要就是做做程设作业，做做OJ这些，主要就是和C++打交道。所以我当然就开始找一些比较成熟的C++的LSP server。有一个 Sourcegraph 维护的 langserver.org ，上面有着目前的各个语言和编辑器/IDE的支持情况，我刚才提到的cquery也会加入到这个列表里去。从这个列表里可以看到，我用的比较多的Python和Haskell都已经有不错的的LSP server，我已经开始在本地体验pyls和hie了，感觉做得挺不错的。
回到C++，我的主力编辑器是Emacs，其次是CLion，而Emacs上的LSP支持 lsp-mode也在快速发展，与之配合的lsp-ui 也出现了很多很棒的功能。
下面开始编译并配置cquery：
git clone https://github.com/jacobdufault/cquery --recursive cd cquery ./waf configure # to use system clang, append --use-system-clang ./waf build  然后配置Emacs：
(use-package lsp-mode :ensure t :diminish lsp-mode :commands (lsp-mode) :config (lsp-define-stdio-client lsp-pyls &amp;quot;python&amp;quot; #&#39;get-project-root &#39;(&amp;quot;/usr/local/bin/pyls&amp;quot;))) (use-package lsp-ui :commands lsp-ui-mode :init (add-hook &#39;lsp-mode-hook &#39;lsp-ui-mode)) (use-package cquery :load-path &amp;quot;path_to_cquery/emacs&amp;quot; :config (setq cquery-executable &amp;quot;path_to_cquery/build/app&amp;quot; cquery-resource-dir &amp;quot;path_to_cquery/clang_resource_dir&amp;quot;))  接下来，需要配置 基于Clang的 工具都需要的 Compilation Database 。Sacrasm对这个有一个非常完整的总结 ，可以查看里面的方法。我这里推荐在CMake项目中用CMake自带的，加上nickdiego/compiledb-generator 应付基于Makefile/Autotools的项目。如果都不适用，就按照cquery的README写一个简单的.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2017/12/02/on-nginx-memory-pool/</link>
      <pubDate>Sat, 02 Dec 2017 22:16:07 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2017/12/02/on-nginx-memory-pool/</guid>
      <description>今晚参加了 Tunight ，会长给我们讲了 Nginx 的一些内部运作的机制和原理。中间的时候，会长展示的代码中用到了线程池方面的一些函数，但是大多地方只有调用 ngx_pcalloc 而没有看到相应的对象释放的过程，于是在演示的最后，会长应大家要求对 Nginx 魔幻的线程池实现做了现场代码分析。
在分析的中途遇到了很多坑，最后才终于理清了内存池的工作原理。这里直接解释结论吧。以下代码均摘自 Nginx 1.13.7 ，代码都可以在官方仓库找到。
首先分析一下创建一个内存池的函数：
ngx_pool_t * ngx_create_pool(size_t size, ngx_log_t *log) { ngx_pool_t *p; p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log); if (p == NULL) { return NULL; } p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t); p-&amp;gt;d.end = (u_char *) p + size; p-&amp;gt;d.next = NULL; p-&amp;gt;d.failed = 0; size = size - sizeof(ngx_pool_t); p-&amp;gt;max = (size &amp;lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL; p-&amp;gt;current = p; p-&amp;gt;chain = NULL; p-&amp;gt;large = NULL; p-&amp;gt;cleanup = NULL; p-&amp;gt;log = log; return p; }  现在开始分段分析这个函数：在这里，一个内存池用一个 ngx_pool_t (aka struct ngx_pool_s) 类型的数据进行包装，所有的关于内存池的操作都基于相应的内存池对象。 ngx_log_t 表示输出信息的对象，与内存池无关，后面也不会讨论它。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2017/11/30/run-cpp-in-jupyter-notebook/</link>
      <pubDate>Thu, 30 Nov 2017 18:07:10 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2017/11/30/run-cpp-in-jupyter-notebook/</guid>
      <description>刚刚在HN上看到了这么一个文章：Interactive Workflows for C++ with Jupyter HN ，终于可以在Jupyter Notebook里跑C++代码了，很开心，于是开始自己研究了起来怎么本地跑。
首先当然是更新一波jupyter，安装一波cling：
pip3 install -U jupyter brew install cling  然后根据官方教程里的要求执行：
cd /usr/local/share/cling/Jupyter/kernel pip3 install -e . jupyter kernelspec install cling-cpp11 jupyter kernelspec install cling-cpp14 jupyter kernelspec install cling-cpp17 jupyter kernelspec install cling-cpp1z  结果发现找不到jupyter-kernelspec，遂重装了一下jupyter-client这个包，果然就可以了。打开一个notebook测试：
jupyter notebook  然后创建一个C++14的Notebook，结果发现一直Kernel rebooting，错误信息是说找不到../Cellar/cling/0.5/lib/libclingJupyter.dylib。这一看就是路径处理的问题，当前目录肯定不是/usr/local，肯定出现了什么问题，然后研究发现cling-kernel.py中对cling判断是否是个连接，如果是连接则按照连接去找cling的安装目录，但是！没有考虑到这个连接是个相对路径的问题（Homebrew你背锅吗）。于是我愉快地改了代码并提交了PR。修复了以后就可以用了。
以下是一个小小的例子：
&amp;gt;&amp;gt; jupyter console --kernel cling-cpp14 Jupyter console 5.2.0 cling-X In [1]: #include &amp;lt;stdio.h&amp;gt; Out[1]: In [2]: char *s = &amp;quot;Hello, world!&amp;quot;; input_line_4:2:12: warning: ISO C++11 does not allow conversion from string literal to &#39;char *&#39; [-Wwritable-strings] char *s = &amp;quot;Hello, world!</description>
    </item>
    
    <item>
      <title>用CPUID获取评测机器的CPU</title>
      <link>https://jiege.ch/others/2017/10/30/use-cpuid-to-get-machine-cpu/</link>
      <pubDate>Mon, 30 Oct 2017 21:07:23 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2017/10/30/use-cpuid-to-get-machine-cpu/</guid>
      <description>受用 CPUID 检测各大 OJ 测评机所用的 CPU（以及日常黑 BZOJ）的启发，我决定去测试一下徐老师自己写的OJ（名为Tyche）所跑的机器是什么CPU。于是我改造一下代码，用以下代码测评：
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;cpuid.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; static void cpuid(uint32_t func, uint32_t sub, uint32_t data[4]) { __cpuid_count(func, sub, data[0], data[1], data[2], data[3]); } int main() { uint32_t data[4]; char str[48]; for(int i = 0; i &amp;lt; 3; ++i) { cpuid(0x80000002 + i, 0, data); for(int j = 0; j &amp;lt; 4; ++j) reinterpret_cast&amp;lt;uint32_t*&amp;gt;(str)[i * 4 + j] = data[j]; } struct timeval stop, start; gettimeofday(&amp;amp;start, NULL); while(1) { gettimeofday(&amp;amp;stop, NULL); if(stop.</description>
    </item>
    
    <item>
      <title>一个代替Pulse Secure客户端的工具</title>
      <link>https://jiege.ch/others/2017/10/26/alternative-to-pulse-secure/</link>
      <pubDate>Thu, 26 Oct 2017 07:50:34 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2017/10/26/alternative-to-pulse-secure/</guid>
      <description>清华的校外VPN服务使用的是Pulse Secure,所以在外网我们需要在客户端上安装Pulse Secure才能使用内网的info和网络学堂等网站.但是Pulse Secure一是非自由软件二界面难看,所以我找到了一个代替它的工具:OpenConnect.
安装后,输入以下命令:
sudo openconnect --user 你的学号 sslvpn.tsinghua.edu.cn --juniper --reconnect-timeout 60 --servercert sha256:398c6bccf414f7d71b6dc8d59b8e3b16f6d410f305aed7e30ce911c3a4064b31  然后输入你的info密码即可.</description>
    </item>
    
    <item>
      <title>分析一个我第一次见的素数测试函数</title>
      <link>https://jiege.ch/programming/2017/10/17/analysis-on-a-primality-test/</link>
      <pubDate>Tue, 17 Oct 2017 21:05:28 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2017/10/17/analysis-on-a-primality-test/</guid>
      <description>今天逛到这个连接，发现其中的第四种素数判定方法很有意思：
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;math.h&amp;gt; int p[8]={4,2,4,2,4,6,2,6}; int prime(int n) { int i=7,j,q; if(n==1)return 0; if(n==2||n==5||n==3)return 1; if(n%2==0||n%3==0||n%5==0)return 0; q=(int)sqrt(n); for(;i&amp;lt;=q;){ for(j=0;j&amp;lt;8;j++){ if(n%i==0)return 0; i+=p[j]; } if(n%i==0)return 0; } return 1; } void main() { int n; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); if(prime(n))puts(&amp;quot;Yes&amp;quot;); else puts(&amp;quot;No&amp;quot;); }  仔细研究发现，这里利用的是这样的原理：
 判断是不是1, 2, 3, 5及其倍数 从7开始，不断考虑其是否是素数，那么，这个p是什么回事呢？  首先把p的各个元素加起来，和为30，然后就可以发现一个规律： 7为质数，7+2=9不是质数，7+4=11为质数，11+2=13为质数，13+2=15为合数，15+2=17为质数，17+2=19为质数，19+2=21为合数，21+2=23为质数，23+2=25为合数，25+2=27为合数，27+2=29为质数，29+1=31为质数，31+2=33为合数，33+2=35为合数，35+2=37为质数。 观察以上所有的合数，都含有2或者3或者5的因子，而30又是2,3,5的公倍数，也就是说，后面的素数模30的余数不可能是上面这些合数，而剩下的素数才可能是真正的素数，于是跳过了很多素数的判断。
至于这个函数的性能如何，还需要进一步测试来进行判断。</description>
    </item>
    
    <item>
      <title>关于scanf和scanf_s的问题</title>
      <link>https://jiege.ch/programming/2017/10/17/on-scanf-and-scanf_s/</link>
      <pubDate>Tue, 17 Oct 2017 16:46:40 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2017/10/17/on-scanf-and-scanf_s/</guid>
      <description>最近作为程设基础的小教员，收到很多同学的求助，关于scanf和scanf_s的问题已经遇到了两次，特此写一篇博文来叙述一下这个问题。
一开始，有同学问我，
char a; scanf(&amp;quot;%c&amp;quot;,&amp;amp;a);  为什么会报错？我说，vs默认强制要求使用scanf_s函数，于是我建议这位同学把这个错误信息关掉了。嗯。经过百度，这位同学的问题解决了。
后来，又有一位同学问我，
char a; scanf_s(&amp;quot;%c&amp;quot;,&amp;amp;a);  程序为什么会崩溃？我想了想，如果scanf_s和scanf是一样的行为，这段代码是没问题的。但scanf_s既然安全，必然是在字符串方面做了处理。这里的char*勉强也算一个？网上一查，果然，应该写成scanf_s(&amp;quot;%c&amp;quot;,&amp;amp;a,1);，字符串则要写成scanf_s(&amp;quot;%s&amp;quot;,str,sizeof(str))，来保证缓冲区不会溢出。
但是，这样解决这个问题又面临着不同的选择：
 学习scanf_s和scanf的不同，把所有scanf换成scanf_s并做相应的修改。 这样当然符合了语言进化的潮流，也会让vs闭嘴。但是，scanf_s只有在C11标准中有，而且，根据cpprefrence.com上关于scanf的描述，只有在__STDC_LIB_EXT1__被定义且在#include&amp;lt;stdio.h&amp;gt;之前#define __STDC_WANT_LIB_EXT1__才能确保使用scanf_s能使用，当然在vs较新版本中是默认可以使用的。但是，程设基础的作业是要丢到oj上的，而oj上的编译器不一定支持这些，所以这个选项不行。 坚持用scanf，自己按照题目要求保证缓冲区不溢出，同时让vs闭嘴。 网上已有教程，已经讲的很全面了，大家可以根据这个教程把vs教训一顿。为了能在oj里跑，建议用里面的方法五到八。（个人最推荐在文件头添加#define _CRT_SECURE_NO_WARNINGS）  以后再遇到这个问题，我就丢这个连接上来就好了咯。yeah！</description>
    </item>
    
    <item>
      <title>一个搞笑的伸展树的Wiki</title>
      <link>https://jiege.ch/others/2017/10/16/a-funny-wiki-of-splay-tree/</link>
      <pubDate>Mon, 16 Oct 2017 19:59:30 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2017/10/16/a-funny-wiki-of-splay-tree/</guid>
      <description>光哲同学在群里发了这个链接，特别搞笑，特此分享： 伸展树 - 百度百科
 伸展树（Spaly Tree，事实上在国内 IO 界常常被称作 Tajarn 发明的 Spaly Tree，与此同理的还有 Terap），也叫分裂树，是一种二叉排序树，它能在 O(n log n) 内完成插入、查找和删除操作。它由 Daniel Sleator 和 Robert Tajarn 发现，后者对其进行了改造。它的优势可以不断伸展枝干（一个月 2~3 次），从而使树冠散开，提高光合作用效率。木材坚硬，是重要的经济类乔木。与其他植物不同的是，伸展树可以进行出芽生殖，繁殖速度极快。
 </description>
    </item>
    
    <item>
      <title>回顾昨天的酒井知识竞赛</title>
      <link>https://jiege.ch/others/2017/10/16/review-on-yesterdays-jiujing-adi-contest/</link>
      <pubDate>Mon, 16 Oct 2017 10:36:28 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2017/10/16/review-on-yesterdays-jiujing-adi-contest/</guid>
      <description>昨天晚上，我作为蒟蒻组的一员在三教2102参加了酒井知识竞赛，并因此鸽掉了TUNA和Lab mU的迎新会hhh，不过运气好拿到了二等奖的好成绩，获得Paperang便携打印机一台。中间遇到了好一些网络方面的知识，这对于没有记忆OSI模型的我无疑有巨大的难度。下面是几道比较有印象的题目：
 以下哪个不是编程语言？ A. J B. L C. R D. K 这题不难，R肯定对，J见过，K略微有印象，选B
 IPv6链路层地址解析的协议是？ A. ARP B. Neighbour Solicitation C. Neighbour Advertisement D. Neighbour Discovery 对于一个没研究过IPv6的人来说这只好蒙了。。。ARP是IPv4时代的，ND(Neighbour Discovery则是IPv6时代的新产物，把ARP和ICMP等协议的功能都包含了进来，并且有新的功能。之前样题里还出现过问IPv6中去掉了Unicast,Anycast,Multicast,Broadcast中的哪种，答案是Broadcast。 第一个把程序错误称做bug的是？ 选项太多忘了，答案是Grace Hopper，因为当时一只飞蛾意外飞入了机器导致了故障，后来慢慢就流传下来了。 以下不是网络操作系统的是？ A. Windows NT B. OS/2 warp C. DOS D. Netware 当时我没见过D，于是就选了。。。然后就挂了，Netware是Novell开发的系统，OS/2 warp当然是历史悠久的系统啦，而DOS=Disk Operating System所以没有“网络”二字。。。晕倒 以下是用作局域网的协议是？ A. TCP/IP B. IPX/SPX C. NetBEUI D. RS-232-C TCP/IP当然不仅限于局域网，RS-232-C是接口，当时蒙了B结果就对了，白白拿了50分哈哈哈。IPX/SPX是Novell设计用在Netware系统上的局域网协议，NetBEUI则是NetBIOS的一个历史遗留的一个“别称”。 姚期智的夫人给谁取了中文名？ 当然是Donald Ervin Knuth啦！高德纳万岁！  </description>
    </item>
    
    <item>
      <title>华为随行 WiFi 2 mini开箱</title>
      <link>https://jiege.ch/unboxing/2017/08/08/huawei-portable-wifi/</link>
      <pubDate>Tue, 08 Aug 2017 20:38:00 +0800</pubDate>
      
      <guid>https://jiege.ch/unboxing/2017/08/08/huawei-portable-wifi/</guid>
      <description>前段时间，我办了4G升级，移动送了一张副卡，有不少免费的流量，由于我的手机是iPhone不支持双卡，老爸就借了我他的GlocalMe当成MiFi来用，不过呢GlocalMe放在这里当然是大材小用了，所以我就网购了华为随行WiFi 2 mini，把我的副卡装上一个壳放进去就可以了！把这个MiFi插入电脑，会弹出一个目录，里面有Win/Mac的驱动安装文件，打开后在网络设置里就有HUAWEI_MOBILE的连接了，并自动打开网络配置界面。设置一下SSID和密码，就能正常使用了，手机连上也很正常，手机上可以下载HUAWEI HiLink来配置MiFi，挺爽的。随赠的有联通的上网卡，不过我准备在北京买个上网卡放MiFi里面用。</description>
    </item>
    
    <item>
      <title>Farewell, Flash</title>
      <link>https://jiege.ch/news/2017/07/26/farewell-flash/</link>
      <pubDate>Wed, 26 Jul 2017 22:02:20 +0800</pubDate>
      
      <guid>https://jiege.ch/news/2017/07/26/farewell-flash/</guid>
      <description>It&amp;rsquo;s time to say goodbye to Flash. HN #1 HN #2</description>
    </item>
    
    <item>
      <title>In macOS Sierra, Karabiner-Elements finally support complex modifications</title>
      <link>https://jiege.ch/system/2017/06/15/macos-sierra-karabiner-finally-support-complex-modifications/</link>
      <pubDate>Thu, 15 Jun 2017 17:22:20 +0800</pubDate>
      
      <guid>https://jiege.ch/system/2017/06/15/macos-sierra-karabiner-finally-support-complex-modifications/</guid>
      <description>In favor of this commit, Karabiner-Elements now supports the much welcomed yet long-lost feature, namely complex modifications that enable users to trigger complex keypress.
Now I can achieve this:
If I press &amp;lt;Enter&amp;gt;, then: 1. If &amp;lt;Enter&amp;gt; is pressed alone, then send &amp;lt;Enter&amp;gt;. 2. If &amp;lt;Enter&amp;gt; is pressed along with other keys, then send &amp;lt;Control&amp;gt; + Other.  By adding this code to ~/.config/karabiner/karabiner.json :
&amp;quot;complex_modifications&amp;quot;: { &amp;quot;rules&amp;quot;: [ { &amp;quot;manipulators&amp;quot;: [ { &amp;quot;description&amp;quot;: &amp;quot;Change return_or_enter to left_control.</description>
    </item>
    
    <item>
      <title>等时圆</title>
      <link>https://jiege.ch/others/2016/08/02/dengshiyuan/</link>
      <pubDate>Tue, 02 Aug 2016 16:03:41 +0800</pubDate>
      
      <guid>https://jiege.ch/others/2016/08/02/dengshiyuan/</guid>
      <description>最近学校老师讲了一下等时圆。先从这个题讲起：
在同一个地方向不同倾角光滑斜面用不同的初速度上滑，到达最高点所用时间相等，求最高点的轨迹是什么？
A. 直线 B. 椭圆 C. 抛物线 D. 圆
当时做这个题目的第一想法是把x和y座标表示出来：
$$ \frac{1}{2}gsin\theta{}t^2=l, y=lsin\theta, x=ycot\theta $$
然后就傻眼了，并得不到x与y的关系式。当然了可以求出几个点，强行带入二次曲线通式求解。不过想了想还是用解析几何的方法去做吧：
$$ \frac{1}{2}gsin\theta{}t^2=\sqrt{x^2+y^2}, sin\theta=\frac{y}{\sqrt{x^2+y^2}} $$
这么一代入，显然是圆。但既然这是物理题，可不可以用物理方法做呢？
可以，这就是等时圆。
啥叫等时圆？
等时圆就是，在一个光滑圆环上选择任意一点，让一个小球从这个点沿着光滑直杆到圆的最低点，无论这个点在哪里（最低点不算哈），时间都是一样的。怎么证明？
很简单：设小球与最低点连线与数值方向上夹角为$$\theta$$，那么
$$ s=2Rcos\theta, \frac{1}{2}gcos\theta{}t^2=s $$
你会发现t与$$\theta$$无关。证明完毕。
其实也可以倒过来：从圆的最高点往各个方向下滑，到达圆周时间相等。
好了，到此为止内容都没什么，但你会想问这和前面那道题目有什么关系呢？这怎么等时圆？重力往下诶。运动可是往右上方。
Here comes the black magic :)
我们考虑向下滑到最低点的那个等时圆，在这个圆周上滑倒最低点的时间都相等。好，我们把这个图沿着竖直方向旋转180度形成一个球，想想这个球上每一个点到最低点时间是不是也一样？那么考虑逆过程，让小球从斜面上滑下来，我对刚才的球体再竖着切一刀，得到的平面不就是题目中那个吗？得证。
当然了最好能有动画说明，限于本人时间问题暂时不提供 ^_^</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2016/07/23/a-good-way-to-show-git-diff-for-compressed-files/</link>
      <pubDate>Sat, 23 Jul 2016 14:46:41 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2016/07/23/a-good-way-to-show-git-diff-for-compressed-files/</guid>
      <description>I have found a good way to track changes in .gz files: Add these to ~/.gitconfig:
[core] attributesFile = ~/.gitattributes [diff &amp;quot;zip&amp;quot;] textconv = unzip -p binary = true [diff &amp;quot;gz&amp;quot;] textconv = gzcat binary = true [diff &amp;quot;bz2&amp;quot;] textconv = bzcat binary = true [diff &amp;quot;xz&amp;quot;] textconv = xzcat binary = true [diff &amp;quot;tar&amp;quot;] textconv = tar -O -xf binary = true [diff &amp;quot;tar-bz2&amp;quot;] textconv = tar -O -xjf binary = true [diff &amp;quot;tar-gz&amp;quot;] textconv = tar -O -xzf binary = true [diff &amp;quot;tar-xz&amp;quot;] textconv = tar -O -xJf binary = true [diff &amp;quot;odf&amp;quot;] textconv = odt2txt [diff &amp;quot;pdf&amp;quot;] textconv = pdfinfo [diff &amp;quot;bin&amp;quot;] textconv = hexdump -v -C  And these to ~/.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/life/the-end-of-senior-two/</link>
      <pubDate>Thu, 07 Jul 2016 18:44:22 +0800</pubDate>
      
      <guid>https://jiege.ch/life/the-end-of-senior-two/</guid>
      <description>Finally the end of Senior 2 arrives. I&amp;rsquo;m on the way to Senior 3. The summer vacation is rather short which is really common in China. These days I have been diving into Emacs by subscribing both emacs and emacs-devel mailing list. It contributes to my English as well. I can learn a lot of new words and expression thanks to the nice and convenient feature of looking up a word in iOS.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2016/05/22/exciting-new-software-updates/</link>
      <pubDate>Sun, 22 May 2016 07:47:16 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2016/05/22/exciting-new-software-updates/</guid>
      <description>Just got a piece of great news: GHC 8.0.1 is out! See the announcement [here][http://article.gmane.org/gmane.comp.lang.haskell.ghc.devel/11928].
So excited! And Emacs 25 release will be out soon. Using Emacs 25.0.94 now. Many new features available. See [this][http://puntoblogspot.blogspot.com/2016/05/emacs-251-news.html] for more information.
Recently I have finally started to use mu4e and gnus. What makes it truly great is that they integrate org, bbdb and so on.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2016/04/09/interesting-links/</link>
      <pubDate>Sat, 09 Apr 2016 06:17:34 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2016/04/09/interesting-links/</guid>
      <description>Having a bad cold. Really annoying.
Okay, here comes the interesting links:
https://glyph.twistedmatrix.com/2015/11/editor-malware.html
http://kitchingroup.cheme.cmu.edu/blog/2016/04/07/Writing-hy-code-from-hy-code/
https://github.com/holomorph/transmission
https://github.com/bergey/org-babel-diagrams
http://ess.r-project.org/
http://projects.haskell.org/diagrams/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2016/04/03/tips-on-git-shallow-clone/</link>
      <pubDate>Sun, 03 Apr 2016 14:38:09 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2016/04/03/tips-on-git-shallow-clone/</guid>
      <description>Just learned a new tip on git shallow clone. As you know, some repository are really really large, such as emacs and linux. Cloning is slow and unstable. And there is no way to pause and resume a git clone. So I use shallow clone to clone them. But what if I want to clone other branches?
From here: http://stackoverflow.com/a/27393574/2148614
git remote set-branches origin &#39;*&#39;  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/speech/2016/03/19/listen-and-write-subtitles-cameron/</link>
      <pubDate>Sat, 19 Mar 2016 20:23:46 +0800</pubDate>
      
      <guid>https://jiege.ch/speech/2016/03/19/listen-and-write-subtitles-cameron/</guid>
      <description>Here is the subtitle:
We meet in a week that could change the United Kingdom for ever. Indeed, it could end the United Kingdom as we know it. On Thursday, Scotland votes, of the future of our country is at stake. On Friday, people could be living in a different country with a different place in the world and the different future ahead of it. This is the decision that could break up our family of nations and rips Scotland from rest of the United Kingdom.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/logo/2016/03/13/logo-is-a-lisp-dialect/</link>
      <pubDate>Sun, 13 Mar 2016 09:24:28 +0800</pubDate>
      
      <guid>https://jiege.ch/logo/2016/03/13/logo-is-a-lisp-dialect/</guid>
      <description>Most of us have learnt how to use PCLogo to draw some graphics. Logo is a dialect of Lisp in fact, so most of us used a Lisp dialect at a early time! For some people, it is earlier than C++. Cool.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jiege.ch/programming/2016/03/09/some-interesting-links/</link>
      <pubDate>Wed, 09 Mar 2016 22:10:31 +0800</pubDate>
      
      <guid>https://jiege.ch/programming/2016/03/09/some-interesting-links/</guid>
      <description>I&amp;rsquo;m here to share some interesting links. I do not have much time writing the blog now.
Recently I have been working on CodeFalling/MacGesture on Github. If you are interested in it, go and have a look.
Here are the links to share: https://twitter.com/PoolpOrg/status/694593152670437376 https://github.com/wellle/targets.vim http://thecodelesscode.com/case/225 https://twitter.com/zhangyuze320602/status/706457155763712000
I have done reading the biography of Steve Jobs. Great book.</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://jiege.ch/about/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
      
      <guid>https://jiege.ch/about/</guid>
      <description>I&amp;rsquo;m an undergraduate student in Tsinghua University in China. Interested in programming and mathematics. I can speak Mandarin, Cantonese and English. Please inform me if I have made any mistakes by commenting below, sending email to me, or make a issue on my Github repo of this blog.
Find me by my email noc@jiegec.ac.cn . My Github user name is jiegec.</description>
    </item>
    
  </channel>
</rss>