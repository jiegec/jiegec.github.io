<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jiajie Chen's blog</title>
    <description>This is the personal blog of Jiajie Chen, a NANO(uNix hAcker aNd lOver).
</description>
    <link>https://jiegec.github.io/</link>
    <atom:link href="https://jiegec.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 28 Apr 2018 22:51:17 +0800</pubDate>
    <lastBuildDate>Sat, 28 Apr 2018 22:51:17 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>使用 Cisco AC + AP 组合搭建网络实践</title>
        <description>&lt;p&gt;有一台已配置好直接可用的 AC 在地址 ac-address 。我们需要搭建交换机 + AP 的网络，并且用一台 Linux 服务器进行 DHCP 从而给 AP 分发 AC 的地址。这里以 systemd-networkd 为例。&lt;/p&gt;

&lt;p&gt;我们约定，vlan 2 上联外网， vlan 3 为 Linux 服务器和 AP 的内部网络。&lt;/p&gt;

&lt;p&gt;接下来，配置交换机给 Linux 服务器的端口为 trunk 口，然后将下联 Cisco AP 的端口都设为 access vlan 3 模式。接下来在 Linux 服务器上配置 DHCP 服务器和 NAT 。&lt;/p&gt;

&lt;p&gt;如果 Linux 服务器的 interface 名称为 eno1 :&lt;/p&gt;

&lt;p&gt;配置两个 VLAN interface:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.network
[Match]
Name=eno1

[Network]
VLAN=eno1.2
VLAN=eno1.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相应添加 VLAN 配置：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.2.network
[NetDev]
Name=eno1.2

[VLAN]
Id=2
$ cat /etc/systemd/network/eno1.3.network
[NetDev]
Name=eno1.3

[VLAN]
Id=3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置上行的 eno1.2 interface 的静态地址：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.2.network
[Match]
Name=eno1.2

[Network]
Address=123.123.123.123/24
Gateway=123.123.123.1
DNS=1.2.4.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置内部网络 eno1.3 interface:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/systemd/network/eno1.3.network
[Match]
Name=eno1.3

[Network]
Address=192.168.1.1/24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置 dhcpd (isc-dhcp-server):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /etc/dhcpd.conf
option space Cisco_LWAPP_AP;
option Cisco_LWAPP_AP.server-address code 241 = array of ip-address;

subnet 192.168.1.0 netmask 255.255.255.0 {
  range 192.168.1.100 192.168.1.200;
  option routers 192.168.1.1;
  vendor-option-space Cisco_LWAPP_AP;
  option Cisco_LWAPP_AP.server-address $ac-address;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置 iptables 做NAT:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -o eno1.2 -j MASQUERADE
iptables-save &amp;gt; /etc/iptables/iptables.rules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打开 ipv4 forwarding:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo 'net.ipv4.conf.all.forwarding=1' &amp;gt;&amp;gt; /etc/sysctl.d/99-ipv4-forwarding.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 28 Apr 2018 21:58:00 +0800</pubDate>
        <link>https://jiegec.github.io/networking/2018/04/28/wifi-with-cisco-ac-and-ap/</link>
        <guid isPermaLink="true">https://jiegec.github.io/networking/2018/04/28/wifi-with-cisco-ac-and-ap/</guid>
        
        <category>cisco</category>
        
        <category>wifi</category>
        
        <category>vlan</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>把 GDB 降级到 8.0.1</title>
        <description>&lt;p&gt;在 macOS 上使用 GDB 需要 codesigning 。但是在 GDB 升级到 8.1 后这种方法不知道为何失效了。所以我安装回了 GDB 8.0.1 并且重新 codesigning ，现在又可以正常升级了。&lt;/p&gt;

&lt;p&gt;对 Formula 进行 patch：&lt;/p&gt;

&lt;div class=&quot;language-patch highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/Formula/gdb.rb b/Formula/gdb.rb
index 29a1c590..25360893 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/Formula/gdb.rb
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/Formula/gdb.rb
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -1,14 +1,15 @@
&lt;/span&gt; class Gdb &amp;lt; Formula
   desc &quot;GNU debugger&quot;
   homepage &quot;https://www.gnu.org/software/gdb/&quot;
&lt;span class=&quot;gd&quot;&gt;-  url &quot;https://ftp.gnu.org/gnu/gdb/gdb-8.1.tar.xz&quot;
-  mirror &quot;https://ftpmirror.gnu.org/gdb/gdb-8.1.tar.xz&quot;
-  sha256 &quot;af61a0263858e69c5dce51eab26662ff3d2ad9aa68da9583e8143b5426be4b34&quot;
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  url &quot;https://ftp.gnu.org/gnu/gdb/gdb-8.0.1.tar.xz&quot;
+  mirror &quot;https://ftpmirror.gnu.org/gdb/gdb-8.0.1.tar.xz&quot;
+  sha256 &quot;3dbd5f93e36ba2815ad0efab030dcd0c7b211d7b353a40a53f4c02d7d56295e3&quot;
&lt;/span&gt; 
   bottle do
&lt;span class=&quot;gd&quot;&gt;-    sha256 &quot;43a6d6cca157ef70d13848f35c04e11d832dc0c96f5bcf53a43330f524b3ac40&quot; =&amp;gt; :high_sierra
-    sha256 &quot;fe7c6261f9164e7a744c9c512ba7e5afff0e74e373ece9b5aa19d5da6443bfc2&quot; =&amp;gt; :sierra
-    sha256 &quot;cd89001bcf8c93b5d6425ab91a400aeffe0cd5bbb0eccd8ab38c719ab5ca34ba&quot; =&amp;gt; :el_capitan
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+    sha256 &quot;e98ad847402592bd48a9b1468fefb2fac32aff1fa19c2681c3cea7fb457baaa0&quot; =&amp;gt; :high_sierra
+    sha256 &quot;0fdd20562170c520cfb16e63d902c13a01ec468cb39a85851412e7515b6241e9&quot; =&amp;gt; :sierra
+    sha256 &quot;f51136c70cff44167dfb8c76b679292d911bd134c2de3fef40777da5f1f308a0&quot; =&amp;gt; :el_capitan
+    sha256 &quot;2b32a51703f6e254572c55575f08f1e0c7bc2f4e96778cb1fa6582eddfb1d113&quot; =&amp;gt; :yosemite
&lt;/span&gt;   end
 
   deprecated_option &quot;with-brewed-python&quot; =&amp;gt; &quot;with-python@2&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 17 Apr 2018 13:08:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/04/17/downgrade-gdb/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/04/17/downgrade-gdb/</guid>
        
        <category>macOS</category>
        
        <category>gdb</category>
        
        <category>homebrew</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（8）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/04/07/thoughts-on-stanford-cs140e-7/&quot;&gt;上一篇文章&lt;/a&gt;之后，我其实还是很忙，但是一直心理惦记着这件事，毕竟只剩最后的一点点就可以做完了，不做完总是觉得心痒。&lt;/p&gt;

&lt;p&gt;今天做的部分是调度。我们目前只在 EL0 运行了一个 shell ，每当触发 exception 时回到 kernel 进行处理，再回到原来的地方。但现在，我要实现一个 preemtive round-robin scheduler ，就需要管理当前的所有进程，并且维护当前的进程状态，当时钟中断到来的时候，决定下一个 time slice 要执行的进程，再切换过去。这个过程当然会遇到不少的坑。&lt;/p&gt;

&lt;p&gt;首先，我们需要判断一个进程是否可以执行了。考虑到阻塞的 IO ，作者提供了一个优雅的方法：如果这个进程阻塞在 IO 上，那么，提供一个函数，在 scheduler 中调用，判断所需要的数据是否到达。这样，我们就可以一个循环把下一个 time slice 要执行的线程找到。如果找不到，就等待 interrupt 再尝试。&lt;/p&gt;

&lt;p&gt;困难的地方在于，在启动的时候，切换到一个起始线程。并且在上下文切换的时候，在 process 1 -&amp;gt; kernel -&amp;gt; process 2 这两步过程中，有许多寄存器都需要仔细考虑如何实现。并且在这个过程中，我也发现了之前写的代码中的问题，最终修复了（目前来看是 working 了）。&lt;/p&gt;

&lt;p&gt;我的代码实现在 &lt;a href=&quot;https://github.com/jiegec/cs140e/commit/977f179a9b28e88e85f4ba9577a0682bf2b6c57b&quot;&gt;这里&lt;/a&gt; 。下一步就要写 syscall 了。希望能在期中前抽时间赶紧把这个做完。&lt;/p&gt;

&lt;p&gt;18:54 PM Update: 刚实现完了 sleep 的 syscall 。比预想中要简单。果然找到了自己实现的调度器的 BUG 。此系列大概是完结了。&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Apr 2018 17:27:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/04/10/thoughts-on-stanford-cs140e-8/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/04/10/thoughts-on-stanford-cs140e-8/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>aarch64</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（7）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/05/thoughts-on-stanford-cs140e-6/&quot;&gt;上一篇文章&lt;/a&gt;之后，我很长时间都没有在继续我这个项目，清明节刚好闲下来了我就回来继续啃它。Stanford那边已经结课，最后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;3-spawn&lt;/code&gt; 也只有一部分，剩下的部分不知道什么时候作者才会填上去了。&lt;/p&gt;

&lt;p&gt;这次主要要写的代码就是，对异常的处理。这里的异常并不是我们编程语言中的 catch/throw ，而是硬件的异常。AArch64 和 x86 一样，也有不同的特权级别的区分，前者是 EL0~EL3 ，后者则是 RING0 和 RING3 。特权级别高可以往特权级别低转换，但是反过来，只能通过异常的方式提高特权等级，并且切换特权等级后只有固定的一些代码可能会跳转，这就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception handler/vectors&lt;/code&gt; 。这些函数可以知道是什么原因调用了他们，根据硬件规定好的文档，我们可以知道发生了什么事情，是对齐出错了呢，还是用户调用了 syscall 呢，等等。根据不同的情况，我们需要进行不同的处理。当处理完之后，我们需要考虑，跳转回用户代码的时候，回到哪里，提供什么值，不提供什么。&lt;/p&gt;

&lt;p&gt;实现的话，需要很多步骤。首先是构造好 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception vector&lt;/code&gt; ，这里作者已经写好了一个宏（这里 @BenYip 遇到了一个 assembler 的 BUG ），直接用宏就可以把它写出来。然后，我们需要把它加载到当前 EL 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;VBAR_ELx&lt;/code&gt; 寄存器中，当 CPU 抛出异常的时候，就会找到这里相应的处理器进行处理。进到这里以后，我们首先先不考虑太多上下文保存的事情–我们先保证能处理异常，恢复也是个有很多坑的步骤，作者也是在这里分成了两个 Subphase 。首先还是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;ESR_ELx&lt;/code&gt; 中解析到错误的来源的具体内容，如果是我们在 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 中自己调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 指令，我们就自己新开一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，修改了提示符以示区别。这样，我们就成功地捕捉到了这个异常。由于我们还无法恢复回去，所以我们直接死循环。&lt;/p&gt;

&lt;p&gt;接下来我们要做的是，从异常中恢复出来。由于用户代码可能在各种地方抛出异常，异常也分同步和异步两种情况，这里有许多需要考虑的问题。为了简化，我们目前只考虑同步的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 导致的 Brk 异常。为了能恢复之后能够正常运行，我们需要把所有的寄存器都保存下来，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;TrapFrame&lt;/code&gt; 。保存的时候需要讲究 AArch64 平台下 SP 寄存器的对齐问题。我们也要把一些特殊的寄存器保存下来。还有一点，就是，因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;exception handler&lt;/code&gt; 中调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;context_save&lt;/code&gt; 函数，所以此时的 lr 本身也需要进行保存，这个地方也卡了我很久。最后，再把这些一个一个地恢复到原来的样子，调整 &lt;code class=&quot;highlighter-rouge&quot;&gt;ELR_EL1&lt;/code&gt; 使得退回到原来的状态时，会跳过当前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;brk 2&lt;/code&gt; 指令，调用它的下一调指令。这样，我们就成功地在遇到异常时，弹出一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，而且还可以回退回来。&lt;/p&gt;

&lt;p&gt;学到了很多很多。之后大三，我们可能需要做自己的 CPU ，在自己的 CPU 上跑自己的操作系统，在自己的操作系统中跑自己的编译器，在自己的编译器中编译一个数据库。希望到时我还活着吧。#flag&lt;/p&gt;
</description>
        <pubDate>Sat, 07 Apr 2018 14:05:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/04/07/thoughts-on-stanford-cs140e-7/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/04/07/thoughts-on-stanford-cs140e-7/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>aarch64</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>最近比较忙</title>
        <description>&lt;p&gt;最近一直没有更新我的 CS140e 系列文章，是因为最近一直忙于各种事情。等有空了再更新吧。&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Mar 2018 15:05:00 +0800</pubDate>
        <link>https://jiegec.github.io/others/2018/03/26/busy-these-days/</link>
        <guid isPermaLink="true">https://jiegec.github.io/others/2018/03/26/busy-these-days/</guid>
        
        
        <category>others</category>
        
      </item>
    
      <item>
        <title>偶遇清华吴文虎教授</title>
        <description>&lt;p&gt;今天百团大战，正准备收摊的时候，天空工场那边来了一位长者，在和他们聊着什么。我很感兴趣，就上去听。老人大概已有八十高龄（后来查，是1936年生），但依然精神矍铄，首先和我们讲，作为工科的学生，一定在理解原理的基础上，多多去实践。他举了他自己的例子，他首先在电机系学习，后来，计算机系成立（当时还是自动控制系），他转到了计算机系，重新学起了计算机，说计算机编程学起来并没有什么难的。当年，苹果公司送过来了中国第一台 Apple-2 ，他们就把电脑拆了下来研究原理，又装上去继续工作。后来，他就在计算机系任教，教的正是《程序设计基础》这门课程。他十分重视实践，在第一年开课的时候就说，最关键的就是实践，安排了一些编程实验课，期中期末就是大作业。一开始有一些同学不重视实践，结果期末就挂科了。后来同学们就明白了实践的重要性，实践起来发现并没有那么难，最后就说，“吴老师，你说得对”。他又谈到了他的体育，他当年是北京长跑代表队的集训队选手，擅长一千五百米项目，他三千米只需要九分钟就能跑完。我们都感到自愧不如。我们说，现在的《程序设计基础》是徐明星老师在教，他说徐明星是他的博士生，邬晓钧也是他的博士生，他另外还有一个高徒我记不清楚了。他还是IOI中国队的前教练，听到我们有过一些OI基础，表示了赞许和鼓励。还有一些细节记不清楚了，记起来了再补充吧。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Mar 2018 17:47:50 +0800</pubDate>
        <link>https://jiegec.github.io/others/2018/03/08/encountering-wu-wenhu/</link>
        <guid isPermaLink="true">https://jiegec.github.io/others/2018/03/08/encountering-wu-wenhu/</guid>
        
        <category>百团大战</category>
        
        <category>吴文虎</category>
        
        
        <category>others</category>
        
      </item>
    
      <item>
        <title>〖新手向〗绕过 C++ 类的访问限制</title>
        <description>&lt;p&gt;这是一篇很水的文章，面向萌新，已经知道了的可以自觉绕道。&lt;/p&gt;

&lt;p&gt;昨天上课，有同学问，如果用户偷偷把 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; 改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; 再和原有的库链接，是不是就可以在用户代码里更改了。这个答案是肯定的。下面我们就做个实验：&lt;/p&gt;

&lt;p&gt;首先，创建 good_class.h 和 good_class.cpp:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;good_class.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，首先编译，&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang++ &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; good_class.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; good_class.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，修改 good_class.cpp 并写一个 evil_user.cpp&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;good_class.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang++ good_class.o evil_user.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; evil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;evil&lt;/code&gt; 如愿地输出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;37&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;一些提醒：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt; 的访问控制十分的弱，仅仅是编译期。所以是很容易绕过的。&lt;/li&gt;
  &lt;li&gt;对于不想泄露源代码的库，不要导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt; 的类和函数。选择导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 函数，结构体用 incomplete type 或者干脆 &lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;扩展阅读： &lt;a href=&quot;https://liam0205.me/2018/01/23/crack-private-member-function-by-vtable/&quot;&gt;L叔的通过虚函数表访问私有函数&lt;/a&gt; 。&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Mar 2018 07:59:20 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/03/07/breaking-C++-weak-access-control/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/03/07/breaking-C++-weak-access-control/</guid>
        
        <category>C++</category>
        
        <category>hack</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（6）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/03/thoughts-on-stanford-cs140e-5/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者终于更新了测试的用例，我的程序终于可以成功跑过所有测试，也成功在树莓派跑起来。不过，我的代码中很多地方的错误处理比较偷懒，往往直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; ，显然并不友好。同时，我想到了使用 &lt;a href=&quot;https://github.com/rust-fuzz/cargo-fuzz&quot;&gt;cargo-fuzz&lt;/a&gt; 来进行自动化测试，果然，使用这个很快就修复了不少我没想到的会出错的地方，比如乘法溢出，目录项没有正确结束等等。目前还发现一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 的问题，研究发现大概是文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cluster chain&lt;/code&gt; 中出现了环，导致一直读取文件而没有停止。要解决这个问题，我目前想到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Floyd&lt;/code&gt; 的判圈算法，但还没上实现。等过几天，新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 3&lt;/code&gt; 出了以后，再继续更新。希望作者少点跳票，多点勤奋，哈哈哈哈哈&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 19:55:49 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/03/05/thoughts-on-stanford-cs140e-6/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/03/05/thoughts-on-stanford-cs140e-6/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>FAT32</category>
        
        <category>fuzz test</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（5）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/27/thoughts-on-stanford-cs140e-4/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后（again），终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 3: Saddle Up&lt;/code&gt; 。这次，我们要做的变成了把已经写好的（错漏百出）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 的驱动搬到树莓派里面去，然后实现一些基本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 等等。作者首先更新了老版本的新的测试样例，放了一些映像然后提供了预期的结果，结果发现，这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 有一些不同，主要的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes_per_sector&lt;/code&gt; 不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt; 了，意味着物理的扇区和逻辑扇区并不一致。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;sectors_per_cluster&lt;/code&gt; 也不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 了，需要考虑多个扇区的情况。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;read_cluster&lt;/code&gt; 传入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;offset&lt;/code&gt; 也可能不再是第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sector&lt;/code&gt; 中的，所以需要做一个处理。对于物理和逻辑扇区的问题，作者推荐的方案是，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 之外的扇区保持不变，把其内的扇区视为逻辑扇区。这样，其它代码都可以透明地工作，而不用到处更改，这就体现了封装的威力。接着，作者提供了一个写好了的 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsd&lt;/code&gt; 和一些导出的函数，使用这些函数即可。不过，在错误处理和 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 上也遇到了一些坑。后面，把东西搬到树莓派上运行，问题就出现了：读取了第一个扇区（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 所在的扇区）之后，直接就死掉了。想了半天都没找到方案，突然想起可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic!&lt;/code&gt; 对错误语句进行二分查找。查找了大概有七八个小时之后，终于发现，问题出现在读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 类型的变量上。我起初怀疑是栈出了问题，所以放到堆上分配，然而还是不行。忽然想起以前遇到的对齐问题，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AArch64&lt;/code&gt; 架构上，可能为了简化，读取的 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 必须对齐到四个字节上。于是找了找 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中的对齐方面的文档，找到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(align=4)]&lt;/code&gt; 这种表示方法，代替了原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(packed)]&lt;/code&gt; ，并且把数据先拷贝到对齐后的栈上的对应数据结构，然后再读取对应的项。果然，这个问题就解决了。然后又发现我的盘中会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;lfn&lt;/code&gt; 项并不是从后往前的情况，于是我又修改了一下相关的代码。现在，终于可以成功地 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;不过还是要吐槽一下，作者的测试用的映像文件中，会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xE5&lt;/code&gt; 表示这个项已经被删除的情况，但是似乎作者的代码并没有处理这个，所以在预期的输出中出现了一些明显不正确的结果，导致我的代码跑测试并不能通过。而且，作者的代码在一些情况下会把文件的后缀漏掉。作者后来更新了几次测试的文件，不过这个问题只解决了一部分，并没有完全解决。坐等作者继续放出新的测试文件吧。&lt;/p&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 11:07:30 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/03/03/thoughts-on-stanford-cs140e-5/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/03/03/thoughts-on-stanford-cs140e-5/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>FAT32</category>
        
        <category>SD card</category>
        
        <category>alignment</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（4）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/16/thoughts-on-stanford-cs140e-3/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后，终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 2:32-bit Lipids&lt;/code&gt; ，这两天就把只读 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 写完了（不过封装得并不好，许多地方利用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;pub(super)&lt;/code&gt; 把变量可以访问的范围控制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;vfat&lt;/code&gt; 中，然后直接读，只有少数需要特殊处理的进行了函数的封装）。首先当然是研究了半天 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的结构，拿了不同来源的 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 结构说明进行对比和验证，最后终于把格式搞清楚了，先实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;MasterBootRecord&lt;/code&gt; ，这个其实很好实现，以前也有接触过 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; ，本身也很简单。然后就是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 找到第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的分区，根据偏移找到分区的开头，开头的第一个扇区就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 数据结构，里面保存了 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 分区的各种信息。根据里面的信息，可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表的位置和数量，还有数据部分的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 的位置和数量。接着，解析一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表，实际上是一个与 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 一一对应的链表结构，用特殊的数据代表链表的尾和空、坏扇区。利用这些，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 中根目录所在的第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; ，先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;VFat&lt;/code&gt; 里面实现了读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 链的内容的函数，利用这个函数读取一个一个的目录项，解析目录项，把长文件名的项合并到一个之中，然后对应地丢到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt; 对象中，目录则可以枚举子目录项，根据名字比较去找子目录或者子文件夹，文件则实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Read&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Seek&lt;/code&gt; 使得可以读取文件的内容。实现好了这些以后，就拿了 &lt;code class=&quot;highlighter-rouge&quot;&gt;raspbian-strech-lite.img&lt;/code&gt; 作为硬盘映像，从文件里读取文件信息，成功地把 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.txt&lt;/code&gt; 读取出来。&lt;/p&gt;

&lt;p&gt;其中还是遇到许多困难，如各种偏移的计算，如何处理跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 和跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sector&lt;/code&gt; 的读写，等等，有不少的坑在其中，花了两天的空余时间才差不多完善了这个功能。还有就是利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 现有的功能完成 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 里面很轻易就可以实现的指针操作，也花了不少时间。&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Feb 2018 22:42:59 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/02/27/thoughts-on-stanford-cs140e-4/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/02/27/thoughts-on-stanford-cs140e-4/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>FAT32</category>
        
        
        <category>programming</category>
        
      </item>
    
  </channel>
</rss>
