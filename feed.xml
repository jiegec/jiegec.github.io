<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杰哥的{运维,编程}小笔记</title>
    <description>This is the personal blog of Jiajie Chen, a NANO(uNix hAcker aNd lOver).
</description>
    <link>https://jiegec.me/</link>
    <atom:link href="https://jiegec.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 07 Sep 2018 10:34:36 +0800</pubDate>
    <lastBuildDate>Fri, 07 Sep 2018 10:34:36 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>在 macOS 上读取移动硬盘的 S.M.A.R.T. 信息</title>
        <description>&lt;p&gt;之前想看看自己各个盘的情况，但是发现只能看电脑内置的 SSD 的 S.M.A.R.T 信息，而移动硬盘的都显示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ smartctl -a /dev/disk2
smartctl 6.6 2017-11-05 r4594 [Darwin 17.7.0 x86_64] (local build)
Copyright (C) 2002-17, Bruce Allen, Christian Franke, www.smartmontools.org

/dev/disk2: Unable to detect device type
Please specify device type with the -d option.

Use smartctl -h to get a usage summary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一开始我怀疑是个别盘不支持，但换了几个盘都不能工作，问题应该出现在了 USB 上。查了下资料，果然如此。根据 &lt;a href=&quot;https://www.smartmontools.org/wiki/USB&quot;&gt;USB devices and smartmontools&lt;/a&gt; ，获取 S.M.A.R.T 信息需要直接发送 ATA 命令，但是由于经过了 USB ，于是需要进行一个转换，导致无法直接发送 ATA 命令。这个问题自然是有解决方案，大概就是直接把 ATA 命令发送过去（pass-through）。上面这个地址里写到，如果需要在 macOS 上使用，需要安装一个内核驱动。可以找到，源码在 &lt;a href=&quot;https://github.com/kasbert/OS-X-SAT-SMART-Driver&quot;&gt;kasbert/OS-X-SAT-SMART-Driver&lt;/a&gt; 并且有一个带签名的安装包在 &lt;a href=&quot;https://binaryfruit.com/drivedx/usb-drive-support&quot;&gt;External USB / FireWire drive diagnostics support&lt;/a&gt; 中可以下载。丢到 VirusTotal 上没查出问题，用 v0.8 版本安装好后就成功地读取到了移动硬盘的 S.M.A.R.T 信息了。&lt;/p&gt;

&lt;p&gt;然后我又简单研究了一下各个 S.M.A.R.T 各个值的含义是什么。 &lt;code class=&quot;highlighter-rouge&quot;&gt;VALUE&lt;/code&gt; 代表当前的值， &lt;code class=&quot;highlighter-rouge&quot;&gt;WORST&lt;/code&gt; 代表目前检测到的最差的值， &lt;code class=&quot;highlighter-rouge&quot;&gt;THRESH&lt;/code&gt; 代表损坏阈值。这些值都是从 &lt;code class=&quot;highlighter-rouge&quot;&gt;RAW_VALUE&lt;/code&gt; 进行计算后归一化而来。然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;TYPE&lt;/code&gt; 分为两种，一是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pre-fail&lt;/code&gt; ，代表如果这一项的值小于阈值，代表这个机器很危险了，赶紧拷数据丢掉吧。二是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Old_age&lt;/code&gt; ，代表如果这一项小于阈值，代表这个机器比较老了，但还没坏。真正要看是否坏了，可以看 &lt;code class=&quot;highlighter-rouge&quot;&gt;When_Failed&lt;/code&gt; 一栏。&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Sep 2018 10:20:00 +0800</pubDate>
        <link>https://jiegec.me/hardware/2018/09/07/reading-smart-info-of-external-drives-under-macOS/</link>
        <guid isPermaLink="true">https://jiegec.me/hardware/2018/09/07/reading-smart-info-of-external-drives-under-macOS/</guid>
        
        <category>smart</category>
        
        <category>macOS</category>
        
        <category>smartmontools</category>
        
        <category>kext</category>
        
        
        <category>hardware</category>
        
      </item>
    
      <item>
        <title>通过 Ipfilter Extension 实现 RFC8367</title>
        <description>&lt;p&gt;前几天无聊闲逛看到了一个很有趣的 &lt;a href=&quot;https://tools.ietf.org/html/rfc8367&quot;&gt;RFC8367 - Wrongful Termination of Internet Protocol (IP) Packets&lt;/a&gt; ，看到日期大家应该都懂了，这是个粥客，不过里面还是反映了一些事情，咳。&lt;/p&gt;

&lt;p&gt;之前看到闪客实现了 &lt;a href=&quot;https://github.com/shankerwangmiao/xt_PROTO&quot;&gt;shankerwangmiao/xt_PROTO&lt;/a&gt; ，想到自己也可以做一个 iptables 扩展，于是就写了 &lt;a href=&quot;https://github.com/jiegec/xt_EQUALIZE&quot;&gt;jiegec/xt_EQUALIZE&lt;/a&gt; 。它是这样使用的：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone git@github.com:jiegec/xt_EQUALIZE.git
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;make install
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; filter &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; INPUT &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; EQUALIZE
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;dmesg &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; &amp;amp;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# Make some random network requests to see the effect!&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping 1.1.1.1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping 8.8.8.8
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping ::1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;目前还没有把参数都变成可以配置的。如果真的有人需要这个模块的话，我再改吧（逃&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Aug 2018 15:47:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/08/31/implementing-rfc8367-as-iptables-extension/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/08/31/implementing-rfc8367-as-iptables-extension/</guid>
        
        <category>rfc</category>
        
        <category>rfc8367</category>
        
        <category>aprilfool</category>
        
        <category>iptables</category>
        
        <category>kernel</category>
        
        <category>mod</category>
        
        <category>xtables</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>在 macOS 上 TAP Interface 上启用 IPv6 自动配置</title>
        <description>&lt;p&gt;由于 macOS 对 TAP Interface 不会自动出现一个设置中对应的服务，所以需要手动进行配置。一番测试后，发现可以通过：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo ipconfig set [tap_if] automatic-v6
$ sudo ipconfig set [tap_if] dhcp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启用系统自带的 dhcp 和 ra 功能。也许有方法可以把这些 tap 搬到系统的设置中去。&lt;/p&gt;

&lt;p&gt;UPDATE:&lt;/p&gt;

&lt;p&gt;可以把 TAP Interface 加到系统的设置中去。方法参考&lt;a href=&quot;https://stackoverflow.com/a/6375307&quot;&gt;Virtual network interface in Mac OS X&lt;/a&gt;。完成以后可以直接通过系统设置界面进行配置。&lt;/p&gt;
</description>
        <pubDate>Sat, 25 Aug 2018 19:07:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/08/25/enable-ipv6-autoconfiguration-on-tap-interfaces-in-macos/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/08/25/enable-ipv6-autoconfiguration-on-tap-interfaces-in-macos/</guid>
        
        <category>slacc</category>
        
        <category>ipv6</category>
        
        <category>tuntaposx</category>
        
        <category>tap</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>在 macOS 下实现 GRETAP</title>
        <description>&lt;p&gt;由于没有找到 macOS 下现成的 GRETAP 实现，我就想到自己实现一个。由于&lt;a href=&quot;http://tuntaposx.sourceforge.net/&quot;&gt;tuntaposx&lt;/a&gt;提供了一个和 Linux 下基本一样的 TAP Interface，于是自己利用 raw socket 和 TAP Interface 实现了一下，主要方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;打开 raw socket ，读取收到的 proto 47 的包，判断是否为 GRETAP 包，是，则写入内层包到打开的 TAP Interface 中。&lt;/li&gt;
  &lt;li&gt;从 TAP Interface 中读入包，自己加上 GRE 头和 IP 头，然后发送。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;主要的难度是在 raw socket 部分，macOS 继承了 BSD ，与 Linux 不大一样。于是参考了&lt;a href=&quot;https://sock-raw.org/papers/sock_raw&quot;&gt;SOCK_RAW Demystified&lt;/a&gt;，成功地实现了这个功能。&lt;/p&gt;

&lt;p&gt;代码放在&lt;a href=&quot;https://github.com/jiegec/gretapmac&quot;&gt;jiegec/gretapmac&lt;/a&gt;。写得并不高效，仅仅可用，用了一百多行。&lt;/p&gt;

&lt;p&gt;UPDATE: 之后又随手实现了一个类似的协议，L2TPv3 over UDP。代码在&lt;a href=&quot;https://github.com/jiegec/l2tpv3udptap&quot;&gt;jiegc/l2tpv3udptap&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Aug 2018 09:42:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/08/21/implementing-gretap-in-macos/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/08/21/implementing-gretap-in-macos/</guid>
        
        <category>tuntaposx</category>
        
        <category>tap</category>
        
        <category>gre</category>
        
        <category>gretap</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>在 WireGuard 构建的 Overlay Network 上跑 babel 路由协议</title>
        <description>&lt;p&gt;受 &lt;a href=&quot;https://fugoes.github.io/computer/network/2018/02/03/Run-Babeld-over-Wireguard.html&quot;&gt;Run Babeld over Wireguard - Fugoes’s Blog&lt;/a&gt; 和 &lt;a href=&quot;https://vincent.bernat.im/en/blog/2018-route-based-vpn-wireguard&quot;&gt;Route-based VPN on Linux with WireGuard&lt;/a&gt; 启发，自己也想尝试一下，在一个有多个结点的网络中，如何通过 WireGuard 构建一个 overlay network，并通过 babel 自动进行结点发现和路径选择。&lt;/p&gt;

&lt;p&gt;首先建立点对点的 WireGuard Tunnel 。由于我们用 babel 进行路由，所以我们不能采用 Wiregurad 本身基于目的地址的端口复用，所以每一个 WireGuard interface 都只有一个 Peer 。&lt;/p&gt;

&lt;p&gt;配置一个点对点的 WireGuard Tunnel：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ # for wg-quick
$ cat wg0.conf
[Interface]
Address = IPV4/32, fe80::ID/64
PrivateKey = REDACTED
ListenPort = PORT1
Table = off # ask wg-quick not to insert peer address into routing table

[Peer]
PublicKey = REDACTED
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = REDACTED:PORT2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的 IPV4 和 ID 在同一设备上的不同 WireGuard Tunnel 上相同。只是通过 wg interface 编号来区分。&lt;/p&gt;

&lt;p&gt;接着配置 babeld ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat babeld.conf

router-id ID
local-port 33123 # for babelweb2

# one line for each wg interface
interface wg0 type tunnel rtt-max 512

redistribute ip PREFIX/LEN ge LEN le 32 local allow # tunnel neighbors
redistribute proto 42 # routes installed by babeld
redistribute local deny
# consult babeld man page for more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后通过 BabelWeb2 （很难用）进行可视化，然后通过手动触发一些网络波动即可达到效果。&lt;/p&gt;
</description>
        <pubDate>Fri, 10 Aug 2018 09:17:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/08/10/use-babel-in-overlay-network-with-wireguard/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/08/10/use-babel-in-overlay-network-with-wireguard/</guid>
        
        <category>wireguard</category>
        
        <category>babel</category>
        
        <category>routing</category>
        
        <category>go</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>更改 macOS 屏幕亮度的按键</title>
        <description>&lt;p&gt;由于我打开了「Invert Fn」功能，所以需要调亮度的时候，是采用Fn+F1/F2的方法。但是，我的机械键盘则是，不按Fn时为1-9,按着Fn时为对应的F1-F9，但是就无法调整亮度和声音了。&lt;/p&gt;

&lt;p&gt;然后捣腾了一下，发现可以用ScLk和Pa/Br（名称在各个键盘上不大一样）调整亮度。不过，还没发现如何更改音量。。。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Aug 2018 09:59:00 +0800</pubDate>
        <link>https://jiegec.me/os/2018/08/05/changing-screen-brightness-key/</link>
        <guid isPermaLink="true">https://jiegec.me/os/2018/08/05/changing-screen-brightness-key/</guid>
        
        <category>keyboard</category>
        
        
        <category>os</category>
        
      </item>
    
      <item>
        <title>向 Lenovo y1s 刷入 OpenWRT 17.01.5 固件，并把 IPv6 bridge 到内网中和配置认证脚本</title>
        <description>&lt;p&gt;首先参照&lt;a href=&quot;https://wiki.openwrt.org/toh/lenovo/lenovo_y1_v1&quot;&gt;OpenWRT Wiki - Lenovo Y1 v1&lt;/a&gt;找到刷固件教程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/lede/releases/17.01.5/targets/ramips/mt7620/lede-17.01.5-ramips-mt7620-y1s-squashfs-sysupgrade.bin&quot;&gt;Lenovo y1s 的固件&lt;/a&gt;备用&lt;/li&gt;
  &lt;li&gt;断开电源，等待一段时间，插入电源同时快速按下重置按钮，如果面板双闪，则说明进入了恢复模式&lt;/li&gt;
  &lt;li&gt;电脑连接到四个 LAN 口中任意一个，配置静态地址在 192.168.1.0/24 网段&lt;/li&gt;
  &lt;li&gt;打开 192.168.1.1 可以看到刷固件的页面&lt;/li&gt;
  &lt;li&gt;上传固件，等待路由器重启&lt;/li&gt;
  &lt;li&gt;配置 IP 地址为 DHCP 模式，打开 192.168.1.1 进行配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后就是常规的密码设置，opkg 源设置为 tuna 的源，配置 ssh 和 公钥。&lt;/p&gt;

&lt;p&gt;接下来，我们为了使用学校的 SLAAC ，采用 ebtables 直接把学校的 IPv6 bridge 进来，而 IPv4 由于准入系统，需要 NAT 。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;https://tmikey.tech/tech_daily/lede/2017/08/25/bridge_ipv6_lede.html&quot;&gt;Bridge IPv6 connections to WAN&lt;/a&gt;，下载&lt;a href=&quot;https://github.com/cvmiller/v6brouter/blob/master/v6brouter_openwrt.sh&quot;&gt;v6brouter_openwrt.sh&lt;/a&gt;到某个地方，然后修改一下里面的一些参数：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# For Lenovo y1s&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;WAN_DEV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;eth0.2
&lt;span class=&quot;nv&quot;&gt;BRIDGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;br-lan
&lt;span class=&quot;c&quot;&gt;# the rest remain unchanged&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后跑起来之后，自己的电脑可以成功拿到原生的 IPv6 地址了，不需要用难用的 NAT66 技术。&lt;/p&gt;

&lt;p&gt;下一步是采用&lt;a href=&quot;https://github.com/z4yx/GoAuthing&quot;&gt;z4yx/GoAuthing&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;go get &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; github.com/z4yx/GoAuthing
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/z4yx/GoAuthing/cli
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;env &lt;span class=&quot;nv&quot;&gt;GOOS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux &lt;span class=&quot;nv&quot;&gt;GOARCH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;mipsle &lt;span class=&quot;nv&quot;&gt;GOMIPS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;softfloat go build main.go
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mipsel-linux-gnu-strip main
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;scp main root@192.168.1.1:~/GoAuthing
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh root@192.168.1.1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;opkg install ca-certificates
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./GoAuthing
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里参考了&lt;a href=&quot;https://blog.csdn.net/QQ531456898/article/details/80095707&quot;&gt;解决GO语言编译程序在openwrt(mipsle架构)上运行提示Illegal instruction问题&lt;/a&gt;，配置了 GOMIPS 环境变量。为了访问 HTTPS 网站，参考了&lt;a href=&quot;https://wiki.openwrt.org/doc/howto/wget-ssl-certs&quot;&gt;OpenWRT Wiki - SSL and Certificates in wget&lt;/a&gt;。有毒的是，这个环境变量，在 macOS 上不能正常工作，而在 Linux 机子上是没有问题的。&lt;/p&gt;

&lt;p&gt;然后就可以成功地跑起来 GoAuthing ，解决了上校园网认证的问题。&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;https://github.com/z4yx&quot;&gt;宇翔&lt;/a&gt;编写的 GoAuthing 小工具。&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Jul 2018 20:48:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/07/26/flashing-lenovo-y1s-and-bridge-ipv6/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/07/26/flashing-lenovo-y1s-and-bridge-ipv6/</guid>
        
        <category>lenovo</category>
        
        <category>newifi</category>
        
        <category>uboot</category>
        
        <category>lede</category>
        
        <category>openwrt</category>
        
        <category>go</category>
        
        <category>ebtables</category>
        
        <category>bridge</category>
        
        <category>ipv6</category>
        
        <category>goauthing</category>
        
        <category>z4yx</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>构建简易的 initramfs</title>
        <description>&lt;p&gt;一直对 Linux 的启动很感兴趣，但对 initrd 和 initramfs 等概念不大了解，于是上网找了资料，自己成功地看到了现象。&lt;/p&gt;

&lt;p&gt;参考资料：
&lt;a href=&quot;http://www.kaizou.org/2016/09/boot-minimal-linux-qemu/&quot;&gt;Build and boot a minimal Linux system with qemu&lt;/a&gt;
&lt;a href=&quot;https://wiki.gentoo.org/wiki/Custom_Initramfs&quot;&gt;Custom Initramfs&lt;/a&gt;
&lt;a href=&quot;https://dazdaztech.wordpress.com/2013/04/04/initrd-vs-initramfs/&quot;&gt;initramfs vs initrd&lt;/a&gt;
&lt;a href=&quot;https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt&quot;&gt;ramfs, rootfs and initramfs&lt;/a&gt;
&lt;a href=&quot;https://www.linux.com/learn/kernel-newbie-corner-initrd-and-initramfs-whats&quot;&gt;The Kernel Newbie Corner: “initrd” and “initramfs”– What’s Up With That?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;hello.c
&lt;span class=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;

int main&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello, world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;gcc &lt;span class=&quot;nt&quot;&gt;-static&lt;/span&gt; hello.c &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; init
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;init | cpio &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; newc | gzip &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; initrd
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;qemu-system-x86_64 &lt;span class=&quot;nt&quot;&gt;-kernel&lt;/span&gt; /boot/vmlinuz-linux &lt;span class=&quot;nt&quot;&gt;-initrd&lt;/span&gt; initrd &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-append&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'console=ttyS0'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Use C-a c q u i t &amp;lt;Enter&amp;gt; to exit&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到过一会（三四秒？），可以看到满屏的 Hello world 在输出。&lt;/p&gt;
</description>
        <pubDate>Mon, 16 Jul 2018 03:43:00 +0800</pubDate>
        <link>https://jiegec.me/os/2018/07/16/build-custom-initramfs/</link>
        <guid isPermaLink="true">https://jiegec.me/os/2018/07/16/build-custom-initramfs/</guid>
        
        <category>linux</category>
        
        <category>initrd</category>
        
        <category>initramfs</category>
        
        
        <category>os</category>
        
      </item>
    
      <item>
        <title>用 multicast 地址找到同一网段的主机</title>
        <description>&lt;p&gt;IPv4 :&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping &lt;span class=&quot;nt&quot;&gt;-t1&lt;/span&gt; 224.0.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IPv6:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping &lt;span class=&quot;nt&quot;&gt;-t1&lt;/span&gt; ff02::1%iface
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 15 Jul 2018 17:19:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/07/15/use-multicast-address-to-find-neighbours/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/07/15/use-multicast-address-to-find-neighbours/</guid>
        
        <category>icmp</category>
        
        <category>ping</category>
        
        <category>multicast</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>用 MuSSH 快速对多台机器进行软件包升级</title>
        <description>&lt;p&gt;Debian Stretch 9.5 刚刚更新，自己手上有不少 stretch 的机器，于是顺手把他们都升级了。不过，这个过程比较繁琐，于是我采用了 MuSSH 的方法，让这个效率可以提高，即自动同时 SSH 到多台机器上进行更新。&lt;/p&gt;

&lt;p&gt;首先编写 hostlist 文件，一行一个地址，分别对应每台机器。&lt;/p&gt;

&lt;p&gt;然后采用 MuSSH 对每台机器执行同样的命令&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mussh &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; hostlist &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'apt update &amp;amp;&amp;amp; apt upgrade -y'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时要求，ssh 上去以后有相应的权限。这个有许多方法，不再赘述。然后就可以看到一台台机器升级，打上安全补丁，爽啊。&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Jul 2018 01:10:00 +0800</pubDate>
        <link>https://jiegec.me/devop/2018/07/15/use-mussh-to-upgrade-multiple-machines/</link>
        <guid isPermaLink="true">https://jiegec.me/devop/2018/07/15/use-mussh-to-upgrade-multiple-machines/</guid>
        
        <category>debian</category>
        
        <category>stretch</category>
        
        <category>mussh</category>
        
        
        <category>devop</category>
        
      </item>
    
  </channel>
</rss>
