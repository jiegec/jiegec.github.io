<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杰哥的{运维,编程}小笔记</title>
    <description>This is the personal blog of Jiajie Chen, a NANO(uNix hAcker aNd lOver).
</description>
    <link>https://jiegec.me/</link>
    <atom:link href="https://jiegec.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 25 May 2018 22:14:52 +0800</pubDate>
    <lastBuildDate>Fri, 25 May 2018 22:14:52 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>在 WSL 上开启一个 getty 到串口的方法</title>
        <description>&lt;p&gt;为了测试一个硬件的 terminal ，想在 Windows 上向串口开一个 tty ，跑各种软件来测试。这件事情在 Linux 上和 macOS 上都有实践，但一直不知道 Windows 上怎么搞。经过了一番搜索，找到了 https://blogs.msdn.microsoft.com/wsl/2017/04/14/serial-support-on-the-windows-subsystem-for-linux/ 和 https://unix.stackexchange.com/a/123559 的方案。&lt;/p&gt;

&lt;p&gt;以 COM5 为例：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;chmod 666 /dev/ttyS5
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;agetty &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 115200 ttyS5 linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以看到一个登录的界面了。&lt;/p&gt;

&lt;p&gt;在 macOS 上(https://superuser.com/questions/1059744/serial-console-login-on-osx)：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;screen /dev/tty.SLAB_USBtoUART 115200
&lt;span class=&quot;c&quot;&gt;# type C-b : exec ::: /usr/libexec/getty std.115200&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 25 May 2018 21:56:00 +0800</pubDate>
        <link>https://jiegec.me/os/2018/05/25/opening-tty-terminal-in-wsl/</link>
        <guid isPermaLink="true">https://jiegec.me/os/2018/05/25/opening-tty-terminal-in-wsl/</guid>
        
        <category>windows</category>
        
        <category>wsl</category>
        
        <category>getty</category>
        
        <category>agetty</category>
        
        <category>terminal</category>
        
        <category>cu</category>
        
        
        <category>os</category>
        
      </item>
    
      <item>
        <title>体验 Fedora on RISCV</title>
        <description>&lt;p&gt;看到 RISCV 很久了，但一直没能体验。最近工具链不断更新， QEMU 在 2.12.0 也正式加入了 riscv 的模拟。但是自己编译一个内核又太麻烦，就找到了 Fedora 做的 RISCV port，下载下来试用了一下。之前试过一次，但是遇到了一些问题，刚才总算是成功地搞出来了。&lt;/p&gt;

&lt;p&gt;官方文档地址： https://fedorapeople.org/groups/risc-v/disk-images/readme.txt
首先下载 https://fedorapeople.org/groups/risc-v/disk-images/ 下的 bbl vmlinux 和 stage4-disk.img.xz 三个文件，然后解压 stage4-disk.img.xz ，大约有 5G 的样子。之前作者在脚本里作死开得特别大，导致我以前光是解压这一步就成功不了。现在终于解决了。&lt;/p&gt;

&lt;p&gt;然后启动 qemu 命令打开虚拟机：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-riscv64 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-nographic&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-machine&lt;/span&gt; virt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 2G &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-kernel&lt;/span&gt; bbl &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-object&lt;/span&gt; rng-random,filename&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/dev/urandom,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;rng0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-rng-device,rng&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;rng0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-append&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;console=ttyS0 ro root=/dev/vda&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-blk-device,drive&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-drive&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;stage4-disk.img,format&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;raw,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hd0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-device&lt;/span&gt; virtio-net-device,netdev&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;usernet &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-netdev&lt;/span&gt; user,id&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;usernet,hostfwd&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;tcp::10000-:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段命令摘自 readme.txt ，区别只在于把 -smp 4 去掉了。不知道为什么不能正常工作，可能和作者提到的 FPU patch 有关。然后系统就可以正常起来了（firewalld和systemd-logind不止为啥起不来，但是不用管）。&lt;/p&gt;

&lt;p&gt;可以验证一下我们的系统：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;uname &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;
Linux stage4.fedoraproject.org 4.15.0-00046-g48fb45691946 &lt;span class=&quot;c&quot;&gt;#27 SMP Mon May 14 08:25:14 UTC 2018 riscv64 riscv64 riscv64 GNU/Linux&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 24 May 2018 23:40:00 +0800</pubDate>
        <link>https://jiegec.me/os/2018/05/24/trying-fedora-on-riscv/</link>
        <guid isPermaLink="true">https://jiegec.me/os/2018/05/24/trying-fedora-on-riscv/</guid>
        
        <category>fedora</category>
        
        <category>riscv</category>
        
        <category>qemu</category>
        
        
        <category>os</category>
        
      </item>
    
      <item>
        <title>在 VMware ESXi 上部署 vCSA 实践</title>
        <description>&lt;p&gt;首先获取 vCSA 的 ISO 镜像，挂载到 Linux 下（如 /mnt），然后找到 /mnt/vcsa-cli-installer/templates/install 下的 embedded_vCSA_on_ESXi.json ，复制到其它目录并且修改必要的字段，第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt; 为 ESXi 的登录密码，一会在安装的过程中再输入。下面有个 deployment_option，根据你的集群大小来选择，我则是用的 small 。下面配置这台机器的 IP 地址，用内网地址即可。下面的 system_name 如果要写 fqdn ，记得要让这个域名可以解析到正确的地址，不然会安装失败，我因此重装了一次。下面的密码都可以留空，在命令行中输入即可。SSO 为 vSphere Client 登录时用的密码和域名，默认用户名为 Administrator@domain_name (默认的话，则是 Administrator@vsphere.local) 这个用户名在安装结束的时候也会提示。下面的 CEIP 我选择关闭，设置为 false 。&lt;/p&gt;

&lt;p&gt;接下来进行安装。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;/mnt/vcsa-cli-installer/lin64/vcsa-deploy install /path/to/embedded_vCSA_on_ESXi.json &lt;span class=&quot;nt&quot;&gt;--accept-eula&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一路输入密码，等待安装完毕即可。然后通过 443 端口进入 vSphere Client, 通过 5480 端口访问 vCSA 的管理页面。两个的密码可以不一样。&lt;/p&gt;

&lt;p&gt;2018-05-21 Update: 想要设置 VMKernel 的 IPv6 网关的话，ESXi 中没找到配置的地方，但是在 vSphere Client 中可以进行相关配置。&lt;/p&gt;
</description>
        <pubDate>Sun, 20 May 2018 16:44:00 +0800</pubDate>
        <link>https://jiegec.me/devops/2018/05/20/deploy-vcsa-under-esxi/</link>
        <guid isPermaLink="true">https://jiegec.me/devops/2018/05/20/deploy-vcsa-under-esxi/</guid>
        
        <category>vmware</category>
        
        <category>vcsa</category>
        
        <category>esxi</category>
        
        
        <category>devops</category>
        
      </item>
    
      <item>
        <title>在脚本中寻找 X11 的 DISPLAY 和 XAUTHORITY</title>
        <description>&lt;p&gt;之前在搞一个小工具，在里面需要访问 X11 server ，但是访问 X11 server 我们需要两个东西：DISPLAY和XAUTHORITY两个环境变量。但是，由于它们在不同的发型版和Display Manager下都有些不同，所以花了不少功夫才写了一些。&lt;/p&gt;

&lt;p&gt;为了验证我们是否可以连上 X11 server， 我们使用这一句：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;DIMENSIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;xdpyinfo | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'dimensions:'&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'{print $2;exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它尝试打开当前的 DISPLAY，并且输出它的分辨率。接下来，我对不同的一些发型版，综合网上的方法，尝试去找到正确的环境变量。&lt;/p&gt;

&lt;p&gt;对于 Debian:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;DISPLAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;w &lt;span class=&quot;nt&quot;&gt;-hs&lt;/span&gt; | awk &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /sys/class/tty/tty0/active&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'$2 == tty &amp;amp;&amp;amp; $3 != &quot;-&quot; {print $3; exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;w &lt;span class=&quot;nt&quot;&gt;-hs&lt;/span&gt; | awk &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /sys/class/tty/tty0/active&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'$2 == tty &amp;amp;&amp;amp; $3 != &quot;-&quot; {print $1; exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;XAUTHORITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~&lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;/.Xauthority
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;DISPLAY
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;XAUTHORITY
&lt;span class=&quot;nv&quot;&gt;DIMENSIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;xdpyinfo | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'dimensions:'&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'{print $2;exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于 Archlinux：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;DISPLAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;w &lt;span class=&quot;nt&quot;&gt;-hs&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'match($2, /:[0-9]+/) {print $2; exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;USER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;w &lt;span class=&quot;nt&quot;&gt;-hs&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'match($2, /:[0-9]+/) {print $1; exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;eval &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;XAUTHORITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/run/user/&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;id &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$USER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/gdm/Xauthority
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;DISPLAY
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;XAUTHORITY
&lt;span class=&quot;nv&quot;&gt;DIMENSIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;xdpyinfo | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'dimensions:'&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'{print $2;exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一种情况很粗暴的，直接找进程拿：&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;XAUTHORITY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;ps a | awk &lt;span class=&quot;s1&quot;&gt;'match($0, /Xorg/) {print $0; exit}'&lt;/span&gt; | perl &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'/Xorg.*\s-auth\s([^\s]+)\s/ &amp;amp;&amp;amp; print $1'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;PID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;ps a | awk &lt;span class=&quot;s1&quot;&gt;'match($0, /Xorg/) {print $1; exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;DISPLAY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;lsof &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PID&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'match($9, /^\/tmp\/\.X11-unix\/X[0-9]+$/) {sub(&quot;/tmp/.X11-unix/X&quot;,&quot;:&quot;,$9); print $9; exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;DISPLAY
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;XAUTHORITY
&lt;span class=&quot;nv&quot;&gt;DIMENSIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;xdpyinfo | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'dimensions:'&lt;/span&gt; | awk &lt;span class=&quot;s1&quot;&gt;'{print $2;exit}'&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;中间混用了大量的 awk perl 代码，就差 sed 了。牺牲了一点可读性，但是开发起来比较轻松。&lt;/p&gt;
</description>
        <pubDate>Fri, 11 May 2018 14:21:00 +0800</pubDate>
        <link>https://jiegec.me/programming/2018/05/11/finding-x11-display-and-xauthority/</link>
        <guid isPermaLink="true">https://jiegec.me/programming/2018/05/11/finding-x11-display-and-xauthority/</guid>
        
        <category>linux</category>
        
        <category>x11</category>
        
        <category>display</category>
        
        <category>xauthority</category>
        
        <category>awk</category>
        
        <category>perl</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>在 macOS 和 Linux 之间搭建 tinc 网络</title>
        <description>&lt;p&gt;一直听说 tinc 比较科学，所以尝试自己用 tinc 搭建一个网络。这里，macOS 这段没有固定 IP 地址，Linux 机器有固定 IP 地址 linux_ip 。假设网络名称为 example , macOS 端名为 macos 地址为 192.168.0.2, linux 端名为 linux 地址为 192.168.0.1。&lt;/p&gt;

&lt;p&gt;在 macOS 上配置：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install tinc
mkdir &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /usr/local/etc/tinc/example
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;新建 /usr/local/etc/tinc/example/tinc.conf:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name = macos
Device = utun0 # use an unused number
ConnectTo = linux
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编辑 /usr/local/etc/tinc/example/tinc-up:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
ifconfig &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt; 192.168.0.2 192.168.0.1 mtu 1500 netmask 255.255.255.255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和 /usr/local/etc/tinc/example/tinc-down:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
ifconfig &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt; down
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有 /usr/local/etc/tinc/example/subnet-up:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NAME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NODE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;0
/usr/local/opt/iproute2mac/bin/ip route add &lt;span class=&quot;nv&quot;&gt;$SUBNET&lt;/span&gt; dev &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以及 /usr/local/etc/tinc/example/subnet-down:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NAME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NODE&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;0
/usr/local/opt/iproute2mac/bin/ip route del &lt;span class=&quot;nv&quot;&gt;$SUBNET&lt;/span&gt; dev &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后将它们都设为可执行的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod +x tinc-up
chmod +x tinc-down
chmod +x subnet-down
chmod +x subnet-down
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编辑 /usr/local/etc/tinc/example/macos:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Port = 655
Subnet = 192.168.0.1/24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;tincd -n example -K&lt;/code&gt; 生成密钥。&lt;/p&gt;

&lt;p&gt;到 Linux 机器上：
编辑以下文件：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mkdir &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /etc/tinc/example/hosts
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/tinc/example/tinc.conf
Name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; linux
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/tinc/example/tinc-up
&lt;span class=&quot;nv&quot;&gt;$!&lt;/span&gt;/bin/sh
ip link &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt; up
ip addr add 192.168.0.1/24 dev &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/tinc/example/tinc-down
&lt;span class=&quot;nv&quot;&gt;$!&lt;/span&gt;/bin/sh
ip addr del 192.168.0.1/24 dev &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt;
ip link &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$INTERFACE&lt;/span&gt; down
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/tinc/example/hosts/linux
Address &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; linux_ip
Port &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 655
Subnet &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 192.168.0.1/24
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;tincd &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; example &lt;span class=&quot;nt&quot;&gt;-K&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着，把 linux 上 /etc/tinc/example/hosts/linux 拷贝到 macos 的 /usr/local/etc/tinc/example/hosts/linux ，然后把 macos 上 /usr/local/etc/tinc/example/hosts/macos 拷贝到 /etc/tinc/example/hosts/macos 。在两台机器上都 &lt;code class=&quot;highlighter-rouge&quot;&gt;tinc -n example -D -d3&lt;/code&gt; 即可看到连接的建立，通过 ping 即可验证网络建立成功。&lt;/p&gt;
</description>
        <pubDate>Wed, 09 May 2018 10:02:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/05/09/tinc-between-macos-and-linux/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/05/09/tinc-between-macos-and-linux/</guid>
        
        <category>linux</category>
        
        <category>macos</category>
        
        <category>tinc</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>使用 Nginx 转发 VMware ESXi</title>
        <description>&lt;p&gt;我们的 VMware ESXi 在一台 NAT Router 之后，但是我们希望通过域名可以直接访问 VMware ESXi 。我们首先的尝试是，把 8443 转发到它的 443 端口，比如：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socat TCP-LISTEN:8443,reuseaddr,fork TCP:esxi_addr:443
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它能工作地很好（假的，如果你把 8443 换成 9443 它就不工作了），但是，我们想要的是，直接通过 esxi.example.org 就可以访问它。于是，我们需要 Nginx 在其中做一个转发的功能。在这个过程中遇到了很多的坑，最后终于是做好了 （VMware Remote Console等功能还不行，需要继续研究）。&lt;/p&gt;

&lt;p&gt;首先讲讲为啥把 8443 换成 9443 不能工作吧 – 很简单，ESXi 的网页界面会请求 8443 端口。只是恰好我用 8443 转发到 443， 所以可以正常工作。这个很迷，但是测试的结果确实如此。VMware Remote Console 还用到了别的端口，我还在研究之中。&lt;/p&gt;

&lt;p&gt;来谈谈怎么配置这个 Nginx 转发吧。首先是 80 跳转 443:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 80;
        listen 8080;
        server_name esxi.example.org;

        return 301 https://$host$request_uri;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个很简单，接下来是转发 443 端口：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
server {
        listen 443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;

        location / {
                proxy_pass https://esxi_addr;
                proxy_ssl_verify off;
                proxy_ssl_session_reuse on;
                proxy_set_header Host $http_host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时，打开 https://esxi.example.org 就能看到登录界面了。但是仍然无法登录。从 DevTools 看错误，发现它请求了 8443 端口。于是进行转发：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 8443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;


        location / {
                if ($request_method = 'OPTIONS') {
                        add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org';
                        add_header 'Access-Control-Allow-Credentials' 'true';
                        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
                        add_header 'Access-Control-Max-Age' 1728000;
                        add_header 'Access-Control-Allow-Headers' 'VMware-CSRF-Token,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Cookie,SOAPAction';
                        add_header 'Content-Type' 'text/plain; charset=utf-8';
                        add_header 'Content-Length' 0;
                        return 204;
                }

                add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org';
                add_header 'Access-Control-Allow-Credentials' 'true';
                proxy_pass https://esxi_addr:443;
                proxy_ssl_verify off;
                proxy_ssl_session_reuse on;
                proxy_set_header Host $http_host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要麻烦的是配置 CORS 的相关策略。我也是看了 DevTools 的错误提示半天才慢慢写出来的。这样配置以后，就可以成功登录 VMware ESXi 了。&lt;/p&gt;

&lt;p&gt;20:02 更新：现在做了 WebSocket 转发，目前可以在浏览器中打开 Web Console 了。但是，在访问 https://esxi.example.org/ 的时候还是会出现一些问题，然而 https://esxi.example.org:8443/ 是好的。&lt;/p&gt;

&lt;p&gt;转发 WebSocket：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
}

server {
        listen 8443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;


        location / {

                if ($request_method = 'OPTIONS') {
                        add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org';
                        add_header 'Access-Control-Allow-Credentials' 'true';
                        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
                        add_header 'Access-Control-Max-Age' 1728000;
                        add_header 'Access-Control-Allow-Headers' 'VMware-CSRF-Token,DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Cookie,SOAPAction';
                        add_header 'Content-Type' 'text/plain; charset=utf-8';
                        add_header 'Content-Length' 0;
                        return 204;
                }

                add_header 'Access-Control-Allow-Origin' 'https://esxi.example.org' always;
                add_header 'Access-Control-Allow-Credentials' 'true' always;

                proxy_pass https://esxi_addr:443;
                proxy_ssl_verify off;
                proxy_ssl_session_reuse on;
                proxy_set_header Host $http_host;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;20:29 更新：找到了 VMware Remote Console 的端口：902，用 iptables 进行 DNAT 即可：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; wan_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 902 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; esxi_addr:902
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2018-05-09 08:07 更新：最后发现，还是直接隧道到内网访问 ESXi 最科学。或者，让 443 重定向到 8443 ：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        listen 443 ssl;
        server_name esxi.example.org;
        ssl_certificate /path/to/ssl/cert.pem;
        ssl_certificate_key /path/to/ssl/key.pem;

        return 301 https://$host:8443$request_uri;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样，前面也不用写那么多 CORS 的东西了。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 May 2018 19:26:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/05/08/nginx-proxy-vmware-esxi/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/05/08/nginx-proxy-vmware-esxi/</guid>
        
        <category>linux</category>
        
        <category>nat</category>
        
        <category>forwarding</category>
        
        <category>vmware</category>
        
        <category>esxi</category>
        
        <category>nginx</category>
        
        <category>proxy</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>搭建 FTP server behind NAT</title>
        <description>&lt;p&gt;我们出现新的需求，要把以前的 FTP 服务器迁移到 NAT 之后的一台机器上。但是，FTP 不仅用到 20 21 端口， PASV 还会用到高端口，这给端口转发带来了一些麻烦。我们一开始测试，直接在 Router 上转发 20 和 21 端口到 Server 上。但是很快发现， Filezilla 通过 PASV 获取到地址为 （内网地址，端口高8位，端口低8位），然后，Filezilla 检测出这个地址是内网地址，于是转而向 router_ip:port 发包，这自然是不会得到结果的。&lt;/p&gt;

&lt;p&gt;此时我们去网上找了找资料，找到了一个很粗暴的方法：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; external_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 20 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; internal_ip:20
iptables &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; external_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 21 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; internal_ip:21
iptables &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; external_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 1024:65535 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; internal_ip:1024-65535
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有趣地是， macOS 自带的 ftp 命令（High Sierra似乎已经删去）可以正常使用。研究发现，它用 EPSV（Extended Passive Mode） 代替 PASV ，这里并没有写内网地址，因而可以正常使用。&lt;/p&gt;

&lt;p&gt;这么做， Filezilla 可以成功访问了。但是，用其它客户端的时候，它会直连那个内网地址而不是 Router 的地址，于是还是连不上。而且，使用了 1024-65535 的所有端口，这个太浪费而且会影响我们其它的服务。&lt;/p&gt;

&lt;p&gt;我们开始研究我们 FTP 服务器(pyftpdlib)的配置。果然，找到了适用于 FTP behind NAT 的相关配置：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     - (str) masquerade_address:
        the &quot;masqueraded&quot; IP address to provide along PASV reply when
        pyftpdlib is running behind a NAT or other types of gateways.
        When configured pyftpdlib will hide its local address and
        instead use the public address of your NAT (default None).
     - (dict) masquerade_address_map:
        in case the server has multiple IP addresses which are all
        behind a NAT router, you may wish to specify individual
        masquerade_addresses for each of them. The map expects a
        dictionary containing private IP addresses as keys, and their
        corresponding public (masquerade) addresses as values.
     - (list) passive_ports:
        what ports the ftpd will use for its passive data transfers.
        Value expected is a list of integers (e.g. range(60000, 65535)).
        When configured pyftpdlib will no longer use kernel-assigned
        random ports (default None).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;于是，我们配置了 &lt;code class=&quot;highlighter-rouge&quot;&gt;masquerade_address&lt;/code&gt; 使得 FTP 服务器会在 PASV 中返回 Router 的地址，并且在 &lt;code class=&quot;highlighter-rouge&quot;&gt;passive_ports&lt;/code&gt; 中缩小了 &lt;code class=&quot;highlighter-rouge&quot;&gt;pyftpdlib&lt;/code&gt; 使用的端口范围。&lt;/p&gt;

&lt;p&gt;进行配置以后，我们在前述的 iptables 命令中相应修改了端口范围，现在工作一切正常。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 May 2018 13:34:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/05/08/ftp-behind-nat/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/05/08/ftp-behind-nat/</guid>
        
        <category>linux</category>
        
        <category>nat</category>
        
        <category>forwarding</category>
        
        <category>ftp</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>使用 iptables 和策略路由进行带源地址的 forwarding</title>
        <description>&lt;p&gt;陈老师打开他的服务器，突然发现 CPU 莫名高负载，然后发现是有一个用户被远程登录拿来挖矿了。但是这台机器在 NAT 后，所以登录的源地址全是 NAT 路由，所以不知道对方的地址是什么。我们为了能使用 fail2ban 来禁用多次尝试失败的 IP ，但又不想因为别人把 NAT 路由的地址给禁了，这样我们自己也用不了了。所以必须要让这台机器能够知道 ssh 的源地址，我们现在简单的 socat 方案不能满足这个需求。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以在外网连 NAT 路由的高端口（如2222）来访问这台机器。&lt;/li&gt;
  &lt;li&gt;在内网中，既可以直接连它的内网地址，也可以连 NAT 路由的高端口来访问这台服务器。此时，由于连 ssh 的机器就在同一个子网中，如果保留了源地址，服务器发的包会直接回来不经过 NAT 。所以我们还是保留了 socat 的方案。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现方法：&lt;/p&gt;

&lt;p&gt;在 NAT Router 上配置 DNAT ，这样发到 NAT Router 上的包就可以转发到服务器上：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; nat &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; external_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--dport&lt;/span&gt; 2222 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; DNAT &lt;span class=&quot;nt&quot;&gt;--to-destination&lt;/span&gt; internal_server_ip:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，从服务器回来的包到了 NAT Router 上后，由于路由表的配置问题，默认的路由并不能把包送达对方。所以，我们首先给包打上 mark：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; mangle &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; PREROUTING &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; internal_interface &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; tcp &lt;span class=&quot;nt&quot;&gt;--sport&lt;/span&gt; 22 &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; MARK &lt;span class=&quot;nt&quot;&gt;--set-mark&lt;/span&gt; 0x2222
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后配置策略路由：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip rule add fwmark 0x2222 table 2222
ip route add table 2222 default via gateway_address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就可以保证 ssh 的回包可以原路返回了。&lt;/p&gt;

&lt;p&gt;由于前面提到的原因，上面我们配置的 DNAT 规则只对外网过来的包有效。为了内网的访问，我们仍然采用了 socat 的方式：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socat TCP-LISTEN:2222,reuseaddr,fork TCP:internal_server_ip:22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从不同的机器测试，都可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;who&lt;/code&gt; 看到，地址确实是我们想看到的源地址。接下来配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;fail2ban &lt;/code&gt;即可。&lt;/p&gt;
</description>
        <pubDate>Sun, 06 May 2018 14:07:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/05/06/nat-forwarding-with-src-address/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/05/06/nat-forwarding-with-src-address/</guid>
        
        <category>linux</category>
        
        <category>nat</category>
        
        <category>forwarding</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>利用 UPnP 协议进行 mosh NAT 穿透的研究</title>
        <description>&lt;p&gt;由于经常要从宿舍、教室等不同的 Wi-Fi 之间切换，但是 ssh 连接又总是断，所以想用 mosh 代替 ssh 。但是 mosh 也有它的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不能滚动。这个可以在 mosh 中嵌套一层 tmux 解决。我目前写了一些自动 mosh 后打开 tmux 并且开启鼠标支持的脚本，但还是有缺陷。&lt;/li&gt;
  &lt;li&gt;在高端口 60000+ 监听 UDP ，这使得 NAT 后的服务器难以直接通过端口转发。如果直接转发到 NAT 后的机器，那么 NAT 后面如果有多台机器，这又失效了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是找了找网上的 NAT 穿透的一些文章，看到了 UPnP 的方法。大致就是，用户可以向路由器注册一个临时的转发规则，路由会自动在 iptables 上配置转发。但是，这样也会遇到一个问题：路由上的 mosh-server 不知道这个转发的存在，所以它可能会尝试监听同样的端口。解决方案下面会提到。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server &amp;lt;---&amp;gt; NAT Router &amp;lt;---&amp;gt; My Laptop
On NAT Router, port 8022 is forwarded to Server:22
1. mosh router # works
2. mosh --ssh=&quot;ssh -p 8022&quot; router # works
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先在 NAT Router 上配置 miniupnpd （以 Debian 为例）&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install miniupnpd
&lt;span class=&quot;c&quot;&gt;# you will get a dialog upon installation&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# input your wan interface and listening ip accordingly&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim /etc/default/miniupnpd
&lt;span class=&quot;c&quot;&gt;# edit START_DAEMON=0 to START_DAEMON=1&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim /etc/miniupnpd/miniupnpd.conf
&lt;span class=&quot;c&quot;&gt;# edit ext_ifname, listening_ip accordingly&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# set secure_mode=yes&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# add 'allow 60000-60023 internal_ip/prefix 60000-60023'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# before the last line 'deny 0-65535 0.0.0.0/0 0-65535'&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; miniupnpd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，复制 &lt;a href=&quot;https://github.com/jiegec/mosh-upnp-hole-puncher/blob/master/mosh-wrapper.js&quot;&gt;我修改的mosh-wrapper.js&lt;/a&gt; 到用户的 home 目录下，在 Server 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpc&lt;/code&gt; 然后通过：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mosh &lt;span class=&quot;nt&quot;&gt;--ssh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ssh -p 8022&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/mosh-wrapper.js user@router
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样， mosh 首先会通过 ssh 和 Server 协商一个 AES 的密钥和 UDP 端口（如 60001 ），之后的通信都通过 UDP 端口走加密后的流量。我的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-wrapper.js&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpc&lt;/code&gt; 向路由器请求把该 UDP 端口转发到 Server 上，这样， &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 就能通过 NAT 路由穿透到后面的 Server 上。&lt;/p&gt;

&lt;p&gt;等会！问题来了：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 默认的 IP 范围是 &lt;code class=&quot;highlighter-rouge&quot;&gt;60000-61000&lt;/code&gt; ，根据我的观察，它会从 60001 开始尝试监听本机地址，如果已经被占用，则 60002, 60003, … 但是！Router 和 Server 实际上占用了相同的端口空间，并且 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 只知道本机哪些端口被占用了，而不知道 Router 和 Server 共同占用了多少端口。&lt;/p&gt;

&lt;p&gt;我想到了一些可能的解决方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 Router 上让 miniupnpd 监听对应的端口，占住这个坑。这样，Router 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 就不会用和 Server 相同的端口&lt;/li&gt;
  &lt;li&gt;如果有多个 Server ，则会出现抢夺相同端口的情况。我目前的想法是，让 &lt;code class=&quot;highlighter-rouge&quot;&gt;upnpc&lt;/code&gt; 去询问 Router 找空闲的端口，然后再传给 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh-server&lt;/code&gt; 使用。另一种方法则是，给不同的 Server 划分不同的端口范围，比如 Router 用 60001-60005, 然后 Server1 用 60006-60010, Server2 用 60011-60015 如此下去。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后，新的问题又发现了：&lt;/p&gt;

&lt;p&gt;当我在和 Server 同一个子网的时候，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;miniupnpd&lt;/code&gt; 配置的 &lt;code class=&quot;highlighter-rouge&quot;&gt;iptables&lt;/code&gt; 规则中来源只有 WAN interface ，所以我在内网发的包是不会被转发的。当然，既然在内网了，为啥不直接用内网 IP 呢，不知道 &lt;code class=&quot;highlighter-rouge&quot;&gt;mosh&lt;/code&gt; 有没有提供设置备用 IP 的功能。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 May 2018 20:25:00 +0800</pubDate>
        <link>https://jiegec.me/networking/2018/05/05/mosh-behind-nat-with-upnp/</link>
        <guid isPermaLink="true">https://jiegec.me/networking/2018/05/05/mosh-behind-nat-with-upnp/</guid>
        
        <category>nat</category>
        
        <category>mosh</category>
        
        <category>upnp</category>
        
        <category>miniupnpd</category>
        
        
        <category>networking</category>
        
      </item>
    
      <item>
        <title>在 Archlinux 上用 winbind 配合 pam 配置 Windows AD 认证登录</title>
        <description>&lt;p&gt;作为不清真的网络管理员，为了配置一套完整的统一认证系统，陈老师采用了 Windows AD 的方法给这里配置统一认证。重装了系统，自然要把之前的统一认证再配到新装的 Archlinux 上。&lt;/p&gt;

&lt;p&gt;参考资料： &lt;a href=&quot;https://wiki.archlinux.org/index.php/Active_Directory_Integration&quot;&gt;Active Directory Integration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先安装相应的包：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pacman &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; samba
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们还没有配好 Kerberos，所以跳过。&lt;/p&gt;

&lt;p&gt;然后配置 /etc/samba/smb.conf ，以下是一个例子。可以根据文档微调。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[global]
        security = ads
        realm = YOUR-AD-HERE
        workgroup = YOUR-GROUP-HERE
        idmap uid = 10000-20000
        idmap gid = 10000-20000
        winbind enum users = yes
        winbind enum groups = yes
        template homedir = /home/%D/%U
        template shell = /bin/bash
        client use spnego = yes
        client ntlmv2 auth = yes
        encrypt passwords = yes
        winbind use default domain = yes
        restrict anonymous = 2

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，域上的用户 user 会拿到 home 目录为 /home/YOUR-DOMAIN-HERE/user ，uid 在 10000-2000范围内的用户。在一会经过配置之后，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;getent passwd&lt;/code&gt; 验证。&lt;/p&gt;

&lt;p&gt;接下来，需要把本机的 samba 登入到域的管理员，并且启动服务。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net ads join &lt;span class=&quot;nt&quot;&gt;-U&lt;/span&gt; your-user-name
systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; smb
systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; nmb
systemctl &lt;span class=&quot;nb&quot;&gt;enable&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--now&lt;/span&gt; winbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;更改 /etc/nsswitch.conf ，在 passwd, shadow 和 group 都增添 winbind ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;passwd: files mymachines systemd winbind
group: files mymachines systemd winbind
shadow: files winbind
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来，可以进一步验证配置是否正确：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wbinfo &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt;
wbinfo &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt;
getent passwd
getent group
net ads info
net ads lookup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来可以配置 PAM 了。这一部分踩到了一些坑，现在终于做得差不多了。&lt;/p&gt;

&lt;p&gt;需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果一个用户名既有本地用户也有域上的用户，选择前者&lt;/li&gt;
  &lt;li&gt;用户要修改密码的话，如果是域用户，则要求走 Windows AD 那套方法改密码；否则仅修改本地用户密码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;修改 /etc/pam.d/system-auth:&lt;/p&gt;

&lt;p&gt;第一部分： auth&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auth [success=1 default=ignore]         pam_localuser.so
auth [success=2 default=die]            pam_winbind.so krb5_auth krb5_ccache_type=FILE cached_login try_first_pass
auth [success=1 default=die]            pam_unix.so nullok_secure
auth requisite                          pam_deny.so
auth optional                           pam_permit.so
auth required                           pam_env.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先利用 pam_localuser.so 匹配用户名和 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt; ，如果有， &lt;code class=&quot;highlighter-rouge&quot;&gt;success=1&lt;/code&gt; 代表跳过下面一条规则，故会跳到 pam_unix.so 这一行。如果失败，&lt;code class=&quot;highlighter-rouge&quot;&gt;default=ignore&lt;/code&gt; 表示忽略它的结果。如果是本地用户，匹配 pam_localuser.so 成功后跳到 pam_unix.so ，如果成功了则跳到第五行， pam_permit.so 代表通过，最后由 pam_env.so 配置环境变量。如果是域用户，则由 pam_winbind.so 处理，如果成功，同样跳到第 5 条。如果本地用户和域用户都失败，就 pam_deny.so 认证失败。&lt;/p&gt;

&lt;p&gt;第二部分：account&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;account required                        pam_unix.so
account [success=1 default=ignore]      pam_localuser.so
account required                        pam_winbind.so
account optional                        pam_permit.so
account required                        pam_time.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这一部分仍有疑问。留待以后来补充。&lt;/p&gt;

&lt;p&gt;第三部分：password&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;password [success=1 default=ignore]     pam_localuser.so
password [default=die]                  pam_echo.so file=/etc/pam.d/messages/ad_reject_change_passwd.txt
password optional                       pam_echo.so file=/etc/pam.d/messages/local_user_passwd.txt
password [success=1 default=die]        pam_unix.so sha512 shadow
password requisite                      pam_deny.so
password optional                       pam_permit.so
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里实现了我们的需求：如果是本地用户，提醒用户当前要修改的是本地用户的密码；如果是域用户，则输出信息后直接拒绝。&lt;/p&gt;

&lt;p&gt;这里的 /etc/pam.d/messages/ad_reject_change_passwd.txt 内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi %u, please go to xxxxxxx to change your Active Directory password!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第四部分：session&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-int&quot;&gt;session   required                      pam_limits.so
session   required                      pam_mkhomedir.so skel=/etc/skel/ umask=0022
session   required                      pam_unix.so
session   [success=1 default=ignore]    pam_localuser.so
session   required                      pam_winbind.so
session   optional                      pam_permit.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里与 Wiki 上内容无异。&lt;/p&gt;

&lt;p&gt;然后修改 /etc/pam.d/passwd :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;password        required        pam_cracklib.so difok=2 minlen=8 dcredit=2 ocredit=2 retry=3
password        include         system-auth
#password       requisite       pam_deny.so
#password       required        pam_unix.so sha512 shadow nullok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先判断密码强度。通过后则直接用刚才更改的 system-auth 中的 password 部分规则。&lt;/p&gt;

&lt;p&gt;这样就配好了认证。自己对这套东西的理解还不够深，以后遇到了要继续钻研。&lt;/p&gt;

&lt;p&gt;扩展阅读： &lt;a href=&quot;https://innull.com/pam-configuration-how-to/&quot;&gt;PAM 配置简介 - 王邈&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 05 May 2018 15:39:00 +0800</pubDate>
        <link>https://jiegec.me/system/2018/05/05/windows-ad-linux-pam/</link>
        <guid isPermaLink="true">https://jiegec.me/system/2018/05/05/windows-ad-linux-pam/</guid>
        
        <category>windows</category>
        
        <category>ad</category>
        
        <category>pam</category>
        
        <category>winbind</category>
        
        <category>samba</category>
        
        
        <category>system</category>
        
      </item>
    
  </channel>
</rss>
