<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jiajie Chen's blog</title>
    <description>This is the personal blog of Jiajie Chen, a NANO(uNix hAcker aNd lOver).
</description>
    <link>https://jiegec.github.io/</link>
    <atom:link href="https://jiegec.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 08 Mar 2018 19:10:19 +0800</pubDate>
    <lastBuildDate>Thu, 08 Mar 2018 19:10:19 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>偶遇清华吴文虎教授</title>
        <description>&lt;p&gt;今天百团大战，正准备收摊的时候，天空工场那边来了一位长者，在和他们聊着什么。我很感兴趣，就上去听。老人大概已有八十高龄（后来查，是1936年生），但依然精神矍铄，首先和我们讲，作为工科的学生，一定在理解原理的基础上，多多去实践。他举了他自己的例子，他首先在电机系学习，后来，计算机系成立（当时还是自动控制系），他转到了计算机系，重新学起了计算机，说计算机编程学起来并没有什么难的。当年，苹果公司送过来了中国第一台 Apple-2 ，他们就把电脑拆了下来研究原理，又装上去继续工作。后来，他就在计算机系任教，教的正是《程序设计基础》这门课程。他十分重视实践，在第一年开课的时候就说，最关键的就是实践，安排了一些编程实验课，期中期末就是大作业。一开始有一些同学不重视实践，结果期末就挂科了。后来同学们就明白了实践的重要性，实践起来发现并没有那么难，最后就说，“吴老师，你说得对”。他又谈到了他的体育，他当年是北京长跑代表队的集训队选手，擅长一千五百米项目，他三千米只需要九分钟就能跑完。我们都感到自愧不如。我们说，现在的《程序设计基础》是徐明星老师在教，他说徐明星是他的博士生，邬晓钧也是他的博士生，他另外还有一个高徒我记不清楚了。他还是IOI中国队的前教练，听到我们有过一些OI基础，表示了赞许和鼓励。还有一些细节记不清楚了，记起来了再补充吧。&lt;/p&gt;

</description>
        <pubDate>Thu, 08 Mar 2018 17:47:50 +0800</pubDate>
        <link>https://jiegec.github.io/others/2018/03/08/encountering-wu-wenhu/</link>
        <guid isPermaLink="true">https://jiegec.github.io/others/2018/03/08/encountering-wu-wenhu/</guid>
        
        <category>百团大战</category>
        
        <category>吴文虎</category>
        
        
        <category>others</category>
        
      </item>
    
      <item>
        <title>〖新手向〗绕过 C++ 类的访问限制</title>
        <description>&lt;p&gt;这是一篇很水的文章，面向萌新，已经知道了的可以自觉绕道。&lt;/p&gt;

&lt;p&gt;昨天上课，有同学问，如果用户偷偷把 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; 改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; 再和原有的库链接，是不是就可以在用户代码里更改了。这个答案是肯定的。下面我们就做个实验：&lt;/p&gt;

&lt;p&gt;首先，创建 good_class.h 和 good_class.cpp:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;good_class.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，首先编译，&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang++ &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; good_class.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; good_class.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，修改 good_class.cpp 并写一个 evil_user.cpp&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;good_class.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang++ good_class.o evil_user.cpp &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; evil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;evil&lt;/code&gt; 如愿地输出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;37&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;一些提醒：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt; 的访问控制十分的弱，仅仅是编译期。所以是很容易绕过的。&lt;/li&gt;
  &lt;li&gt;对于不想泄露源代码的库，不要导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt; 的类和函数。选择导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 函数，结构体用 incomplete type 或者干脆 &lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;扩展阅读： &lt;a href=&quot;https://liam0205.me/2018/01/23/crack-private-member-function-by-vtable/&quot;&gt;L叔的通过虚函数表访问私有函数&lt;/a&gt; 。&lt;/p&gt;
</description>
        <pubDate>Wed, 07 Mar 2018 07:59:20 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/03/07/breaking-C++-weak-access-control/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/03/07/breaking-C++-weak-access-control/</guid>
        
        <category>C++</category>
        
        <category>hack</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（6）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/03/03/thoughts-on-stanford-cs140e-5/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者终于更新了测试的用例，我的程序终于可以成功跑过所有测试，也成功在树莓派跑起来。不过，我的代码中很多地方的错误处理比较偷懒，往往直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; ，显然并不友好。同时，我想到了使用 &lt;a href=&quot;https://github.com/rust-fuzz/cargo-fuzz&quot;&gt;cargo-fuzz&lt;/a&gt; 来进行自动化测试，果然，使用这个很快就修复了不少我没想到的会出错的地方，比如乘法溢出，目录项没有正确结束等等。目前还发现一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 的问题，研究发现大概是文件的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cluster chain&lt;/code&gt; 中出现了环，导致一直读取文件而没有停止。要解决这个问题，我目前想到的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Floyd&lt;/code&gt; 的判圈算法，但还没上实现。等过几天，新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 3&lt;/code&gt; 出了以后，再继续更新。希望作者少点跳票，多点勤奋，哈哈哈哈哈&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Mar 2018 19:55:49 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/03/05/thoughts-on-stanford-cs140e-6/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/03/05/thoughts-on-stanford-cs140e-6/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>FAT32</category>
        
        <category>fuzz test</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（5）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/27/thoughts-on-stanford-cs140e-4/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后（again），终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 3: Saddle Up&lt;/code&gt; 。这次，我们要做的变成了把已经写好的（错漏百出）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 的驱动搬到树莓派里面去，然后实现一些基本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 命令： &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 等等。作者首先更新了老版本的新的测试样例，放了一些映像然后提供了预期的结果，结果发现，这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 有一些不同，主要的就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;bytes_per_sector&lt;/code&gt; 不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt; 了，意味着物理的扇区和逻辑扇区并不一致。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;sectors_per_cluster&lt;/code&gt; 也不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 了，需要考虑多个扇区的情况。同时， &lt;code class=&quot;highlighter-rouge&quot;&gt;read_cluster&lt;/code&gt; 传入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;offset&lt;/code&gt; 也可能不再是第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;sector&lt;/code&gt; 中的，所以需要做一个处理。对于物理和逻辑扇区的问题，作者推荐的方案是，把 &lt;code class=&quot;highlighter-rouge&quot;&gt;fat32&lt;/code&gt; 之外的扇区保持不变，把其内的扇区视为逻辑扇区。这样，其它代码都可以透明地工作，而不用到处更改，这就体现了封装的威力。接着，作者提供了一个写好了的 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsd&lt;/code&gt; 和一些导出的函数，使用这些函数即可。不过，在错误处理和 &lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 上也遇到了一些坑。后面，把东西搬到树莓派上运行，问题就出现了：读取了第一个扇区（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 所在的扇区）之后，直接就死掉了。想了半天都没找到方案，突然想起可以利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic!&lt;/code&gt; 对错误语句进行二分查找。查找了大概有七八个小时之后，终于发现，问题出现在读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 类型的变量上。我起初怀疑是栈出了问题，所以放到堆上分配，然而还是不行。忽然想起以前遇到的对齐问题，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;AArch64&lt;/code&gt; 架构上，可能为了简化，读取的 &lt;code class=&quot;highlighter-rouge&quot;&gt;u32&lt;/code&gt; 必须对齐到四个字节上。于是找了找 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 中的对齐方面的文档，找到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(align=4)]&lt;/code&gt; 这种表示方法，代替了原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;#[repr(packed)]&lt;/code&gt; ，并且把数据先拷贝到对齐后的栈上的对应数据结构，然后再读取对应的项。果然，这个问题就解决了。然后又发现我的盘中会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;lfn&lt;/code&gt; 项并不是从后往前的情况，于是我又修改了一下相关的代码。现在，终于可以成功地 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;不过还是要吐槽一下，作者的测试用的映像文件中，会出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;0xE5&lt;/code&gt; 表示这个项已经被删除的情况，但是似乎作者的代码并没有处理这个，所以在预期的输出中出现了一些明显不正确的结果，导致我的代码跑测试并不能通过。而且，作者的代码在一些情况下会把文件的后缀漏掉。作者后来更新了几次测试的文件，不过这个问题只解决了一部分，并没有完全解决。坐等作者继续放出新的测试文件吧。&lt;/p&gt;
</description>
        <pubDate>Sat, 03 Mar 2018 11:07:30 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/03/03/thoughts-on-stanford-cs140e-5/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/03/03/thoughts-on-stanford-cs140e-5/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>FAT32</category>
        
        <category>SD card</category>
        
        <category>alignment</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（4）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/16/thoughts-on-stanford-cs140e-3/&quot;&gt;上一篇文章&lt;/a&gt;之后，作者多次延期跳票之后，终于放出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2 Phase 2:32-bit Lipids&lt;/code&gt; ，这两天就把只读 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 写完了（不过封装得并不好，许多地方利用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;pub(super)&lt;/code&gt; 把变量可以访问的范围控制到 &lt;code class=&quot;highlighter-rouge&quot;&gt;vfat&lt;/code&gt; 中，然后直接读，只有少数需要特殊处理的进行了函数的封装）。首先当然是研究了半天 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的结构，拿了不同来源的 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 结构说明进行对比和验证，最后终于把格式搞清楚了，先实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;MasterBootRecord&lt;/code&gt; ，这个其实很好实现，以前也有接触过 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; ，本身也很简单。然后就是根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt; 找到第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的分区，根据偏移找到分区的开头，开头的第一个扇区就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 数据结构，里面保存了 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 分区的各种信息。根据里面的信息，可以找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表的位置和数量，还有数据部分的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 的位置和数量。接着，解析一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT&lt;/code&gt; 表，实际上是一个与 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 一一对应的链表结构，用特殊的数据代表链表的尾和空、坏扇区。利用这些，和 &lt;code class=&quot;highlighter-rouge&quot;&gt;EBPB&lt;/code&gt; 中根目录所在的第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; ，先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;VFat&lt;/code&gt; 里面实现了读取一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 链的内容的函数，利用这个函数读取一个一个的目录项，解析目录项，把长文件名的项合并到一个之中，然后对应地丢到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt; 对象中，目录则可以枚举子目录项，根据名字比较去找子目录或者子文件夹，文件则实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Read&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Seek&lt;/code&gt; 使得可以读取文件的内容。实现好了这些以后，就拿了 &lt;code class=&quot;highlighter-rouge&quot;&gt;raspbian-strech-lite.img&lt;/code&gt; 作为硬盘映像，从文件里读取文件信息，成功地把 &lt;code class=&quot;highlighter-rouge&quot;&gt;config.txt&lt;/code&gt; 读取出来。&lt;/p&gt;

&lt;p&gt;其中还是遇到许多困难，如各种偏移的计算，如何处理跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt; 和跨 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sector&lt;/code&gt; 的读写，等等，有不少的坑在其中，花了两天的空余时间才差不多完善了这个功能。还有就是利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rust&lt;/code&gt; 现有的功能完成 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 里面很轻易就可以实现的指针操作，也花了不少时间。&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Feb 2018 22:42:59 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/02/27/thoughts-on-stanford-cs140e-4/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/02/27/thoughts-on-stanford-cs140e-4/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>RPi3</category>
        
        <category>FAT32</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（3）</title>
        <description>&lt;p&gt;由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Assignment 2: File System &lt;/code&gt; 延期发布，所以中间那段时间转向 &lt;code class=&quot;highlighter-rouge&quot;&gt;MIT 6.828&lt;/code&gt; 稍微研究了一下。前几天放出了新的任务，在&lt;a href=&quot;/programming/2018/02/06/thoughts-on-stanford-cs140e-2/&quot;&gt;上一篇文章&lt;/a&gt;之后，我又有了一些进展： 实现了从内存中读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;ATAGS(ARM Tags)&lt;/code&gt; 信息的代码，从而可以获得内存大小的信息，根据这个信息，实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;bump&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 两种内存分配器，并且把二者之一注册为全局内存分配器，利用上更新了的 &lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; 就可以使用需要动态分配内存的相关工具了。利用这个，我实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 输入历史的回溯，把输入历史保存在一个动态增长的数组中，再特殊处理上下键，把当前的行替换为历史。&lt;/p&gt;

&lt;p&gt;这个过程也不是没有踩坑。一开始代码放出来了，但是题目说明还没出，我就自己按照代码做了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ATAGS&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bump&lt;/code&gt; 分配器，后来做完了，看到说明出了以后，发现理解还是有偏差，把代码更改了并修复了分配器的 BUG 。看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 分配器的时候，我按照网上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;buddy memory allocation&lt;/code&gt; 实现了一个内存分配器，原理看起来简单实现起来还是有很多细节问题，后来按照新放出的单元测试，修修补补才写得差不多可用了。同时，原来的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 因为用了新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;std&lt;/code&gt; 而缺失了 &lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt; 不能编译，我就把 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 下的相关文件软连接过去，调了数次后把问题解决。此时， &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 文件大小已经有 40K ，按照 115200 Baudrate 发送需要几秒才能传输过去，我就调到了 230400 Baudrate ，果然现在的传输速度就有所提升，可以接受了。等之后写了 &lt;code class=&quot;highlighter-rouge&quot;&gt;EMMC(SD card)&lt;/code&gt; 的驱动和 &lt;code class=&quot;highlighter-rouge&quot;&gt;FAT32&lt;/code&gt; 的文件系统后，就可以实现更多的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 的功能了。中间还遇到一个问题，就是如果给 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 开启了 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 分配器，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt; 回到 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 就无法传新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 上去了，结果发现是因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin&lt;/code&gt; 中用到的侵入式 &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt; 实现覆盖了部分 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 的代码，换回不能回收内存的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bump&lt;/code&gt; 分配器即可，反正目前远远还用不了那么多内存。&lt;/p&gt;

&lt;p&gt;之后还要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;aarch64&lt;/code&gt; 上用 &lt;code class=&quot;highlighter-rouge&quot;&gt;MMU&lt;/code&gt; 实现虚拟内存，之前在 &lt;code class=&quot;highlighter-rouge&quot;&gt;MIT 6.828&lt;/code&gt; 里被页表整得脑子眩晕，希望到时我还活着吧（逃&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Feb 2018 20:09:00 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/02/16/thoughts-on-stanford-cs140e-3/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/02/16/thoughts-on-stanford-cs140e-3/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>kernel</category>
        
        <category>hardware</category>
        
        <category>RPi3</category>
        
        <category>shell</category>
        
        <category>bootloader</category>
        
        <category>MIT 6.828</category>
        
        <category>ATAGS</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（2）</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/programming/2018/02/04/thoughts-on-stanford-cs140e/&quot;&gt;上一篇文章&lt;/a&gt;之后，我又有了一些进展：&lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，简易的&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，修复了之前写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmodem&lt;/code&gt; 中的 BUG，一个可以从 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 接收一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 写入到内存中再跳转过去的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;首先是 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，就是通过两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO pin&lt;/code&gt; 进行数据传输，首先在 &lt;code class=&quot;highlighter-rouge&quot;&gt;memory mapped IO&lt;/code&gt; 上进行相应的初始化，然后包装了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Read&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io::Write&lt;/code&gt; （这里实现一开始有 BUG，后来修复了），然后很快地完成了一个仅仅能 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;然后实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONSOLE&lt;/code&gt; ，一个对 &lt;code class=&quot;highlighter-rouge&quot;&gt;MiniUart&lt;/code&gt; 和单例封装，就可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;kprint!/kprintln!&lt;/code&gt; 宏来输出到 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，接着实现了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; ，读入一行输出一行。然后实现退格键和方向键，这里的难点在于要控制光标并且用读入的或者空格覆盖掉屏幕上已经显示而不应该显示的内容。接着，利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;skeleton&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Command&lt;/code&gt; 做了一个简单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;接着，利用之前编写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;tty&lt;/code&gt; ，配合上新编写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; ，实现通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 把新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;XMODEM&lt;/code&gt; 协议发送到设备，写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;0x80000&lt;/code&gt; 启动地址并且调转到新加载的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; 中执行。&lt;/p&gt;

&lt;p&gt;最后，又实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;uptime&lt;/code&gt; （输出设备启动到现在的时间）和 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt; （跳转回 &lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt; ，可以上传新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt; ）。并添加了 &lt;code class=&quot;highlighter-rouge&quot;&gt;TUNA&lt;/code&gt; 作为 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 启动时输出的 &lt;code class=&quot;highlighter-rouge&quot;&gt;BANNER&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;整个过程挺虐的，踩了很多的坑，由于很多东西都没有，输入输出目前也只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; ，写了 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 后又遇到 &lt;code class=&quot;highlighter-rouge&quot;&gt;XMODEM&lt;/code&gt; 难以调试的问题。十分感谢 &lt;code class=&quot;highlighter-rouge&quot;&gt;#tuna&lt;/code&gt; 上的 @BenYip 及时地指出了代码的几处问题，节省了我许多时间。&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Feb 2018 12:52:59 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/02/06/thoughts-on-stanford-cs140e-2/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/02/06/thoughts-on-stanford-cs140e-2/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>kernel</category>
        
        <category>GPIO</category>
        
        <category>hardware</category>
        
        <category>RPi3</category>
        
        <category>shell</category>
        
        <category>bootloader</category>
        
        <category>XMODEM</category>
        
        <category>UART</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考</title>
        <description>&lt;p&gt;最近，受各路安利，剁手买下了 &lt;a href=&quot;https://item.taobao.com/item.htm?id=537501616420&quot;&gt;这个淘宝商家的树莓派的套餐C&lt;/a&gt; ，还买了许多 LED 灯泡、杜邦线和电阻，开始按照 &lt;a href=&quot;http://web.stanford.edu/class/cs140e/&quot;&gt;CS 140e&lt;/a&gt; 学习 Rust 并且用 Rust 编译写一个简易的操作系统。Assignment 0 的目标就是编写一个向 GPIO 16 连接的 LED 灯闪烁。首先当然就是愉快地按照教程下载 bootloader ，下载交叉编译工具链，顺带装一个 Raspbian 到机器上，随时可以当成一个低性能的 ARM/ARM64 （实际上，Raspbian 只用了armv7l，没有用 64bit）机器来用，以后如果配上 &lt;a href=&quot;https://scateu.me&quot;&gt;@scateu&lt;/a&gt; 团购的 Motorola Laptop Dock 的话就是一个几百块的笔记本了。把课程上的文件丢上去，可以看到绿色的活动指示灯闪烁，后面又把 CP2102 模块连上去，又能看到 Blink on, Blink off 的输出。然后按照要求，自己先码一段 C 语言，实现 blinky:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define GPIO_BASE (0x3F000000 + 0x200000)
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spin_sleep_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;us&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nop&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;spin_sleep_us&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// STEP 1: Set GPIO Pin 16 as output.
&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// STEP 2: Continuously set and clear GPIO 16.
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中大部分代码都已经给出了，自己要实现也只是查询一下 BCM2837 SoC 的 GPIO 文档，按照文档把该做的内存操作和位运算都写一下即可。最后发现，闪烁的频率特别慢，几秒钟才闪烁一次。毕竟是按照 CPU 的 clock speed 进行粗略的计时，而生成的代码也不是很高效，没有 inline。接着则是用 Rust 再实现一下上面这部分的代码：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compiler_builtins_lib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang_items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pointer_methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no_builtins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no_std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compiler_builtins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lang_items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x3F000000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x200000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x04&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x1C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_BASE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[inline(never)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;usize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;asm!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;nop&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;::::&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;volatile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kmain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// STEP 1: Set GPIO Pin 16 as output.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;GPIO_FSEL1&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write_volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// STEP 2: Continuously set and clear GPIO 16.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_SET0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write_volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GPIO_CLR0&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.write_volatile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这边和上面一样，很多东西都已经给出了，只是重新改写一下而已。不过，这边的实测结果则是，一秒钟会闪烁很多下，看了下汇编，生成的循环比较紧凑，所以也没有达到想要的效果，不过后面到我实现了 Timer 的读取之后，就很精准了。&lt;/p&gt;

&lt;p&gt;接下来就是痛苦的学习 Rust 的过程，Assignment 1 上来就是解答关于 Rust 语言的一些问题，在过程中被 Rust 十分严格的 Lifetime 和 Borrow checker 弄得想死，好歹最后还是让测试都通过了。接下来就是真正地提供一些封装硬件接口的 API，然后利用这些 API 去实现更多功能，首先是利用栈上分配的空间模拟一个变长数组的 API：&lt;code class=&quot;highlighter-rouge&quot;&gt;stack-vec&lt;/code&gt; ，然后是把底层的直接操作硬件的内存操作封装成类型安全的 &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt; ，然后实现一个简单的支持断点续传的传文件的协议 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmodem&lt;/code&gt; ，又做了一个辅助电脑上使用 TTY+XMODEM 的小工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;ttywrite&lt;/code&gt; ，然后就开始撸硬件了：时钟 &lt;code class=&quot;highlighter-rouge&quot;&gt;timer&lt;/code&gt; ，针对 GPIO pin 的类型安全的状态机 &lt;code class=&quot;highlighter-rouge&quot;&gt;GPIO&lt;/code&gt; 。目前只实现到这里，然后做出了一个准确一秒闪烁的 blinky （令人惊讶的是，因为这里的 kernel 直接从文件头开始就是代码，最后的 binary 异常地小，而之前的代码从文件的偏移 0x8000 开始。目前看来，是因为之前的代码是整个文件加载到 0x0000 上，而代码默认了从  0x8000 开始，所以除了最开头的一个跳转指令，中间留了许多空余的空间。而这里的代码是直接被 bootloader 加载到了 0x80000 处并且跳转到这里执行，所以省去了许多空间）：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;blinky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Gpio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin_out16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin16&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.into_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pin_out16&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pin_out16&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;spin_sleep_ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[no_mangle]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;kmain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// FIXME: Start the shell.&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;blinky&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;目前只做到这里。后面还有大把的坑要踩，难写的 Rust 还得继续啃下去。我的代码都以 diff 的形式放在了 &lt;a href=&quot;https://github.com/jiegec/cs140e&quot;&gt;jiegec/cs140e&lt;/a&gt; ，写得并不美观。接下来就是实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; 了，终于要实现串口通信了。&lt;/p&gt;

&lt;p&gt;2018-01-06 更新： &lt;a href=&quot;/programming/2018/02/06/thoughts-on-stanford-cs140e-2/&quot;&gt;下一篇文章已经更新&lt;/a&gt; 。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Feb 2018 22:28:23 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/02/04/thoughts-on-stanford-cs140e/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/02/04/thoughts-on-stanford-cs140e/</guid>
        
        <category>Rust</category>
        
        <category>OS</category>
        
        <category>Stanford</category>
        
        <category>CS140e</category>
        
        <category>kernel</category>
        
        <category>GPIO</category>
        
        <category>hardware</category>
        
        <category>RPi3</category>
        
        <category>XMODEM</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>再次吐槽 VS 关于 scanf 和 scanf_s 的问题</title>
        <description>&lt;p&gt;继&lt;a href=&quot;https://jiegec.github.io/programming/2017/10/17/on-scanf-and-scanf_s/&quot;&gt;上次的吐槽&lt;/a&gt;后，今天再次遇到同学因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt; 在 VS 下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;deprecation error&lt;/code&gt; 感到十分迷茫，在知乎上求助又因为拍照的原因被说，我就在此再次吐槽一下 VS 这对初学者很不友善很不友善的两点。&lt;/p&gt;

&lt;p&gt;一点就是上面提到的这个，另一点就是程序结束后任意键以退出这一功能要做得更加醒目一点 。前者由于大多数新手在学习 &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt; 的时候都会跟着书上或者网上的代码敲一遍输入输出的代码，很容易就会撞到这个问题。后者则会让新手习惯性地以为程序闪退了，没有出结果，而不知道其实是程序执行结束后关闭而已。&lt;/p&gt;
</description>
        <pubDate>Tue, 30 Jan 2018 16:05:33 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/01/30/more-on-scanf-and-scanf_s/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/01/30/more-on-scanf-and-scanf_s/</guid>
        
        <category>VS</category>
        
        <category>C</category>
        
        <category>CS</category>
        
        <category>C++</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>我正在使用的两个 Emacs 的 Patch</title>
        <description>&lt;p&gt;我在本地对 &lt;code class=&quot;highlighter-rouge&quot;&gt;emacs.rb&lt;/code&gt; 进行了修改：&lt;/p&gt;

&lt;div class=&quot;language-patch highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/Formula/emacs.rb b/Formula/emacs.rb
index d0138cd..de3c5ff 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/Formula/emacs.rb
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/Formula/emacs.rb
&lt;/span&gt;&lt;span class=&quot;gu&quot;&gt;@@ -4,6 +4,14 @@ class Emacs &amp;lt; Formula
&lt;/span&gt;   url &quot;https://ftp.gnu.org/gnu/emacs/emacs-25.3.tar.xz&quot;
   sha256 &quot;253ac5e7075e594549b83fd9ec116a9dc37294d415e2f21f8ee109829307c00b&quot;

&lt;span class=&quot;gi&quot;&gt;+  patch do
+    url &quot;https://gist.githubusercontent.com/aatxe/260261daf70865fbf1749095de9172c5/raw/214b50c62450be1cbee9f11cecba846dd66c7d06/patch-multicolor-font.diff&quot;
+  end
+
+  patch do
+    url &quot;https://debbugs.gnu.org/cgi/bugreport.cgi?filename=0001-Fix-child-frame-placement-issues-bug-29953.patch;bug=29953;att=1;msg=8&quot;
+  end
+
&lt;/span&gt;   bottle do
     sha256 &quot;d5ce62eb55d64830264873a363a99f3de58c35c0bd1602cb7fd0bc37137b0c9d&quot; =&amp;gt; :high_sierra
     sha256 &quot;4d7ff7f96c9812a9f58cd45796aef789a1b5d26c58e3e68ecf520fab34af524d&quot; =&amp;gt; :sierra

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要涉及到两个 Patch ：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启用对 Multicolor font ，比如 Emoji 的支持。由于一些 ethic problems 暂时在 Emacs 中被禁用了，所以自己启用回来。&lt;/li&gt;
  &lt;li&gt;打上我前几天上报的 &lt;a href=&quot;https://debbugs.gnu.org/cgi/bugreport.cgi?bug=29953&quot;&gt;BUG #29953&lt;/a&gt; 的修复。已经在上游 Merge 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;emacs-26&lt;/code&gt; 分支中，这个修复会在下一个版本中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了第一个，就可以正常显示 Emoji （对不起，RMS）；有了第二个，就解决了 &lt;code class=&quot;highlighter-rouge&quot;&gt;pyim&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;lsp-ui-peek&lt;/code&gt; 用 &lt;code class=&quot;highlighter-rouge&quot;&gt;child-frame&lt;/code&gt; 显示的一些问题了。&lt;/p&gt;

&lt;p&gt;另外还有一个我自己在用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;recoll.rb&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&quot;language-rb highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Documentation: https://docs.brew.sh/Formula-Cookbook.html&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#                http://www.rubydoc.info/github/Homebrew/brew/master/Formula&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# PLEASE REMOVE ALL GENERATED COMMENTS BEFORE SUBMITTING YOUR PULL REQUEST!&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Recoll&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Formula&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Recoll is a desktop full-text search tool.&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;homepage&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://www.lesbonscomptes.com/recoll/&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://www.lesbonscomptes.com/recoll/recoll-1.23.5.tar.gz&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sha256&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;9b6b6941efc3e87c8325e95a69a5d0a37c022c3c45773c71dccd0fb3f364475f&quot;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;depends_on&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;xapian&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;depends_on&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;qt&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;depends_on&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;aspell&quot;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;install&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;inreplace&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Makefile.in&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;s2&quot;&gt;&quot;-Wl,--no-undefined -Wl,--warn-unresolved-symbols&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;--no-undefined --warn-unresolved-symbols&quot;&lt;/span&gt;

    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;./configure&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;--disable-dependency-tracking&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--disable-silent-rules&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--without-x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--disable-x11mon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--with-aspell&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--enable-recollq&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--disable-webkit&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# requires qtwebkit, which is not bundled with qt5&lt;/span&gt;
                          &lt;span class=&quot;s2&quot;&gt;&quot;--prefix=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;make&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;install&quot;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libexec&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;recoll.app&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;libexec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;recoll.app&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# `test do` will create, run in and delete a temporary directory.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# This test will fail and we won't accept that! For Homebrew/homebrew-core&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# this will need to be a test that verifies the functionality of the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# software. Run the test with `brew test recoll`. Options passed&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# to `brew install` such as `--HEAD` also need to be provided to `brew test`.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# The installed folder is not in the path, so use the entire path to any&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# executables being tested: `system &quot;#{bin}/program&quot;, &quot;do&quot;, &quot;something&quot;`.&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;false&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 07 Jan 2018 14:24:24 +0800</pubDate>
        <link>https://jiegec.github.io/programming/2018/01/07/two-patches-of-Emacs-I-am-using/</link>
        <guid isPermaLink="true">https://jiegec.github.io/programming/2018/01/07/two-patches-of-Emacs-I-am-using/</guid>
        
        <category>emacs</category>
        
        <category>patch</category>
        
        <category>multicolor font</category>
        
        <category>Emoji</category>
        
        <category>frame</category>
        
        <category>child frame</category>
        
        
        <category>programming</category>
        
      </item>
    
  </channel>
</rss>
