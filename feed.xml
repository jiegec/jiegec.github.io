<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>杰哥的{运维,编程}小笔记</title>
    <description>本人的博客
</description>
    <link>https://jiege.ch/</link>
    <atom:link href="https://jiege.ch/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 Mar 2019 17:18:18 +0800</pubDate>
    <lastBuildDate>Mon, 04 Mar 2019 17:18:18 +0800</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>实现网络的 syscall</title>
        <description>&lt;p&gt;有了网卡驱动，接下来要做的就做网络的 syscall 了。为了测试，首先在 busybox 里找可以用来测试的 applet ，由于没有实现 poll ，所以 nc telnet 啥的都用不了。最后选择到了 ping 和 pscan 上。&lt;/p&gt;

&lt;p&gt;ping大家都很了解，pscan就是一个扫端口的，对一个ip连续的若干个端口发起 tcp 请求。这就要求我提供 raw socket和tcp socket状态的支持。由于网络栈本身是异步的，但 read connect 这些函数在不调 setsockopt 的前提下又是同步的，然而现在又没有 signal 可以用，要是 block 了就再也出不来了。于是就采用了 Condvar 的办法，拿一个全局的条件变量，当 poll 不到内容的时候，先把线程拿掉，等到网络栈更新了，再恢复。这样至少不会把 cpu 也 block 住。&lt;/p&gt;

&lt;p&gt;然后就是把 socket 部分改了又改吧，数据结构的设计改了几次，为了解决 ownership 问题上锁啊也有点多，但是也更细了，虽然实际上可能没有必要，因为上面还有大的锁。不过性能还不是现在考虑的重点，关键还要先把 send recv accept bind listen 啥的写得差不多了，然后还有把 poll/select 实现了，这个很关键。&lt;/p&gt;

&lt;p&gt;中间遇到的最大的坑就是，接收 pci interrupt 的时候总是啥也没有，然后靠万能的 qemu trace 发现，原来是 mask 掉了，所以啥也收不了，然后最后的解决方案就是用 MSI Interrupt #55 搞定了这个问题。至于为啥是 55 呢，因为 23 + 32 = 55 啊（误&lt;/p&gt;

&lt;p&gt;总之是修好了。终于可以继续写其它的 syscall 了。还没想好 poll 要怎么写，orz。&lt;/p&gt;
</description>
        <pubDate>Mon, 04 Mar 2019 16:40:00 +0800</pubDate>
        <link>https://jiege.ch/programming/2019/03/04/implement-network-syscalls/</link>
        <guid isPermaLink="true">https://jiege.ch/programming/2019/03/04/implement-network-syscalls/</guid>
        
        <category>rcore</category>
        
        <category>rust</category>
        
        <category>os</category>
        
        <category>e1000</category>
        
        <category>syscall</category>
        
        <category>msi</category>
        
        <category>pci</category>
        
        <category>interrupt</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>每周分享第 13 期</title>
        <description>&lt;p&gt;今天还是早点发吧&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Rust concurrent work-stealing queue 可能可以放到调度器里用 https://github.com/kinghajj/deque&lt;/li&gt;
  &lt;li&gt;支持信用卡/时间等格式信息的输入控件 https://github.com/nosir/cleave.js&lt;/li&gt;
  &lt;li&gt;Rust 的简单 http server https://github.com/svenstaro/miniserve&lt;/li&gt;
  &lt;li&gt;Coroutines &amp;amp; Modules Added For C++20 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Coroutines-Modules-CPP20&lt;/li&gt;
  &lt;li&gt;Implementing TCP in Rust (part 1) https://www.youtube.com/watch?v=bzja9fQWzdA&lt;/li&gt;
  &lt;li&gt;一个类似 Vuetify 的框架 https://buefy.org/&lt;/li&gt;
  &lt;li&gt;systemd tmpfiles.d 用于管理特定的临时文件夹 https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html&lt;/li&gt;
  &lt;li&gt;获取 ASN 信息的 API https://bgpview.docs.apiary.io/#reference/0/asn-prefixes/view-asn-prefixes&lt;/li&gt;
  &lt;li&gt;Rust getter/setter generation https://github.com/Hoverbear/getset&lt;/li&gt;
  &lt;li&gt;Golang 1.12 发布：TLS 1.3 http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=Golang-1.12-Released&lt;/li&gt;
  &lt;li&gt;一个笑话 https://redd.it/aux77g&lt;/li&gt;
  &lt;li&gt;Rust 的 STM https://github.com/mtak-/swym&lt;/li&gt;
  &lt;li&gt;自动同步视频和字幕 https://github.com/smacke/subsync&lt;/li&gt;
  &lt;li&gt;用于快速开发的 http server https://zeroserver.io/&lt;/li&gt;
  &lt;li&gt;一个自动加载的 http server https://github.com/tapio/live-server&lt;/li&gt;
  &lt;li&gt;用 markdown 写 presentation 在线版 https://github.com/gnab/remark&lt;/li&gt;
  &lt;li&gt;解决 excel 读取 nodejs 生成的 csv 的乱码问题 https://github.com/f2e-journey/xueqianban/issues/34&lt;/li&gt;
  &lt;li&gt;清华的 Rust OS https://github.com/oscourse-tsinghua/rcore_plus&lt;/li&gt;
  &lt;li&gt;GPU 加速的 JS http://gpu.rocks/&lt;/li&gt;
  &lt;li&gt;小型的 k8s 实现： k3s https://k3s.io/&lt;/li&gt;
  &lt;li&gt;粗暴的隧道，极低的带宽，有啥用 https://0day.work/performance-of-iodine-over-dns-over-https/&lt;/li&gt;
  &lt;li&gt;Caddy 乘着 Go 官方支持的车轻松加入 TLS1.3 家族 https://github.com/mholt/caddy/pull/2399/files&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 01 Mar 2019 08:39:00 +0800</pubDate>
        <link>https://jiege.ch/misc/2019/03/01/weekly-sharing-13/</link>
        <guid isPermaLink="true">https://jiege.ch/misc/2019/03/01/weekly-sharing-13/</guid>
        
        <category>weeklysharing</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>使用 Rust 实现 e1000 驱动</title>
        <description>&lt;p&gt;是的。我又来了。上次做了&lt;a href=&quot;/programming/2019/01/29/virtio-drivers-implementation/&quot;&gt;使用 Rust 实现 VirtIO 驱动&lt;/a&gt;之后，继续往 rCore 加更多的驱动支持。由于现在工作重点是 x86_64 下的 syscall 实现，所以选了一个比较有代表性的驱动 e1000 来实现。其实如果只是为了在 qemu 下运行的话，其实只需要支持 virtio-pci 就可以了，原来的 virtio-net 直接拿来用就可以了。&lt;/p&gt;

&lt;p&gt;为什么挑 e1000 呢，一方面是支持的设备多，有真实硬件可以测试，虽然不一定要裸机上跑，但是可以通过 PCI passthrough 来测试驱动的正确性。另一方面是网上的资料比较多，有现成的简单的代码可以借鉴。这次主要借鉴了三个来源：一是 Biscuit OS， 二是 Judge Duck OS ，三是 Linux 。&lt;/p&gt;

&lt;p&gt;首先是实现了简单的 PCI 总线的枚举，然后找到对应的设备，激活，并且找到映射的内存地址，然后把原来 C 语言的实现搬运到 Rust 中。这个过程中遇到很多坑，例如一开始我以为内核里 pa 和 va 是一个固定的偏移，不过多次尝试后才发现这个假设只对 riscv 平台里的实现成立。&lt;/p&gt;

&lt;p&gt;这个时候就可以收到外面给进来的以太网帧了。接着就是把它接入到 smoltcp 的 API 中。但是发包又不工作了，尝试了很多次，各种方法也不行。其中特别要提到的就是 qemu 的 tracing API ，它在帮助我调试之前的 virtio 驱动和这次的 e1000(e) 驱动中起到了很大的帮助。不过，遗憾的是，发包相关的代码里的 trace 不足以让我找到问题的所在，我只好采用了最后一招：&lt;/p&gt;

&lt;p&gt;下载 QEMU ，自己改，然后自己编译。&lt;/p&gt;

&lt;p&gt;这个方法果然很有效啊，经过简单的几个修改，很快就定位到问题所在了，原来就是一个简单的错误，把 4 写成了 8 。这个过程中我也发现 QEMU 在 incremental build 的时候似乎会 segfault ，我没管这么多，反正编译也不慢，次数也不多，每次 clean 再 build 问题也不大。&lt;/p&gt;

&lt;p&gt;接下来要摸索 82559 的网卡适用情况如何，因为有一个真实的 82559 网卡可供测试。另一方面就要开始考虑 socket 那一套 syscall 怎么做了。&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Feb 2019 20:30:00 +0800</pubDate>
        <link>https://jiege.ch/programming/2019/02/26/network-driver-again/</link>
        <guid isPermaLink="true">https://jiege.ch/programming/2019/02/26/network-driver-again/</guid>
        
        <category>rcore</category>
        
        <category>rust</category>
        
        <category>os</category>
        
        <category>e1000</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>每周分享第 12 期</title>
        <description>&lt;p&gt;看脑王迟到了（&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Rust Embedded Graphics 库 https://github.com/jamwaffles/embedded-graphics&lt;/li&gt;
  &lt;li&gt;Wireguard for macOS https://lists.zx2c4.com/pipermail/wireguard/2019-February/003853.html&lt;/li&gt;
  &lt;li&gt;Wireguard-go UI https://github.com/aequitas/macos-menubar-wireguard&lt;/li&gt;
  &lt;li&gt;T2 逆向 https://duo.com/labs/research/apple-t2-xpc&lt;/li&gt;
  &lt;li&gt;脑王剪辑 https://www.bilibili.com/video/av43972717&lt;/li&gt;
  &lt;li&gt;dram 推荐的工具 notion.so&lt;/li&gt;
  &lt;li&gt;带授权和审计的 sudo https://github.com/square/sudo_pair&lt;/li&gt;
  &lt;li&gt;rust 的 manpage 生成器 https://github.com/rust-cli/man&lt;/li&gt;
  &lt;li&gt;才发现 Github 有 Project 功能 https://help.github.com/en/articles/about-project-boards&lt;/li&gt;
  &lt;li&gt;rust 的 elf/macho 生成 https://github.com/m4b/faerie&lt;/li&gt;
  &lt;li&gt;rust 的 elf/macho/pe 读取 https://github.com/m4b/goblin&lt;/li&gt;
  &lt;li&gt;rust 的 glob 实现 https://github.com/rust-lang-nursery/glob&lt;/li&gt;
  &lt;li&gt;基于 BoringSSL 的 rust 加密库 https://mundane.googlesource.com/mundane&lt;/li&gt;
  &lt;li&gt;从 linux 交叉编译到 macOS 的方法 https://github.com/tpoechtrager/osxcross&lt;/li&gt;
  &lt;li&gt;cargo-deb 后又有了 cargo-rpm https://github.com/RustRPM/cargo-rpm&lt;/li&gt;
  &lt;li&gt;自带 diff 的 assert_eq 宏 https://github.com/colin-kiegel/rust-pretty-assertions&lt;/li&gt;
  &lt;li&gt;Learn Helper 4.0 哈利版发布 https://chrome.google.com/webstore/detail/learn-helper/mdehapphdlihjjgkhmoiknmnhcjpjall&lt;/li&gt;
  &lt;li&gt;检查依赖中存在的 unsafe https://github.com/anderejd/cargo-geiger&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 23 Feb 2019 07:24:00 +0800</pubDate>
        <link>https://jiege.ch/misc/2019/02/23/weekly-sharing-12/</link>
        <guid isPermaLink="true">https://jiege.ch/misc/2019/02/23/weekly-sharing-12/</guid>
        
        <category>weeklysharing</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>预告 Learn-Project 4.0 版</title>
        <description>&lt;p&gt;不知道大家听没听说过 Google Chrome 有个插件，叫做 Learn Project ，是一个网络学堂的改良前端。不过，随着网络学堂的不断更（xia）新（gao），它已经不再适用于现在的版本。于是，哈利橙（@Harry_Chen）决定利用寒假时间，在今天（2.17）之前完成 Learn Project 4.0 的开发。为什么叫 4.0 呢，因为哈利橙课程的 GPA 众数是 4.0 。这个版本采用先进的 React 框架编写（Vue 塞高），使用了 Material Ui 作为界面框架（这我觉得可以），目前的一个参考图（图源哈利橙）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/learn_project.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看那满眼的高分数，希望 Learn Project 4.0 能在 flag 倒下之前完成。&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Feb 2019 13:04:00 +0800</pubDate>
        <link>https://jiege.ch/misc/2019/02/17/learn-project-preview/</link>
        <guid isPermaLink="true">https://jiege.ch/misc/2019/02/17/learn-project-preview/</guid>
        
        <category>learnproject</category>
        
        <category>preview</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>每周分享第 11 期</title>
        <description>&lt;p&gt;对不起迟到了（&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Google 的 fuzzing 家族又来了个新成员 太喜欢造轮子了 https://github.com/google/clusterfuzz&lt;/li&gt;
  &lt;li&gt;有趣的文本生成工具 https://github.com/TheBerkin/rant&lt;/li&gt;
  &lt;li&gt;又一个 side channel attack https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2019/february/downgrade-attack-on-tls-1.3-and-vulnerabilities-in-major-tls-libraries/&lt;/li&gt;
  &lt;li&gt;来自 Prof Fan 的一个 cf dns 权限限制分发的工具 https://github.com/ProfFan/cloudflare-proxy-rs&lt;/li&gt;
  &lt;li&gt;部署到了我的博客的小工具 大家体会到了吗 https://instant.page/&lt;/li&gt;
  &lt;li&gt;教育性质的 C on web https://vasyop.github.io/miniC-hosting/&lt;/li&gt;
  &lt;li&gt;激活清华教育版 win10? –&amp;gt; dig +short TXT win10.harrychen.xyz&lt;/li&gt;
  &lt;li&gt;windows95 v2.0 发布（误 https://github.com/felixrieseberg/windows95/releases/tag/v2.0.0&lt;/li&gt;
  &lt;li&gt;已经部署到 tuna 的 rustup-mirror crate https://github.com/jiegec/rustup-mirror&lt;/li&gt;
  &lt;li&gt;Forth 也能有 http 服务端框架 http://www.1-9-9-1.com/&lt;/li&gt;
  &lt;li&gt;bartender 的开源替代 实测可用 https://github.com/Mortennn/Dozer&lt;/li&gt;
  &lt;li&gt;给不支持 pac 的客户端在 http proxy 上套一层 https://github.com/williambailey/pacproxy&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 16 Feb 2019 00:42:00 +0800</pubDate>
        <link>https://jiege.ch/misc/2019/02/16/weekly-sharing-11/</link>
        <guid isPermaLink="true">https://jiege.ch/misc/2019/02/16/weekly-sharing-11/</guid>
        
        <category>weeklysharing</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>近来做 Stanford CS140e 的一些进展和思考（9）</title>
        <description>&lt;p&gt;距离&lt;a href=&quot;/programming/2018/04/10/thoughts-on-stanford-cs140e-8/&quot;&gt;上一篇 CS140e 系列文章&lt;/a&gt;已经过去了很久，距离第一篇文章过了一年零几天。在后来这一段时间内，CS140e 结束了课程，又开始了新一年的 winter 2019 课程，迎来的却是 C 版本的 CS140e ，不禁让人感到失望。还好，Sergio Benitez 放出了原来的 CS140e 的&lt;a href=&quot;https://cs140e.sergio.bz&quot;&gt;镜像&lt;/a&gt;，如果大家仍然想回去查看原版优质的 CS140e ，可以点进去参考。&lt;/p&gt;

&lt;p&gt;后来因为机缘巧合参与到了清华的 Rust OS 课程，又想到回来把原来的 CS140e 进行更新，于是顺带把跑在 QEMU 下的一些需要的工作给做了，另外把 Rust nightly 版本更新了（一年前的 nightly 还能叫 nightly ？），才发现标准库变化还是蛮大的，由于 nightly 版本变了，而且原来是内嵌了一个阉割过的 std ，所以主要是从新的 std 里抄代码到内嵌的 std 中。另外，原来的 xargo 也不再维护了，转而使用 rust-xbuild 进行交叉编译。&lt;/p&gt;

&lt;p&gt;然后又顺手实现了 backtrace 和从 backtrace 中配合 dward symbols 找函数名的功能，不过实践证明，这些东西还是 addr2line 做得更好，所以也就没有做下去，在 relocation 上也是遇到了各种问题。这个经验也是应用到了 rCore 那边。&lt;/p&gt;

&lt;p&gt;再之后也就是寒假写驱动了，见之前的一个博文，我就没有在 CS140e 上去实现它了。有时间有兴趣的时候再考虑做一下 Raspberry Pi 的网卡驱动吧。&lt;/p&gt;

&lt;p&gt;写于迪拜雨天。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Feb 2019 15:35:00 +0800</pubDate>
        <link>https://jiege.ch/programming/2019/02/12/thoughts-on-stanford-cs140e-9/</link>
        <guid isPermaLink="true">https://jiege.ch/programming/2019/02/12/thoughts-on-stanford-cs140e-9/</guid>
        
        <category>rust</category>
        
        <category>os</category>
        
        <category>stanford</category>
        
        <category>cs140e</category>
        
        <category>kernel</category>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>每周分享第 10 期</title>
        <description>&lt;p&gt;新年快乐！&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Haskell to WASM compiler https://github.com/tweag/asterius&lt;/li&gt;
  &lt;li&gt;A ssh tarpit that sends endless banner https://github.com/skeeto/endlessh&lt;/li&gt;
  &lt;li&gt;Use rust to write UEFI app https://github.com/rust-osdev/uefi-rs&lt;/li&gt;
  &lt;li&gt;神奇的小游戏 https://yeahpython.github.io/game/game.html&lt;/li&gt;
  &lt;li&gt;又一个后端 rust web 框架 https://github.com/seanmonstar/warp&lt;/li&gt;
  &lt;li&gt;挺酷的一个网站 https://github.com/pomber/github-history&lt;/li&gt;
  &lt;li&gt;ws 调试工具 https://github.com/vi/websocat&lt;/li&gt;
  &lt;li&gt;React Hooks 进入正式版 https://reactjs.org/blog/2019/02/06/react-v16.8.0.html&lt;/li&gt;
  &lt;li&gt;又一个关于硬件的 wiki https://wikidevi.com/wiki/Main_Page&lt;/li&gt;
  &lt;li&gt;virtio-fs 项目 旨在替代 virtio-9p https://virtio-fs.gitlab.io/&lt;/li&gt;
  &lt;li&gt;SergioBenitez 镜像了一份去年的 CS140e https://cs140e.sergio.bz/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 08 Feb 2019 15:52:00 +0800</pubDate>
        <link>https://jiege.ch/misc/2019/02/08/weekly-sharing-10/</link>
        <guid isPermaLink="true">https://jiege.ch/misc/2019/02/08/weekly-sharing-10/</guid>
        
        <category>weeklysharing</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>每周分享第 9 期</title>
        <description>&lt;ol&gt;
  &lt;li&gt;IDA Loader plugin for some Nintendo rom https://github.com/w4kfu/IDA_loader&lt;/li&gt;
  &lt;li&gt;websocket daemon http://websocketd.com/&lt;/li&gt;
  &lt;li&gt;实时的游戏开发器 https://script-8.github.io/&lt;/li&gt;
  &lt;li&gt;硬核逆向 Leica 相机的固件 https://alexhude.github.io/2019/01/24/hacking-leica-m240.html&lt;/li&gt;
  &lt;li&gt;做 CTF 时遇到的整数溢出的 CVE https://www.anquanke.com/post/id/104182&lt;/li&gt;
  &lt;li&gt;发现一个 speedtest 的轮子 https://github.com/adolfintel/speedtest&lt;/li&gt;
  &lt;li&gt;西数的 RISCV 核实现 https://github.com/westerndigitalcorporation/swerv_eh1&lt;/li&gt;
  &lt;li&gt;iOS 12.2 会有更多的 PWA 兹瓷 https://twitter.com/mhartington/status/1089292031548145666&lt;/li&gt;
  &lt;li&gt;代替死去的 git-up: git config –global alias.up ‘pull –rebase –autostash’&lt;/li&gt;
  &lt;li&gt;利用已知明文破解旧版加密 zip 的工具 https://github.com/kimci86/bkcrack&lt;/li&gt;
  &lt;li&gt;在线看 jwt 内容 https://jwt.io/&lt;/li&gt;
  &lt;li&gt;JS 的 Lua VM  https://github.com/fengari-lua/fengari&lt;/li&gt;
  &lt;li&gt;鲁棒但不优雅的前端 KV https://github.com/gruns/ImmortalDB&lt;/li&gt;
  &lt;li&gt;Emacs Modules doc https://phst.eu/emacs-modules&lt;/li&gt;
  &lt;li&gt;用 IPv6 的 Flow Label 实现类似 MPLS 的效果 https://github.com/wenxin-wang/flowlabel-switching&lt;/li&gt;
  &lt;li&gt;又一个 JS 实现的表格 https://github.com/myliang/x-spreadsheet 类似以前用过的 handsontable&lt;/li&gt;
  &lt;li&gt;@shankerwangmiao 推荐的光纤教程 http://www.kepu.net.cn/gb/technology/telecom/fiber/fbr215.html&lt;/li&gt;
  &lt;li&gt;用 Rust 写 iOS App https://medium.com/visly/rust-on-ios-39f799b3c1dd&lt;/li&gt;
  &lt;li&gt;Build Once, Run Anywhere 还行 https://wasmer.io/&lt;/li&gt;
  &lt;li&gt;挺科学的 DNS proxy https://github.com/AdguardTeam/dnsproxy&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 01 Feb 2019 19:16:00 +0800</pubDate>
        <link>https://jiege.ch/misc/2019/02/01/weekly-sharing-9/</link>
        <guid isPermaLink="true">https://jiege.ch/misc/2019/02/01/weekly-sharing-9/</guid>
        
        <category>weeklysharing</category>
        
        
        <category>misc</category>
        
      </item>
    
      <item>
        <title>使用 Rust 实现 VirtIO 驱动</title>
        <description>&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;最近在给 rCore 添加驱动层的支持。一开始是想做网卡驱动，后来发现， &lt;code class=&quot;highlighter-rouge&quot;&gt;qemu-system-riscv32&lt;/code&gt; 只支持如下的驱动：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# qemu-system-riscv32 -device help&lt;/span&gt;

Storage devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-cd&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI CD-ROM&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-disk&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI disk or CD-ROM (legacy)&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;scsi-hd&quot;&lt;/span&gt;, bus SCSI, desc &lt;span class=&quot;s2&quot;&gt;&quot;virtual SCSI disk&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-blk-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-scsi-device&quot;&lt;/span&gt;, bus virtio-bus

Network devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-net-device&quot;&lt;/span&gt;, bus virtio-bus

Input devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtconsole&quot;&lt;/span&gt;, bus virtio-serial-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-keyboard-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-mouse-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-serial-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-tablet-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtserialport&quot;&lt;/span&gt;, bus virtio-serial-bus

Display devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-gpu-device&quot;&lt;/span&gt;, bus virtio-bus

Misc devices:
name &lt;span class=&quot;s2&quot;&gt;&quot;loader&quot;&lt;/span&gt;, desc &lt;span class=&quot;s2&quot;&gt;&quot;Generic Loader&quot;&lt;/span&gt;
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-balloon-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-crypto-device&quot;&lt;/span&gt;, bus virtio-bus
name &lt;span class=&quot;s2&quot;&gt;&quot;virtio-rng-device&quot;&lt;/span&gt;, bus virtio-bus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以要实现网卡的话，只能实现这里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net-device&lt;/code&gt; ，而 VirtIO 驱动之间有很多共通的地方，于是顺带把 &lt;code class=&quot;highlighter-rouge&quot;&gt;gpu&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mouse&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;blk&lt;/code&gt; 实现了。&lt;/p&gt;

&lt;h1 id=&quot;第一个驱动-virtio-net-的实现&quot;&gt;第一个驱动 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net&lt;/code&gt; 的实现&lt;/h1&gt;

&lt;p&gt;首先想到并且实现了的是网卡驱动， &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio-net&lt;/code&gt; 。最开始的时候，为了简单，只开了一块缓冲区，每次同时只收/发一个包。首先拿了 &lt;a href=&quot;https://github.com/jiegec/device_tree-rs&quot;&gt;device_tree-rs&lt;/a&gt; 读取 bbl 传过来的 dtb 地址，找到各个 &lt;code class=&quot;highlighter-rouge&quot;&gt;virtio_mmio&lt;/code&gt; 总线以后按照设备类型找到对应的设备。然后就是对着 virtio 的标准死磕，同时看 Linux 和 QEMU 的源代码辅助理解，最后终于是成功地把收/发的两个 virtqueue 配置好，并且在中断的时候处理收到的包。这个时候，可以成功地输出收到的包的内容，并且发出指定内容的包了。效果就是看到了这样的图片（图中网站是 &lt;a href=&quot;https://hpd.gasmi.net/&quot;&gt;Hex Packet Decoder&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/arp_packet.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基于此，写了一个简单的以太网帧的解析，ARP 的回复和 ping 的回复（直接修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO_REQUEST&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ECHO_REPLY&lt;/code&gt; 然后更新 CHECKSUM），实现了最基本的 ping ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/arping.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ping.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;显卡驱动&quot;&gt;显卡驱动&lt;/h1&gt;

&lt;p&gt;网卡可以用了，很自然地会想到做一些其他的 virtio 驱动，第一个下手的是显卡。显卡和网卡的主要区别是，网卡是两个 queue 异步作，而在显卡驱动上则是在一个 queue 上每次放一输入一输出的缓冲区来进行交互，具体步骤在 virtio 标准中也写得很清楚。在这个过程中， QEMU 的 Tracing 功能帮了很大的忙，在调试 desc 的结构上提供了很多帮助。&lt;/p&gt;

&lt;p&gt;然后就在 framebuffer 上花了一个 mandelbrot ：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mandelbrot.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 @shankerwangmiao 的建议下，调了一下颜色：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mandelbrot2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就好看多了。&lt;/p&gt;

&lt;h1 id=&quot;http-服务器&quot;&gt;HTTP 服务器&lt;/h1&gt;

&lt;p&gt;在 @wangrunji0408 的提醒和建议下，我开始把一个 Rust 实现的网络栈 &lt;a href=&quot;https://github.com/m-labs/smoltcp&quot;&gt;smoltcp&lt;/a&gt; 集成到代码中来。这个库中，对底层 Interface 的要求如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当可以发包并且可以收包的时候，返回一收一发两个 Token ，并在使用的时候调用指定的函数。&lt;/li&gt;
  &lt;li&gt;当可以发包的时候，返回一个发的 Token ，含义同上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是我第一次看到这种抽象，而且也没有特别明确的文档表示，这个 Token 代表什么，我应该提供什么。我直接按照一些已有的例子，照着实现了一把。过程中遇到了 ownership 的问题，通过 Arc 和 Mutex 解决了，然后又出现了死锁的问题，调了半天才调出来。&lt;/p&gt;

&lt;p&gt;接着按照 somltcp 的样例写一个简单的 udp echo server 和（假的） tcp 服务器：&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// simple http server&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockets&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TcpSocket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcp_handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.is_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.can_send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;write!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HTTP/1.1 200 OK&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Server: rCore&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-Length: 13&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Content-Type: text/html&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Connection: Closed&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Hello, world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.unwrap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然很粗暴，但是 work 了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/http.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;鼠标驱动和块设备驱动&quot;&gt;鼠标驱动和块设备驱动&lt;/h1&gt;

&lt;p&gt;接着自然是往 QEMU 支持的剩下的 virtio 设备里下手。首先下手的是鼠标驱动。这次遇到了新的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;由于缓冲的存在，每次只有在 EV_SYN 的时候才会一次性把若干个事件放入队列中。&lt;/li&gt;
  &lt;li&gt;一个事件就要一个 desc chain ，意味着直接串足够大小的 buffer 到同一个 desc chain 中并不能工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是只好痛定思痛照着 Linux 内核的实现把完整的 Virtqueue 的操作实现了，并且顺带把前面的网卡和显卡的驱动也更新了。果然，每次都是三个左右的事件（X，Y，SYN）插入，然后根据这些事件就可以计算出当前的鼠标位置了。&lt;/p&gt;

&lt;p&gt;至于块设备，遇到的则是别的坑。看标准的时候，本以为就一个结构体 virtio_blk_req 就搞完了，但仔细读了读，标准似乎没讲清楚，读的时候是怎么传，写的时候又是怎么传。于是在这里卡了很久，从 Tracing 信息可以看出，QEMU 一直认为我提供的 buffer 大小不正确，多次实验之后发现，给 device 写入的 buffer 大小为 block size 的整数倍加一，这个一存放的是状态，其他则是数据，真的太坑了。&lt;/p&gt;

&lt;p&gt;有了块设备以后，就可以替换掉原来的内嵌 SFS 的方案，转为直接从块设备读 SFS 文件。这里我没想明白 lazy_static 和 ownership 的一些问题，最后也则是@wangrunji0408 的帮助我解决了。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;用 Rust 写出一个可以工作的驱动并不难，只要知道 unsafe 怎么用，但是一旦需要深入思考这里应该用什么安全的方法封装的时候，才发现是个很困难的事情。现在虽然工作了，但是很多地方线程并不安全，代码也不够简洁高效，以后还有很多需要改进的地方。&lt;/p&gt;

&lt;h1 id=&quot;see-also&quot;&gt;See also&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/oasis-tcs/virtio-spec&quot;&gt;Virtio Spec&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 29 Jan 2019 17:23:00 +0800</pubDate>
        <link>https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation/</link>
        <guid isPermaLink="true">https://jiege.ch/programming/2019/01/29/virtio-drivers-implementation/</guid>
        
        <category>driver</category>
        
        <category>rcore</category>
        
        <category>linux</category>
        
        <category>virtio</category>
        
        
        <category>programming</category>
        
      </item>
    
  </channel>
</rss>
